# leetcode

[TOC]

---

- [二分搜索法总结](./docs/binary_search.md)

- [动态规划总结]

- [回溯法总结](./docs/backtracking.md)

---

## 1. Two sum

使用 hash 表来记录已经存储的数据，新来的数据与 target 做差，判断是否在 hash 表中存在

## 5. Longest Palindromic Substring

正常方法要区分奇偶串，但是也可以首先便遍历中间重复的字符，将奇数偶数串统一处理

或者使用动态规划的方法，dp[i][j]表示这个 ij 区间内的是回文字符串，那么有递推公式：

```c++
dp[i][j] = true
{
if i==j
if j-1<2 && s[i]==s[j]
if dp[i+1][j-1]==true && s[i]==s[j]
}
```

## 6. zig-zag Conversion

o(n)time o(1)space 的算法是找到每一排循环的规律，是按照一定的周期循环的，或者可以使用 o(n)space ,不断的调整填充辅助数组的方向进行填充

## 7. reverse integer

这里要求时说如果 int 反转之后超如了有符号位 32 位大小的限制范围，那么就要返回 0，可以将结果先用 long 保存，然后在计算，并比较最后的结果是否超出了范围，并返回比较后的结果

## 9. Palindrome Number

这里如果是负数一定不是 Palindrome Number， 然后可以转化为字符串用双指针来做

还有一种方法就是，可以将数字进行反转，然后比较二者是否相等，或者可以比较一半，这种方法最快，就是将原本剩下砍掉的数字和新累乘的数字进行比较，知道新的数字大于剩下砍掉的数字，但是要注意边界条件，数字可以被 10 整除的是非常特殊的。

## 14. Longest Common Prefix

先排序，排好序找到最短的字符串的长度，然后遍历最短字符串长度，逐个比较排序后的第一个字符串和最后一个字符串

## 15. three-num

类似于 two num 题目的解法，但是不同的是要固定一个数字，然后找到另外两个数字，同时需要注意不要有重复的组合出现，解决方法是对于相同的数字，我们就将 index 跳过。

## 17. letter combination of a phone number

递归解法，类似于回溯的层级递归解法，整体的结构就是一个树形网络，在数行网络的最低端返回结果

补充：典型的回溯解法，就是设置 help 的参数一般包括&path，&paths,遇到层级底部，将 path 添加到 paths，然后函数返回并，将 path 最后一位去掉，这样就可以遍历所有情况。回溯和 DFS 很像，但是也有区别的地方，主要是以下几点：

Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在 可达性问题 ，这种问题只需要执行到特点的位置然后返回即可。
- 而 Backtracking 主要用于求解 排列组合 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

## 19. Remove Nth Node From End of List

这道题目让去除链表里面倒数第 n 个元素。

可以开始让 head 不断前进，然后 count 计数。如果计数大于等于 n，另一个指针 item 开始前进，当 head 到达末尾的时候，item 就到达了目标位置。需要注意的是细节的处理，使用 pre 指针很方便。

## 20. Valid Parentheses

判断括号的完整性质，使用堆栈实现即可。

## 21. Merge Two Sorted Lists

这道题目是将两个已经排序的链表进行融合，注意的一点就是设置一个 pre 指针，然后不断的添加就可以。

## 24. Swap Nodes in Pairs

这道题目是按照次序交换相邻的两个节点。注意处理好 next 的关系和循环停止条件。

## 34. find first ans last position of element in sorted array

二分查找，可以使用两次二分，也可以使用一次二分之后，将 target 加 1,继续进行二分。本质是一道二分查找第一个大于等于 target 的位置的题目。

## 39. combination

组合求和。这道题目要求根据提供的数字来组合出来和为 target 的数字组合，每个数字可以使用多次，但是最终的结果不能重复。

还是经典的组合问题，用回溯法进行解决。设计的关键有两点，一点是如何判断添加到 paths 的条件，这里就是 path 各个元素的和等于 target。另一个就是如何添加新的元素到 path，这里就是如果新的元素大于等于 path 的末尾元素，那么就可以添加进去，目的是确保没有重复的组合出现，因为 2，2, 3 和 2, 3, 2 是同一种组合。

## 40. combination-sum-2

组合求和 2. 这道题目还是根据提供的数字组合出来和为 target 的数字组合，但是备选数字有重复，而且每个位置的数字只能使用一次，最终结果也不能重复。

由于是组合，那么 2,2,3 和 2,3,2 是一个组合。

因此，还是经典的组合问题，使用回溯方法进行解决。需要注意的是，这里由于结果必须是不同的组合，因此最好先对数组进行排序，然后新添加的数字必须大于等于 path 最后一个数字。

又由于备选数字有重复，因此每次添加新数字的时候，如果前一个数字没有访问标记，并且当前数字等于前一个数字，那么说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此跳过。同时如果当前数字已经被访问过，那么也不能重复访问，也直接跳过。

## 46. permutation

这道题目是排列组合所有可能的数字组合，但是数字只能使用一次，且数字之间都是互不相同的。这是典型的组合问题，可以使用回溯方法进行解决。注意每次插入新的数字的时候，要插入和 path 里面已有的数字的不同的数字

## 47. permutations-2

这道题目是排列组合题目的一个变形，不同之处在于数字之间可能有重复，每个位置的数字可以使用一次。生成的最后结果不能相互有重复。

注意每次添加新的数字的时候，前一个数字如果没有访问标记（visit）,并且当前数字等于前一个数字，说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此直接跳过。同时，如果当前数字已经被标记（visit）,那么不重复访问，也直接跳过。

## 53. maximum subarray

有两种方法，一种是迭代的方法，就是分而治之。那么最大值就是左侧数组的最大值，右侧数组的最大值，以及从中间值向两边进行遍历，记录遍历过程中经过的最大值。那么最大值就是这三个最大值中的较大那个。另一种方法是比较巧妙，设置两个变量，分别是总的最大值，一个是当前遍历的临时最大值。然后用临时最大值加上当前遍历的数值，如果和小于当前数值，那么说明前面的累计是负面效应的，还不如只用当前遍历的数字，那么就更新临时最大值为当前便利的数值。如果和大于当前数值，那么说明前面的累计是有正面作用的，将临时最大值更新为新的和。同时，在每次更新临时最大值的时候都更新总的最大值，用 max 函数，记录这些更新历史过程中的总的最大值，即为最后结果。

## 62. unique-paths

典型的动态规划问题，要求是要寻找矩阵从左上角到右下角的所有可能的情况，那么某一点的情况是他左侧点的情况和上面点的情况的加和。注意最上边和最左边都是 1,然后遍历填满 dp 矩阵即可。

## 64. minimum-path-sum

典型的动态规划问题，由于是二维矩阵，建立一个二维 dp 数组比较合适。

递推关系式是到达 grid[i][j]的最短距离，取决于达到该点左侧和上侧最短距离之间的最小值，在加上该点的距离，然后 for 循环遍历一遍，填满 dp 数组就可以了。

## 67. add-binary

实现二进制加法。

首先将 a 确保为较长的字符串（使用 swap 交换）,然后设计一个 up 参数，如果两个数相加等于 0, 等于 1，等于 2,等于 3,分别进行不同的处理。

最后注意，如果 up 最后还是等于 1,那么就在前面还要加一个 1.

## 69. sqrt-x

可以使用数学解法进行球见，就是找到等式，转化为牛顿法，牛顿法的递推公式就是 Xn+1 = Xn - fx / fx'。 还有一种通用的解法，就是使用二分法

## 70. 爬梯子

典型的动态规划题目，递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。`dp[i] = dp[i-1]+dp[i-2];`

## 72. edit-distance

这道题目是使用三种手段来将两个字符串变成一致，分别时删除，增加，修改。

使用 dp[i][j]用来表示字符串 1 的 0~i-1、字符串 2 的 0~j-1 的最小编辑距离；
我们可以知道边界情况：dp[i][0] = i、dp[0][j]=j；
同时对于两个字符串的子串，都能分为最后一个字符相等或者不等的情况：
如果 words[i-1] == words[j-1]：dp[i][j] = dp[i-1][j-1]；也就是说当前的编辑距离和位置 i 和 j 的字符无关；
如果 words[i-1] != words[j-1]：则存在三种可能的操作：

```
向 word1 插入：dp[i][j] = dp[i][j-1] + 1;
从 word1 删除：dp[i][j] = dp[i-1][j] + 1;
替换 word1 元素：dp[i][j] = dp[i-1][j-1] + 1;
```

## 75. sort colors

荷兰国旗问题，可以设置三个索引指针来进行解决，分别是左侧，当前，右侧

## 77. conbination

这道题目属于比较经典的组合问题，只不过这道题目的组合的长度是自定义可以变化的，仅仅需要修改添加到 paths 的条件即可。

## 78. subsets

递归，回溯法。要设置的变量 paths , path， index, nums(输入变量)

## 79. word search

这道是一个典型的回溯的题目，回溯是 DFS 的一种，但是有一个区别就是回溯在每次调用函数进行递归结束之后要把标记删除掉，这样下次其他递归还可以使用相应的对象。普通 DFS 是找一个可达性，而回溯包括一些匹配与排列组合的概念在里面，因此一个排列组合不对，要把标记清楚，可能其他排列组合就用上了。

还有要注意的一点就是，对于结果是 bool 类型，要把 bool 结果作为函数进行返回，多个返回之间进行取或，因为或操作如果有一个是 true 就整体是 true，后面的就不需要判断了，因此这样能加快函数进行，如果放在&参数里面进行返回，那么每一种情况都会进行，会白跑一些情况。

## 83. Remove Duplicates from Sorted List

这道题目是去除有序链表里面的重复数组，关键的步骤就是如果判断 head->val == head->next->val 那么就 head->next = head->next->next;

## 84. Maximal Rectangle

使用类似于 84 的解法，将原来的矩阵从上到下，具有连续 1 的累加起来，不连续的变为 0，这样没一个新产生的行使用 84 的解法计算，找到最大值。

## 87. scramble-string

可以使用递归或者动态规划的解法。（1）递归解法就是遍历不同的切割方法，但是每种情况不仅要左右对称比较，还要左右交叉比较。需要注意的是，要预先比较两个字符串字符是不是字母都一样，如果不一样肯定返回 false，这样可以加快速度，否则递归会超时。（2）DP 解法是设计三维的 dp 矩阵，三个维度分别是左串起始，右串起始，长度。递推方案是先解决所有长度为 1 的情况，遍历即可。然后对于长度高一层级的情况，都有低一层级的所有子情况推出来，具体递推公式就是左右对称比较和交叉比较，然后逐渐升高长度大小，最终得到最终结果。

动态规划的过程可以看作就情况的逆过程，递推是从最高维度向下分解，但是分解的子情况可能有很多是重复的，这时候会增加计算量，动态情况是找到里面的构建规律，然后逐渐推倒到我们想要的结果，是从最简单情况到复杂情况的过程，而递推是复杂情况渐分解到最简单情况的过程。

## 88. merge-sorted-array

双指针。从尾部开始遍历，逐渐把较大的数字往后放。注意结束的条件是两种：2 数组先到头，那么直接结束，因为 1 数组前面的数字还在原来的位置上。另一种情况是 1 数组先到头，那么就不用比较了，直接将剩下的 2 数组内容依次填好。

## 90. subsets 2

求子集，这道题目是根据备选的数字，找到所有可能组合的子集。注意备选的数字可能有重复。

这里由于备选的数字有重复，因此对于前一个数字没有访问标记，但是当前数字和前一个数字相同的，说明处于同一个位置，那么直接跳过。

由于组合不能有重复，因此新的数字要大于等于 path 的末尾数字，同时对于当前已经正在访问的数组，直接跳过。

## 91. Decode Ways

动态规划解法，使用一个数组 dp 表示记录的数据，列写出动态规划的递推方程，dp[i]=dp[i-1]+dp[i-2],不过这里的递推公式因为边界条件不一样而有所不同。

## 93. restore ip addresses

使用回溯法进行解决，但是要主要判断几个条件不能当作 ip 地址中间的段，分别是：要在 0 ～ 255 之间，不能有 010,001 这样的情况，段的大小要和 i 相等，否则可能在最终结果中加入了相同的东西。

还可以暴力一点，四个 for 循环便利所有可能情况，并对总数目等于 s 大小的去进一步判断，判断每一个段是不是符合那几个条件，如果符合就是最终结果。

## 94. Binary Tree Inorder Traversal

可以使用递归的方法，也可以使用非递归的方法。

下面再来看非递归使用栈的解法，也是符合本题要求使用的解法之一，需要用栈来做，思路是从根节点开始，先将根节点压入栈，然后再将其所有左子结点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中。这样就保证了访问顺序为左-根-右，

## 95. unique binary search trees 2

分而治之思想，这里也可以使用记忆 hash 表或者记忆数组进行记录，本质上，使用记忆数组的递归是动态规划的一种。

## 101. symmetric-tree

使用递归的思想可以判断，判断右子树的左子树是不是相等，判断左子树的右子树是不是相等。

## 104. Maximum Depth of Binary Tree

计算树的高度，使用递归的思想可以完成。

## 108. Convert Sorted Array to Binary Search Tree

将一个有序数组转化为一个 BST,使用递归实现，逐步将最中间的数字作为根节点。

## 109. Convert Sorted List to Binary Search Tree

对于寻找一个链表的中点的问题，可以使用快慢指针实现。

## 110. Balanced Binary Tree

这道题目是判断是不是平衡二叉树，首先需要判断二叉树的高度，然后使用递归的思想判断是不是 BST,如果一个树是 BST，那么他的两个子树都是 BST，且两个子树的高度相差不超过 1。

## 111. Minimum Depth of Binary Tree

这道题目是计算根节点到叶子节点的最短路径，可以使用递归实现。

## 112. path sum

这道题目也可以使用递归进行判断，然后注意边界条件就可以。

## 121. Best Time to Buy and Sell Stock

设置两个变量一个是最大利润，一个是到当前之间为止，前面的最小买入价格，然后遍历，再每次遍历的时候，计算当前卖出价格和前面最小买入价格的差价

## 122. Best Time to Buy and Sell Stock 2

使用贪心的思想，只要后一天比前一天价格高，就会有利润，因此可以计算后一天比前一天收益大于 0 并累积

## 123. Best Time to Buy and Sell Stock III

这道是买股票的最佳时间系列问题中最难最复杂的一道，前面两道 Best Time to Buy and Sell Stock 和 Best Time to Buy and Sell Stock II 的思路都非常的简洁明了，算法也很简单。而这道是要求最多交易两次，找到最大利润，还是需要用动态规划 Dynamic Programming 来解，而这里我们需要两个递推公式来分别更新两个变量 local 和 global，参见网友 Code Ganker 的博客，我们其实可以求至少 k 次交易的最大利润，找到通解后可以设定 k = 2，即为本题的解答。我们定义 local[i][j]为在到达第 i 天时最多可进行 j 次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义 global[i][j]为在到达第 i 天时最多可进行 j 次交易的最大利润，此为全局最优。它们的递推式为：

local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)

global[i][j] = max(local[i][j], global[i - 1][j])

其中局部最优值是比较前一天并少交易一次的全局最优加上大于 0 的差值，和前一天的局部最优加上差值中取较大值，而全局最优比较局部最优和前一天的全局最优

---

这道题是 Best Time to Buy and Sell Stock 的扩展，现在我们最多可以进行两次交易。我们仍然使用动态规划来完成，事实上可以解决非常通用的情况，也就是最多进行 k 次交易的情况。
这里我们先解释最多可以进行 k 次交易的算法，然后最多进行两次我们只需要把 k 取成 2 即可。我们还是使用“局部最优和全局最优解法”。我们维护两种量，一个是当前到达第 i 天可以最多进行 j 次交易，最好的利润是多少（global[i][j]），另一个是当前到达第 i 天，最多可进行 j 次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j]）。下面我们来看递推式，全局的比较简单，

global[i][j]=max(local[i][j],global[i-1][j])，

也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。对于局部变量的维护，递推式是

local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)，

也就是看两个量，第一个是全局到 i-1 天进行 j-1 次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要 j-1 次交易，最后一次交易取当前天），第二个量则是取 local 第 i-1 天 j 次交易，然后加上今天的差值（这里因为 local[i-1][j]比如包含第 i-1 天卖出的交易，所以现在变成第 i 天卖出，并不会增加交易次数，而且这里无论 diff 是不是大于 0 都一定要加上，因为否则就不满足
local[i][j]必须在最后一天卖出的条件了）。
上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是 O(n\*k)，如果是最多进行两次交易，那么复杂度还是 O(n)。空间上只需要维护当天数据皆可以，所以是 O(k)，当 k=2，则是 O(1)。代码如下： 
————————————————
版权声明：本文为 CSDN 博主「Code_Ganker」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/linhuanmars/article/details/23236995

## 125. Valid Palindrome

双指针，两边开始便利，但是要注意边界条件：如果一个字母也没有

## 127. word ladder

BFS 查找，主要是要判断好只相差一个字母的两个字符串，如果只相差一个字母，就认为他们在图上是相邻的。

## 128. Longest Consecutive Sequence

这道题要求求最长连续序列，并给定了 O(n)复杂度限制，我们的思路是，使用一个集合 HashSet 存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后分别用两个变量 pre 和 next 算出其前一个数跟后一个数，然后在集合中循环查找，如果 pre 在集合中，那么将 pre 移除集合，然后 pre 再自减 1，直至 pre 不在集合之中，对 next 采用同样的方法，那么 next-pre-1 就是当前数字的最长连续序列，更新 res 即可。这里再说下，为啥当检测某数字在集合中存在当时候，都要移除数字。这是为了避免大量的重复计算，就拿题目中的例子来说吧，我们在遍历到 4 的时候，会向下遍历 3，2，1，如果都不移除数字的话，遍历到 1 的时候，还会遍历 2，3，4。同样，遍历到 3 的时候，向上遍历 4，向下遍历 2，1，等等等。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效，所以我们要从 HashSet 中移除数字，

## 130. surrounded regions

先遍历四周，将遍历的区域全部变为第三个字母，比如‘T’，然后全部扫描一遍，将 O 变成 X,将 T 变成 O,这里遍历可以使用 BFS 或者 DFS，同时，主要到 DFS 可以使用递归来实现，写一个 help 函数 dfs，如果找到联通的点，就递归进去，直到最深处在回来，和 DFS 的本质思想是一样的

## 131. palindrome-partition

这道题目是根据给定的字符串，然后找到所有可能将字符串进行分割，使得分开的每一个字符串都是一个回文序列。

首先写一个工具函数，判断是个字符串是不是回文序列。

然后因为本质上还是组合问题，因此仍然使用回溯法。回溯 help 函数参数包括 paths，path，和起始 index。 从起始 index 起始遍历所有长度 length, 直到起始 index+length==s.size()，判断子字符串是不是回文序列。

如果是回文序列，就添加到 path 里面，并继续深入进行探索，但是起始 index 要增加 length。

最终判断是否添加到 paths，就是看看起始 index 是否达到了 s 的大小，说明已经探索到了末尾。

## 136. single number

使用异或进行处理，异或满足交换率和结合率，可以将两个相同大小的数字消掉。

## 137. single number 2

使用标记的 ones twos 变量进行每一个位的 1 的个数的记录，也可以推广到其他的问题， 比如三个四个重复的数字

## 139. word-break

这道题目是计算是否可以从备选的单词片段中组成目标单词。

dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。

该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 "leetcode"：

["lee", "tc", "cod"]

求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。

## 141. linked list cycle

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。如果快指针到达末尾，则说明没有环。

## 144. Binary Tree Preorder Traversal

前序遍历。可以递归，也可以使用栈进行 DFS。

## 145. Binary Tree Postorder Traversal

二叉树的后序遍历。可以使用递归实现

```
void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}
```

也可以使用非递归实现：
前序遍历为 root -> left -> right，后序遍历为 left -> right -> root。可以修改前序遍历成为 root -> right -> left，那么这个顺序就和后序遍历正好相反。

## 153. find minimum in rotated sorted array

二分查找，关键是找到二分查找的分割条件。

## 155. Min Stack

这道题目是实现一个可以随时返回堆栈里面最小值的堆栈。只需要设置两个堆栈即可，其中一个堆栈保持最小值。然后注意一些进入最小值的堆栈的细节即可。

## 160. Intersection of Two Linked Lists

这道题目是确定两个链表的相交焦点。

可以使用循环两次的方法，当其中一个链表到达结尾之后，跳转到另一个链表。

如果有焦点，那么循环两次之后一定在焦点相遇，如果没有焦点，那么一定在链表的末尾相遇，而且都是 NULL;

## 167. two sum 2

这里是用双指针，不断判断当前两个数字的和与 target 的大小，然后移动相应的指针，指导两个指针相遇或者找到了两个匹配的数字

## 168. excel-sheet-column-title

这里就是注意将输入的数字减一进行处理，可以用递归也可以不用递归

## 169. majority-element

寻找数组中最大 majority，即数目超过 n/2 的个数的数字，这里可以使用很多种方法：（1）排序，返回中间值。（2）摩尔计数。即确定一个摩尔基数器，开始赋值为 0,当预选数字和当前遍历的数字相等的时候，计数器加一，当不相等的时候，计数器减一。如果计数器等于 0 了，那么赋值当前预选数字为当前遍历的数字。所有数字全部遍历完成后，预选数字即为 majority。（3）位操作。如果一个数字是 majority，那么每一个位上面的最大个数的位（0 或 1），组成的二进制数字就是 majority，可以遍历每一个位来寻找。（4）递归+分而治之。可以分左右两个子数组进行递归，返回的左右结果如果相同，那么就是 majority，如果不同，需要比较两个数字的个数谁大。（5）hash 表。可以按顺序遍历，存放到 hash 表中，如果相同就加一，直到个数超过 n/2 就返回。

## 171. excel-sheet-column-number

和 168 本质是一样的，就是注意字母的对应关系是：数字减一与相应字母对应

## 172. Factorial Trailing Zeroes

这道题目是计算 n 的阶乘的末尾 0 的数量。

尾部的 0 由 2 \* 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。

对于一个数 N，它所包含 5 的个数为：N/5 + N/5^2 + N/5^3 + ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5^2 表示不大于 N 的数中 5^2 的倍数再贡献一个 5 ...。

## 188. Best Time to Buy and Sell Stock IV

这道题目是题目 123 的一般性推广，递推公式可以参考题目 123,但是需要注意的是，如果 k >= prices.size()/2,直接使用贪心算法计算即可（参考题目 122）。

## 190. reverse bits

可以按照单独一个位一个位进行处理，也可以按照四个位或更多的位一起进行处理，但是要提前计算好对应的映射表

## 191. numbers of 1 bits

可以使用 n&(n-1)， 它的作用是可以把 n 的二进制表示中的最低位为 1 的改为 0，每更改一次计数器+1，直到 n=0 停止

## 198. house-robber

动态规划经典题目，递推公式是 dp[i] = max(dp[i-1], dp[i-2]+ nums[i]) 也可以修改为长量的额外空间算法，使用 pre 和 pre_pre 两个变量代表 dp[i-1]和 dp[i-2],并不断更新这两个变量

## 200. number of islands

BFS 或 DFS 和题目 695 很像，这道题目不需要计数，只需要遍历完毕之后，在总数目上面加 1 即可，不需要求最大面积。只需要求岛的个数。

## 204. count-primes

这道题目是计算小于 n 的所有质数，质数是因子仅仅包括自己和 1 的数字。1 不是质数。

这道题目的思想是： 从 2 开始遍历到 n，先找到第一个质数 2，然后将其所有的倍数全部标记出来，然后到下一个质数 3，标记其所有倍数，一次类推，直到根号 n，此时数组中未被标记的数字就是质数。我们需要一个 n-1 长度的 bool 型数组来记录每个数字是否被标记， 这就是实现埃拉托斯特尼筛法，难度并不是很大。

## 205. Isomorphic Strings

这道题目是判断两个字符串是不是同构的。

可以使用字符串数组 128 来代表所有字符，设计 t1,t2，题目说两个字符串的大小相等，那么开始遍历，将两个字符串当前的两个字符，都在 t1 与 t2 里面记录下来，记录下来的标记就是当前的下标加 1（为了与初始化的 t1 和 t2 区分开来）。

如果发现某一次 t1 和 t2 对应的位置不同，要么是一个被访问过，一个没被访问过，要么是两个都被访问过，但是二者上一次出现的位置不同，这两种情况都说明，这两个字符串不是同构的，返回 false 即可，全部遍历完成都没问题，那么返回 true 即可。

## 206. Reverse Linked List

链表反转。

包括迭代方法和递归方法。迭代方法就是设置一个 pre 指针，然后不断插入到 pre->next。递归方法就是不断进行递归，每次递归返回一个头指针，注意保存临时变量。

重要注意的点就是算清楚 next 的链接关系。

## 207. Course Schedule

这道课程清单的问题对于我们学生来说应该不陌生，因为我们在选课的时候经常会遇到想选某一门课程，发现选它之前必须先上了哪些课程，这道题给了很多提示，第一条就告诉我们了这道题的本质就是在有向图中检测环。 LeetCode 中关于图的题很少，有向图的仅此一道，还有一道关于无向图的题是 Clone Graph。个人认为图这种数据结构相比于树啊，链表啊什么的要更为复杂一些，尤其是有向图，很麻烦。第二条提示是在讲如何来表示一个有向图，可以用边来表示，边是由两个端点组成的，用两个点来表示边。第三第四条提示揭示了此题有两种解法，DFS 和 BFS 都可以解此题。我们先来看 BFS 的解法，我们定义二维数组 graph 来表示这个有向图，一维数组 in 来表示每个顶点的入度。我们开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后我们定义一个 queue 变量，将所有入度为 0 的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为 0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为 0，则说明环存在，返回 false，反之则返回 true。

下面我们来看 DFS 的解法，也需要建立有向图，还是用二维数组来建立，和 BFS 不同的是，我们像现在需要一个一维数组 visit 来记录访问状态，这里有三种状态，0 表示还未访问过，1 表示已经访问了，-1 表示有冲突。大体思路是，先建立好有向图，然后从第一个门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用 DFS 递归，直到出现新的课程已经访问过了，则返回 false，没有冲突的话返回 true，然后把标记为已访问的课程改为未访问。

## 208. Implement Trie (Prefix Tree)

这道题让我们实现一个重要但又有些复杂的数据结构-字典树， 又称前缀树或单词查找树，详细介绍可以参见[网友董的博客](http://dongxicheng.org/structure/trietree/)，例如，一个保存了 8 个键的 trie 结构，"A", "to", "tea", "ted", "ten", "i", "in", and "inn"

字典树主要有如下三点性质：

1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。

2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。

3. 每个节点的所有子节点包含的字符串不相同。

字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第 i 次循环找到前 i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。至于结点对儿子的指向，一般有三种方法：

1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；

2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；

3、使用左儿子右兄弟表示法记录这棵树。

三种方法，各有特点。第一种易实现，但实际的空间要求较大；第二种，较易实现，空间要求相对较小，但比较费时；第三种，空间要求最小，但相对费时且不易写。

我们这里只来实现第一种方法，这种方法实现起来简单直观，字母的字典树每个节点要定义一个大小为 26 的子节点指针数组，然后用一个标志符用来记录到当前位置为止是否为一个词，初始化的时候讲 26 个子节点都赋为空。那么 insert 操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，若不存在则新建一个，然后再查找下一个。查找词和找前缀操作跟 insert 操作都很类似，不同点在于若不存在子节点，则返回 false。查找次最后还要看标识位，而找前缀直接返回 true 即可

## 210. Course Schedule II

这道题目和题目 207 很像，就是让我们把课程记录下来，还是使用题目 207 一样的方法，比如使用迭代的方式，就是使用队列，关键是在每次队列弹出元素的时候，加入到 ans 就可以了。

## 213. house-robber2

这道题目也是典型的动态规划问题，可以得到递推公式就是当前所抢劫的户的最大钱数，等于到上上一个户的最大钱数加上当前户的钱数 与 抢劫到上一个户最大钱数的 的二者最大值。

这道题目多了一个要求，就是户是环型的，最后一个户和第一个户不能一起抢。那么可以将这个环问题拆开，我先只抢 0 ～ n-2，在抢 1 ～ n-1，这样第一个户和最后一个户不会被同时抢到，我们再取这两种情况的最大值就可以了。

## 215. kth largest element in an array

可以使用很多种方法：（1）使用 std 的函数 nth_element() 或者 partial_sort() (2) 使用小顶堆，维护一个 K 大小的大顶對，遍历数组，如果当前数字小于小顶堆的最小值，就添加进去，并删除堆顶元素。（3）使用大顶堆，将数组所有元素添加进去，然后不断弹出 K 次堆顶元素。（4）使用快速排序的思想，对数组进行分区。 对于使用堆的方法，可以使用 std 的 priority_queue 来构建，也可以使用 multiset()来构建，也可以使用自己构建的数组来自行构建堆结构。

## 216. combination-sum-3

组合求和，这道题目是根据 1-9 备选数字，选出特定组合求和等于 target 的组合，注意这个组合不能有重复的，而且数组 1-9 只能使用一次，而且长度等于 k 的组合。

这里组合不能有重复的，我们考虑后来新添加到 path 的数字必须大于 path 末尾的数字，这样就能保证数组之间没有重复的。

而且对于 path 能够进入 paths 的标准，如果 path_sum 大于 target,那么直接返回，如果 path 的长度达到了 k,那么判断 path_sum 如果等于 target，那么就可以进入 path_sum,如果不等于，那么就直接返回。

## 217. Contains Duplicate

使用 hash_set 实现即可。

## 225. Implement Stack using Queues

这道题目是用队列实现堆栈，使用一个队列即可，关键就是每次添加新的元素的时候，将原本的的元素都一次挪到后面，让新元素排到第一位。

## 226. Invert Binary Tree

这道题目是翻转二叉树，使用递归的思想即可以。

## 230. Kth Smallest Element in a BST

可以使用中序遍历，对于一个 BST 来说，他的中序遍历序列是递增的。

因此我们中序遍历，就可以很方便的寻找到第 k 个数字。

## 232. Implement Queue using Stacks

这道题目是使用堆栈实现队列，关键点就是设置两个堆栈。

## 234. Palindrome Linked List

这道题目判断链表是不是回文序列。
使用快慢指针，可以找到链表的最中间的位置，一个指针从头开始，一个指针从中间开始， 然后可以判断链表两半部分是不是相等。

## 235. Lowest Common Ancestor of a Binary Search Tree

这道题我们可以用递归来求解，我们首先来看题目中给的例子，由于二叉搜索树的特点是左<根<右，所以根节点的值一直都是中间值，大于左子树的所有节点值，小于右子树的所有节点值，那么我们可以做如下的判断，如果根节点的值大于 p 和 q 之间的较大值，说明 p 和 q 都在左子树中，那么此时我们就进入根节点的左子节点继续递归，如果根节点小于 p 和 q 之间的较小值，说明 p 和 q 都在右子树中，那么此时我们就进入根节点的右子节点继续递归，如果都不是，则说明当前根节点就是最小共同父节点，直接返回即可

## 236. Lowest Common Ancestor of a Binary Tree

这道求二叉树的最小共同父节点的题是之前那道 Lowest Common Ancestor of a Binary Search Tree 的 Follow Up。跟之前那题不同的地方是，这道题是普通是二叉树，不是二叉搜索树，所以就不能利用其特有的性质，我们只能在二叉树中来搜索 p 和 q，然后从路径中找到最后一个相同的节点即为父节点，可以用递归来实现，在递归函数中，首先看当前结点是否为空，若为空则直接返回空，若为 p 或 q 中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了 p 和 q 一定都在二叉树中存在，那么如果当前结点不等于 p 或 q，p 和 q 要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论：

- 若 p 和 q 分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回 p 和 q 结点的位置，而当前结点正好就是 p 和 q 的最小共同父结点，直接返回当前结点即可，这就是题目中的例子 1 的情况。

- 若 p 和 q 同时位于左子树，这里有两种情况，一种情况是 left 会返回 p 和 q 中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子 2 的情况。还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的左子树中的某个结点才是 p 和 q 的最小父结点，会被返回。

- 若 p 和 q 同时位于右子树，同样这里有两种情况，一种情况是 right 会返回 p 和 q 中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的右子树中的某个结点才是 p 和 q 的最小父结点，会被返回，写法很简洁

## 238. Product of Array Except Self

这道题给定我们一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限定了时间复杂度 O(n)，并且不让我们用除法。如果让用除法的话，那这道题就应该属于 Easy，因为可以先遍历一遍数组求出所有数字之积，然后除以对应位置的上的数字。但是这道题禁止我们使用除法，那么我们只能另辟蹊径。我们想，对于某一个数字，如果我们知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果，所以我们只要分别创建出这两个数组即可，分别从数组的两个方向遍历就可以分别创建出乘积累积数组。

我们可以对上面的方法进行空间上的优化，由于最终的结果都是要乘到结果 res 中，所以可以不用单独的数组来保存乘积，而是直接累积到结果 res 中，我们先从前面遍历一遍，将乘积的累积存入结果 res 中，然后从后面开始遍历，用到一个临时变量 right，初始化为 1，然后每次不断累积，最终得到正确结果.

## 240. Search a 2D Matrix II

突然发现 LeetCode 很喜欢从 LintCode 上盗题，这是逼我去刷 LintCode 的节奏么?! 这道题让我们在一个二维数组中快速的搜索的一个数字，这个二维数组各行各列都是按递增顺序排列的，是之前那道 Search a 2D Matrix 搜索一个二维矩阵的延伸，那道题的不同在于每行的第一个数字比上一行的最后一个数字大，是一个整体蛇形递增的数组。所以那道题可以将二维数组展开成一个一位数组用一次二查搜索。而这道题没法那么做，这道题有它自己的特点。如果我们观察题目中给的那个例子，我们可以发现有两个位置的数字很有特点，左下角和右上角的数。左下角的 18，往上所有的数变小，往右所有数增加，那么我们就可以和目标数相比较，如果目标数大，就往右搜，如果目标数小，就往上搜。这样就可以判断目标数是否存在。当然我们也可以把起始数放在右上角，往左和下搜，停止条件设置正确就行

## 241. different ways to add parentheses

可以使用分而治之进行解决，改进一点是可以使用 hash 表记录一些映射，以时间换空间提高计算效率。本题就是按照计算符号将原来的子符串分为两边，两边分别调用原来函数递归得到结果。对于左右的结果，分别遍历交叉计算得到最终的结果。

## 242. Valid Anagram

这道题目让我们判断两个字符串是不是相同字母的。

可以使用 hashmap 来进行统计，又因为这里面仅仅涉及到字母，可以使用大小为 26 的数组，若涉及到各种所有字符，那么可以使用大小为 128 数组。

这里面如果使用 hashmap 空间复杂度计算的时候 O(n),但是使用固定大小的数组的空间复杂度是 O(1)

## 278. first bad version

二分查找

## 279. perfect squares

动态规划。将原问题思考为最初始的简单问题的汇总，这里就是从 n=1 开始，逐渐增加 n,递推关系为 dp[i] = min(dp[i - j * j] + 1, dp[i]);也可以使用 BFS，思路就是假想有一个 graph，里面每个节点如果满足 i=j+squares 即代表二者相连（Node j is connected to node i via an edge if  
and only if either j = i + (a perfect square number) or i = j + (a perfect square number).）。使用广度优先便利即可以找到最短路径。

## 283. Move Zeroes

这道题目让我们将一个数组的所有 0 放在最后面，同时不改变其他数字的相对次序，同时不使用额外的空间。

这个可以使用双指针进行实现。

左边的指针从头开始遍历，右边的指针从第一个 0 数组开始遍历。

然后两个指针一起前进，如果左指针等于 0,右指针非 0,那么交换这两个数字。

如果左指针非 0，那么直接前进，如果右指针等于 0,那么直接前进，直到右指针到达末尾为之。

## 287. Find the Duplicate Number

这道题给了我们 n+1 个数，所有的数都在 [1, n] 区域内，首先让证明必定会有一个重复数，这不禁让博主想起了小学华罗庚奥数中的抽屉原理(又叫鸽巢原理)，即如果有十个苹果放到九个抽屉里，如果苹果全在抽屉里，则至少有一个抽屉里有两个苹果，这里就不证明了，直接来做题吧。题目要求不能改变原数组，即不能给原数组排序，又不能用多余空间，那么哈希表神马的也就不用考虑了，又说时间小于 O(n2)，也就不能用 brute force 的方法，那也就只能考虑用二分搜索法了，在区间 [1, n] 中搜索，首先求出中点 mid，然后遍历整个数组，统计所有小于等于 mid 的数的个数，如果个数小于等于 mid，则说明重复值在 [mid+1, n] 之间，反之，重复值应在 [1, mid-1] 之间，然后依次类推，直到搜索完成，此时的 low 就是我们要求的重复值

## 300. longest-increasing-subsquence

这道题目是求最长子序列。可以使用动态规划进行求解

设计一个数组 dp，dp[i]代表以 nums[i]结尾的最长子序列的长度，然后对于 nums[i],遍历前面的 nums[i](j < i), 如果 nums[i] > nums[j] ，就在 dp[j]上加 1, 说明 nums[j]可以添加到后面的序列中，统计最大值作为 dp[i],然后不断迭代更新。

## 303. range-sum-query-immutable

这道题目比较特殊，构造函数使用一次，子函数调用很多次，所以要求构造函数多做一些任务，子函数做的任务小一些。

这里题目的作用就是返回 i 到 j 之间的求和，那么在构造函数里面，就创建一个数组，数组 i 存储累计到 i 为止的所有元素的和。

子函数直接计算 j-i 就是 i 到 j 之间的和了。

## 309. Best Time to Buy and Sell Stock with Cooldown

这道题目计算股票的最大收益，但是添加了一个条件就是卖出后有一天的冷却期。

设计两个数组，分别是：

have[i],代表第 i 天手里持有股票时的最大收益。

nothave[i]，代表第 i 天手里没有股票是的最大收益。

递推关系式是：

```c++
have[i] = max(have[i-1], (i>=2 ? nothave[i-2] : 0) - prices[i]);
nothave[i] = max(nothave[i-1], have[i-1] + prices[i]);
```

第 i 天 have[i]说明手里有股票，如果没有操作，那么取决于 have[i-1],如果是当天买了，那么取决于 nothave[i-2] - prices[i]，因为有冷却期，取决于前天卖出的最大收益。

第 i 天 nothave[i]说明手里没有股票，如果没有操作，那么取决于 nothave[i-1]，如果当天是卖出，那么取决于 have[i-1]。

## 322. coin-change

这道题目是完全背包问题：想比于普通背包问题，也叫 01 背包问题（例如题目 416），二者区别在于：

> 1. 完全背包问题可以使用无限次物品
> 2. 01 背包问题只能使用一次物品

具体就是体现在循环队列是正序还是倒序列。

我知道，背包问题的递推公式如下：

```c
dp[i] = min(dp[i], dp[i-num]+1);
```

在进行循环遍历的样子如下：

完全背包：

```c
for(int num : coins){
    for(int i=num;i<=amount;i++){
        dp[i] = min(dp[i], dp[i-num]+1);
    }
}
```

01 背包：

```c
for(int num : coins){
    for(int i=amount;i>=num;i--){
        dp[i] = min(dp[i], dp[i-num]+1);
    }
}
```

为什么 01 背包要倒序呢，这是因为 01 背包必须物品只能使用一次，如果正序的话，比如 dp[3]更新了一次，说明使用了当前遍历的物品，那么后续遍历的时候，dp[8]可能用到了 dp[3],又更新一次，那么这个物品又被使用了一次，这是不符合 01 背包物品只能使用一次的规则的。因此倒序进行，先更新 dp[8],这时候使用的 dp[3]肯定是没有被更新过得，保证整个遍历的过程中，物品仅仅被使用一次。

那么对于完全背包问题，由于物品可以使用无限次，那么必须使用正序，倒序反而不合适。

## 326. Power of Three

这道题目是判断 n 是不是 3 的倍数。

一种巧妙的方法，利用对数的换底公式来做，高中学过的换底公式为 logab = logcb / logca，那么如果 n 是 3 的倍数，则 log3n 一定是整数，我们利用换底公式可以写为 log3n = log10n / log103，注意这里一定要用 10 为底数，不能用自然数或者 2 为底数，否则当 n=243 时会出错，原因请看这个帖子。现在问题就变成了判断 log10n / log103 是否为整数，在 c++中判断数字 a 是否为整数，我们可以用 a - int(a) == 0 来判断

## 328. odd even linked list

这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。我们可以使用两个指针来做，pre 指向奇节点，cur 指向偶节点，然后把偶节点 cur 后面的那个奇节点提前到 pre 的后面，然后 pre 和 cur 各自前进一步，此时 cur 又指向偶节点，pre 指向当前奇节点的末尾，以此类推直至把所有的偶节点都提前了即可

## 337. house-robber 3

这道题是之前那两道 House Robber II 和 House Robber 的拓展，这个小偷又偷出新花样了，沿着二叉树开始偷，碉堡了，题目中给的例子看似好像是要每隔一个偷一次，但实际上不一定只隔一个，比如如下这个例子：

```
        4
       /
      1
     /
    2
   /
  3
```

如果隔一个偷，那么是 4+2=6，其实最优解应为 4+3=7，隔了两个，所以说纯粹是怎么多怎么来，那么这种问题是很典型的递归问题，可以利用回溯法来做，因为当前的计算需要依赖之前的结果，那么对于某一个节点，如果其左子节点存在，通过递归调用函数，算出不包含左子节点返回的值，同理，如果右子节点存在，算出不包含右子节点返回的值，那么此节点的最大值可能有两种情况，一种是该节点值加上不包含左子节点和右子节点的返回值之和，另一种是左右子节点返回值之和不包含当期节点值，取两者的较大值返回即可，但是这种方法无法通过 OJ，超时了，所以必须优化这种方法，这种方法重复计算了很多地方，比如要完成一个节点的计算，就得一直找左右子节点计算，可以把已经算过的节点用 HashMap 保存起来，以后递归调用的时候，现在 HashMap 里找，如果存在直接返回，如果不存在，等计算出来后，保存到 HashMap 中再返回，这样方便以后再调用，

## 343. integer-break

这道题目是将一个整数进行拆分，以计算拆分后的各部分积求得最大值。

这道题目一个技巧就是，拆分越多的 3,最终的积的最大。所以拆分求得 3 越多越好，再把剩下的部分乘进去。如果剩下的是>=5,那么继续拆分，如果是 4,那么就乘进去。

还可以用动态规划进行求解，任意一个数字 n，设计一个动态规划数组 dp，代表可以求得的最大积，逐步计算到 dp[n]

对于一个数字 i,可以遍历他其中的一个和因子 j,那么他的另外一部分就是 i-j.

如果不对 i-j 进行拆分，那么求积就是 j\*(i-j), 如果对 i-j 进行拆分，那么求积就是 j\*(dp[i-j]), 二者取最大就是最大积。

## 345. reverse vowels of a string

可以使用 hash 表存储元音字母，然后使用双指针从两边遍历，如果是元音，则交换。另一种方法是 find_last_of 与 find_first_of 函数，不使用 hash 表

## 347. top k frequent elements

使用 hashmap 储存每个数据出现的次数，然后可以使用大顶堆来选出 top k,也可以使用桶排序来计算，桶排序就是将相同出现次数的数字放在一个桶中，然后全部放进去之后，从后向前遍历桶

## 367. Valid Perfect Square

遍历从 2 到 n/2 的范围，检测是否 i\*i==num，如果检测大于 num，那么直接 false，如果等于 num，那么直接 true。

## 376. wiggle-subsequence

这道题目求最长摆动子序列。 动态规划方式进行解决，设计两个数组 up 和 down, 代表到 i 为止以上升沿和下降沿为止的摆动序列的最长长度。

如果 nums[i] > nums[i-1], 则上升沿数组更新（在 down[i-1]上加一），下降沿数组维持上一个不变。如果 nums[i] < nums[i-1], 则下降沿数组更新（在 up[i-1]上加一），上升沿数组维持上一个不变。

## 377. combination-sum-4

这是一道完全背包问题，里面的数字可以使用很多次，而且计算可以组成 target 的序列，顺序是有区别的，比如{1,2,1}和{1,1,2}是两个答案，这个可以使用动态规划来进行计算。

如果使用递归来进行计算会耗时很严重，因为它只需要计算个数，所以我们使用动态规划来解决。

经典的完全背包形式：

```c++
    dp[0] = 1;

    for(long i=1;i<=target;i++){
        for(long num : nums){
            if(i >= num){
                dp[i] += dp[i-num];
            }
        }
    }
```

## 378. Kth Smallest Element in a Sorted Matrix

这道题让我们求有序矩阵中第 K 小的元素，这道题的难点在于数组并不是蛇形有序的，意思是当前行的最后一个元素并不一定会小于下一行的首元素，所以我们并不能直接定位第 K 小的元素，所以只能另辟蹊径。先来看一种利用堆的方法，我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数是否大于 k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求。

这题我们也可以用二分查找法来做，我们由于是有序矩阵，那么左上角的数字一定是最小的，而右下角的数字一定是最大的，所以这个是我们搜索的范围，然后我们算出中间数字 mid，由于矩阵中不同行之间的元素并不是严格有序的，所以我们要在每一行都查找一下 mid，我们使用 upper_bound，这个函数是查找第一个大于目标数的元素，如果目标数在比该行的尾元素大，则 upper_bound 返回该行元素的个数，如果目标数比该行首元素小，则 upper_bound 返回 0, 我们遍历完所有的行可以找出中间数是第几小的数，然后 k 比较，进行二分查找，left 和 right 最终会相等，并且会变成数组中第 k 小的数字。举个例子来说吧，比如数组为:

[1 2
12 100]
k = 3

那么刚开始 left = 1, right = 100, mid = 50, 遍历完 cnt = 3，此时 right 更新为 50
此时 left = 1, right = 50, mid = 25, 遍历完之后 cnt = 3, 此时 right 更新为 25
此时 left = 1, right = 25, mid = 13, 遍历完之后 cnt = 3, 此时 right 更新为 13
此时 left = 1, right = 13, mid = 7, 遍历完之后 cnt = 2, 此时 left 更新为 8
此时 left = 8, right = 13, mid = 10, 遍历完之后 cnt = 2, 此时 left 更新为 11
此时 left = 11, right = 12, mid = 11, 遍历完之后 cnt = 2, 此时 left 更新为 12
循环结束，left 和 right 均为 12，任意返回一个即可。

## 392. is subsequence

遍历母数组，设置子数组遍历 index，如果可以匹配上，那么 index++，如果子数组可以遍历完全，那么代表是子串。

## 404. Sum of Left Leaves

这道题目是计算所有左叶子节点的总和，可以使用递归实现。

## 405. Convert a Number to Hexadecimal

对正数进行 16 进制转换，对负数以补码的形式进行 16 进制转换。

```c++
for(int i=0;num && i<8;i++){
    int item = num & 0x0f;
    if(item>=10){
        ans = map[item-10] + ans;
    }else{
        ans = to_string(item) + ans;
    }
    num = num >> 4;

}
```

使用位操作可以对正负数进行相同的操作。

## 406. queue reconstruction height

首先要确定好如何进行排序，要先安排个子高的同学，然后再去插入个子低的同学。所以排序方式就是先按照个子排序，对于个子相同的，按照第二个数字小的放在前面

## Arithmetic Slices

这道题目是求出数字序列可以拆分成为等差递增序列的个数。

设计一个 dp 数组，其含义是以 A[i]数字为结尾的等差序列的个数。其递推关系式是 dp[i] = dp[i-1] + 1

然后再遍历 dp 数组求和，就可以得到所有的个数了。

## 409. Longest Palindrome

这道题目是根据给定的字符串，判断可以组成的最长回文序列的长度。

注意这里可以使用 hashmap 进行统计每一个字符串的个数。对于偶数，肯定可以加入进去，但是对于奇数，其中的偶数部分也是可以加入进去的。然后如果存在奇数，那么最后还要加 1.

## 415. Add Strings

这道题目是字符串相加，和题目 67 很类似，套路是一样的。

## 416. Partition Equal Subset Sum

动态规划题目，题目要求是确定是否可以将一个序列划分为两个和相等的子序列。

本质上是求是否可以在一个序列中，寻求一个子集，使得和可以等于一个数字 target.

设计一个数组 dp, dp[i]代表是否可能组成 i. 当遍历到 nums[i]和目标 target = j 的时候，dp[j]是否是 true，取决于 dp[ j-nums[i] ]是否为 true, 同时，如果 dp[j] 已经等于 true，当然还要保持 true, 因此，递推关系式是： dp[j] = dp[j - nums[i] ] || dp[j]

这里需要特别注意的是，第二个 for 循环一定要从 target 遍历到 nums[i]，而不能反过来，想想为什么呢？因为如果从 nums[i] 遍历到 target 的话，假如 nums[i]=1 的话，那么 [1, target] 中所有的 dp 值都是 true，因为 dp[0] 是 true，dp[1] 会或上 dp[0]，为 true，dp[2] 会或上 dp[1]，为 true，依此类推，完全使的 dp 数组失效了。

## 417. pacific atlantic water flow

可以使用 BFS 或者 DFS 来进行遍历，遍历就是先从左上边缘进行，对于遍历到的点将 P 相应位置赋值为 TRUE，对于右下角的边缘进行遍历，遍历到的点 A 相应位置赋值为 TRUE，然后再从头遍历一变，如果 P 和 A 都是 true，那么就是均可以流入太平洋和大西洋的点。

## 435. non overlapping intervals

先对待排序的区间进行排序，然后比较两个区间的是否有重叠。根据每个区间的 start 来做升序排序，然后开始要查找重叠区间，判断方法是看如果前一个区间的 end 大于后一个区间的 start，那么一定是重复区间，此时结果 res 自增 1，我们需要删除一个，那么此时究竟该删哪一个呢，为了保证总体去掉的区间数最小，我们去掉那个 end 值较大的区间。具体并不是删掉，而是使用索引指针的形式。

## 437. path sum 3

这道题让我们求二叉树的路径的和等于一个给定值，说明了这条路径不必要从根节点开始，可以是中间的任意一段，而且二叉树的节点值也是有正有负。那么我们可以用递归来做，相当于先序遍历二叉树，对于每一个节点都有记录了一条从根节点到当前节点到路径，同时用一个变量 curSum 记录路径节点总和，然后我们看 curSum 和 sum 是否相等，相等的话结果 res 加 1，不等的话我们来继续查看子路径和有没有满足题意的，做法就是每次去掉一个节点，看路径和是否等于给定值，注意最后必须留一个节点，不能全去掉了，因为如果全去掉了，路径之和为 0，而如果给定值刚好为 0 的话就会有问题

## 445. Add Two Numbers II

这道题是之前那道 Add Two Numbers 的拓展，我们可以看到这道题的最高位在链表首位置，如果我们给链表翻转一下的话就跟之前的题目一样了，这里我们来看一些不修改链表顺序的方法。由于加法需要从最低位开始运算，而最低位在链表末尾，链表只能从前往后遍历，没法取到前面的元素，那怎么办呢？

我们可以利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字了，我们首先遍历两个链表，将所有数字分别压入两个栈 s1 和 s2 中。

然后遍历栈不为空，直到两个栈都为空，设计一个指针 pre，不断插入新的节点到 pre 指针后面。

## 451.sort character by frequency

hashmap 可以得到计数与元素的映射，然后可以使用桶排序或者堆排序来进行计算，看具体的题目要求来决定选择哪一种方法

## 452. minimum number of arrows to burst balloons

类似于计算重叠区间个数，注意在计算重叠区间的时候，要计算公共重叠区间来进行比较，这个区间是逐渐缩小的。

## 455. assign cookies

贪心算法，将两个数组首先进行排序，然后在逐个安排

## 462. Minimum Moves to Equal Array Elements II

这道题是之前那道 Minimum Moves to Equal Array Elements 的拓展，现在我们可以每次对任意一个数字加 1 或者减 1，让我们用最少的次数让数组所有值相等。一般来说这种题目是不能用暴力方法算出所有情况，因为 OJ 一般是不会答应的。那么这道题是否像上面一道题一样，有巧妙的方法呢？答案是肯定的。下面这种解法实际上利用了之前一道题 Best Meeting Point 的思想，是不感觉很 amazing，看似完全不相干的两道题，居然有着某种内部联系。我们首先给数组排序，那么我们最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个数字；如果是偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数实际上就是两端数字的距离，讲到这里发现是不是就和这道题 Best Meeting Point 的思路是一样了。那么我们就两对两对的累加它们的差值就可以了

## 474. ones-and-zeros

这道题是一道典型的应用 DP 来解的题，如果我们看到这种求总数，而不是列出所有情况的题，十有八九都是用 DP 来解，重中之重就是在于找出递推式。如果你第一反应没有想到用 DP 来做，想得是用贪心算法来做，比如先给字符串数组排个序，让长度小的字符串在前面，然后遍历每个字符串，遇到 0 或者 1 就将对应的 m 和 n 的值减小，这种方法在有的时候是不对的，比如对于{"11", "01", "10"}，m=2，n=2 这个例子，我们将遍历完“11”的时候，把 1 用完了，那么对于后面两个字符串就没法处理了，而其实正确的答案是应该组成后面两个字符串才对。所以我们需要建立一个二维的 DP 数组，其中 dp[i][j]表示有 i 个 0 和 j 个 1 时能组成的最多字符串的个数，而对于当前遍历到的字符串，我们统计出其中 0 和 1 的个数为 zeros 和 ones，然后 dp[i - zeros][j - ones]表示当前的 i 和 j 减去 zeros 和 ones 之前能拼成字符串的个数，那么加上当前的 zeros 和 ones 就是当前 dp[i][j]可以达到的个数，我们跟其原有数值对比取较大值即可，所以递推式如下：

dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);

有了递推式，我们就可以很容易的写出代码

## 485. Max Consecutive Ones

这道题目要计算连续 1 的个数。很简单，遍历即可。

## 494. target-sum

可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：

```
sum(P) - sum(N) = target

sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)

2 \* sum(P) = target + sum(nums)
```

因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。

这道题目本质上还是求一个序列里面子集等于 target，不过这里不是求是否存在，而是求有几个，和题目 416 很像。

主要就是 dp[i] = dp[i] + dp[ i-nums[j] ], 解释就是 dp[i]代表 target = i 的有几种组合法。

当前 dp[i]的个数，依赖于历史可以组成 dp[i]的个数，以及 dp[i-nums[j]]个数之和。

然后注意第二层遍历要倒序遍历。

## 501. Find Mode in Binary Search Tree

这道题让我们求二分搜索树中的众数，这里定义的二分搜索树中左根右结点之间的关系是小于等于的，有些题目中是严格小于的，所以一定要看清题目要求。所谓的众数就是出现最多次的数字，可以有多个，那么这道题比较直接点思路就是利用一个哈希表来记录数字和其出现次数之前的映射，然后维护一个变量 mx 来记录当前最多的次数值，这样在遍历完树之后，根据这个 mx 值就能把对应的元素找出来。那么用这种方法的话就不需要用到二分搜索树的性质了，随意一种遍历方式都可以。

题目中的 follow up 说了让我们不用除了递归中的隐含栈之外的额外空间，那么我们就不能用哈希表了，不过这也不难，由于是二分搜索树，那么我们中序遍历出来的结果就是有序的，这样我们只要比较前后两个元素是否相等，就等统计出现某个元素出现的次数，因为相同的元素肯定是都在一起的。我们需要一个结点变量 pre 来记录上一个遍历到的结点，然后 mx 还是记录最大的次数，cnt 来计数当前元素出现的个数，我们在中序遍历的时候，如果 pre 不为空，说明当前不是第一个结点，我们和之前一个结点值比较，如果相等，cnt 自增 1，如果不等，cnt 重置 1。如果此时 cnt 大于了 mx，那么我们清空结果 res，并把当前结点值加入结果 res，如果 cnt 等于 mx，那我们直接将当前结点值加入结果 res，然后 mx 赋值为 cnt。最后我们要把 pre 更新为当前结点

## 503. Next Greater Element II

这道题目和题目 739 很像，但是由于这里的数组是循环的，所以在遍历的时候需要循环遍历两次数组。

## 504. base-7

这道题目是将一个数字转化为 7 进制。

核心的递推公式是：

```c++
    while (item) {
        ans = to_string(item % 7) + ans;
        item = item / 7;
    }
```

注意负数的处理和 0 的处理。

## 513. Find Bottom Left Tree Value

二叉树的层次遍历。

## 518. coin-change-2

这道题目是计算可以凑出目标钱数目的所有硬币组合，这是一个完全背包问题，本质和题目 322 是一样的。

就是递推公式不一样,该题目的递推公式为：

```
    dp[i] = dp[i] + dp[i - coin];

```

需要注意的是，这是完全背包，需要正序遍历。

同时 dp[0] = 1

## 524. Longest Word in Dictionary through Deleting

这个类似于比较一个字符串是不是另一个字符串的子字符串。遍历字典中的字符串，如果当前遍历的字符串是 s 的子字符串，那么就赋值给 ans，然后继续遍历，如果当前遍历的字符串大小小于 ans 或者等于 ans 大小，但是字典排序在 ans 后面，那么就跳过，继续便利。

## 530. Minimum Absolute Difference in BST

计算 BST 两个节点的最小的差值，可以使用中序遍历实现，计算相邻节点的最小差值。

## 538. Convert BST to Greater Tree

这道题目可以使用中序遍历来实现，但是是反过来的中序遍历，这样逐渐从大到小遍历，这样就可以将比 n 大的所有数字都加起来。

## 540. single element in a sorted array

属于能够找到准确值的二分查找

## 543. Diameter of Binary Tree

这道题让我们求二叉树的直径，并告诉了我们直径就是两点之间的最远距离，根据题目中的例子也不难理解题意。我们再来仔细观察例子中的那两个最长路径[4,2,1,3] 和 [5,2,1,3]，我们转换一种角度来看，是不是其实就是根结点 1 的左右两个子树的深度之和呢。那么我们只要对每一个结点求出其左右子树深度之和，这个值作为一个候选值，然后再对左右子结点分别调用求直径对递归函数，这三个值相互比较，取最大的值更新结果 res，因为直径不一定会经过根结点，所以才要对左右子结点再分别算一次。为了减少重复计算，我们用哈希表建立每个结点和其深度之间的映射，这样某个结点的深度之前计算过了，就不用再次计算了

## 547. friend Circles

这道题目是查找联通区域的个数，可以使用 BFS 或者 DFS 来进行遍历，然后统计联通区域的个数即可。这道题目还有一种解法比较巧妙，就是 union find. 核心思想是设置一个数组 root,root 里面存储的是索引链接关系，开始给每一个对象的 root 索引都是自己，各个对象都是独立的，然后如果判断一个对象和另一个对象属于同一类，就把后者的 root 索引链接到前者。这样二者就变为了同一类，最后在总的类别数目上减一。

## [565] Array Nesting

这道题目是让我们计算嵌套数组的最大长度。可以找到的规律就是，如果是嵌套数组，那么一定是循环的，即首位链接嵌套的，那么我们就可以对于访问过的数字进行标记，对于每一个没有被访问过的数字，循环深入潜逃下去，直到发现回到了起点为止，计算他的长度。

## 566. Reshape the Matrix

这道题目是让我实现矩阵的 reshap 函数。我们就按照行进行依次遍历填入数据即可。

## 572. subtree-of-another-tree

这道题让我们求一个数是否是另一个树的子树，从题目中的第二个例子中可以看出，子树必须是从叶结点开始的，中间某个部分的不能算是子树，那么我们转换一下思路，是不是从 s 的某个结点开始，跟 t 的所有结构都一样，那么问题就转换成了判断两棵树是否相同，也就是 Same Tree 的问题了，这点想通了其实代码就很好写了，用递归来写十分的简洁，我们先从 s 的根结点开始，跟 t 比较，如果两棵树完全相同，那么返回 true，否则就分别对 s 的左子结点和右子结点调用递归再次来判断是否相同，只要有一个返回 true 了，就表示可以找得到

## 583. Delete Operation for Two Strings

这道题目是计算多少次删除，可以让两个字符串相等。

本质上这道题目是求最长公共子序列，和题目 1143 是一样的。

## 594. Longest Harmonious Subsequence

我们还可以用 HashMap 来做，先遍历一遍，建立每个数字跟其出现次数之间的映射，然后再遍历每个数字的时候，只需在 HashMap 中查找该数字加 1 是否存在，存在就更新结果 res，这样更简单一些

## 605. can place flowers

这里类似于确定连续 0 的个数 n，然后计算(n-1)/2 即为可以种花的个数，但是要注意，这个是假设两边均种花，如果是位于边界的花，需要单独进行处理。左边界的条件可以事先设置起始 count=1,右边界的话，因为最后遍历完成之后，如果右边界是连续的 0,那么右面连续的 0 还没有统计进去，再统计进去的可以使用 n/2

## 617. merge two binary Trees

这道题目是将两个树进行合并。可以使用递归的思路进行合并。

## 628. maximun-product-of-three-numbers

这道题博主刚开始看的时候，心想直接排序，然后最后三个数字相乘不就完了，心想不会这么 Easy 吧，果然被 OJ 无情打脸，没有考虑到负数和 0 的情况。这道题给了数组的范围，至少三个，那么如果是三个的话，就无所谓了，直接相乘返回即可，但是如果超过了 3 个，而且有负数存在的话，情况就可能不一样，我们来考虑几种情况，如果全是负数，三个负数相乘还是负数，为了让负数最大，那么其绝对值就该最小，而负数排序后绝对值小的都在末尾，所以是末尾三个数字相乘，这个跟全是正数的情况一样。那么重点在于前半段是负数，后半段是正数，那么最好的情况肯定是两个最小的负数相乘得到一个正数，然后跟一个最大的正数相乘，这样得到的肯定是最大的数，所以我们让前两个数相乘，再和数组的最后一个数字相乘，就可以得到这种情况下的最大的乘积。实际上我们并不用分情况讨论数组的正负，只要把这两种情况的乘积都算出来，比较二者取较大值，就能涵盖所有的情况，从而得到正确的结果，

## 633. sum of aqure numbers

这道题目和 two sum 2 很类似，都是在排序好的数组内寻找两个数字，只不过一个是和，一个是平方和，可以使用双指针来实现，但是要注意的是右指针的初始化可以直接初始化为 target 的根号值

## 637. Average of Levels in Binary Tree

二叉树的层次遍历。

## 645. Set Mismatch

这道题给了我们一个长度为 n 的数组，说里面的数字是从 1 到 n，但是有一个数字重复出现了一次，从而造成了另一个数字的缺失，让我们找出重复的数字和缺失的数字。那么最直接的一种解法就是统计每个数字出现的次数了，然后再遍历次数数组，如果某个数字出现了两次就是重复数，如果出现了 0 次，就是缺失数。

另外一种思想就是通过交换数组元素，使得数组上的元素在正确的位置上。然后再遍历一遍数组，如果某一个位置的数字不符合要求，就可以得到我们想要的答案。

## 647. Palindromic substrings

这道题目是计算一个字符串的所有可能的所有字串有多少回文字符串。

关键点就是我们要对于输入的字符串进行拆分，一个回文字符串是有中间线的，这个中间线在原字符串的位置就是 0, 0.5, 1, 1.5, ... 如果是偶数回文，那么中间线就是包含 0.5, 如果是奇数回文，那么中间线就是纯整数。我们遍历这些中间线，然后向两侧遍历，如果相等，ans 就加 1,如果不相等直接 break.

## 650. 2 Keys Keyboard

这道题目关键是找出规律，

递推公式是 dp[i] = min(dp[i], dp[j] + i / j)

其中 i 是准备求的目标数字，j 是 i 的所有可以整除的因子。

## 653. Two Sum IV - Input is a BST

这道题又是一道 2sum 的变种题，博主一直强调，平生不识 TwoSum，刷尽 LeetCode 也枉然！只要是两数之和的题，一定要记得先尝试用 HashSet 来做，这道题只不过是把数组变成了一棵二叉树而已，换汤不换药，我们遍历二叉树就行，然后用一个 HashSet，在递归函数函数中，如果 node 为空，返回 false。如果 k 减去当前结点值在 HashSet 中存在，直接返回 true；否则就将当前结点值加入 HashSet，然后对左右子结点分别调用递归函数并且或起来返回即可

## 665. non decreasing array

判断 i 是否小于 i-1，如果小于，那么就需要修改，但是具体要修改哪个呢，需要看情况而定，如果 i-2 不存在，那么直接修改 i-1,如果 i-2 小于 i，那么修改 i-1,如果 i-2 大于 i，那么修改 i

## 667. Beautiful Arrangement II

这道题目让我们输出一个数组，数组由 1 ～ n 组成，但是每个相邻数字的之间的绝对值要满足在 1 ～ k 之间。

这道题目我们可以寻找一个规律，就是对于 1 ～ 8 这个为例，那么假设 k=7，那么就可以这么找规律：

1 8 2 7 3 6 4 5

就是设计两个变量，left = 1 和 right = 1+k 他俩交替填入到数组里面去，然后直到 left 和 right 相遇，然后处理一个边界问题即可。

## 669. Trim a Binary Search Tree

这道题让我们修剪一棵二叉搜索树，给了个边界范围[L, R], 所有不在这个范围内的结点应该被移除掉，但是仍需要保留二叉搜索树的性质，即左<根<右，有时候是小于等于。博主最开始的想法是先遍历一遍二叉树，将在返回内的结点值都放到一个数组后，遍历结束后再根据数组重建一棵二叉搜索树。这种方法会在某些 test case 上 fail 掉，可能会改变原来的二叉搜索树的结构，所以我们只能换一种思路。正确方法其实应该是在遍历的过程中就修改二叉树，移除不合题意的结点。当然对于二叉树的题，十有八九都是要用递归来解的。首先判断如果 root 为空，那么直接返回空即可。然后就是要看根结点是否在范围内，如果根结点值小于 L，那么返回对其右子结点调用递归函数的值；如果根结点大于 R，那么返回对其左子结点调用递归函数的值。如果根结点在范围内，将其左子结点更新为对其左子结点调用递归函数的返回值，同样，将其右子结点更新为对其右子结点调用递归函数的返回值。最后返回 root 即可，

## 671. Second Minimum Node In a Binary Tree

这道题让我们找二叉树中的第二小的结点值，并且给该二叉树做了一些限制，比如对于任意一个结点，要么其没有子结点，要么就同时有两个子结点，而且父结点值是子结点值中较小的那个，当然两个子结点值可以相等。那么直接上暴力搜索呗，根据该树的附加条件可知，根结点一定是最小的结点值 first，那么我们只要找出第二小的值 second 即可，初始化为整型的最大值。然后对根结点调用递归函数，将 first 和 second 当作参数传进去即可。在递归函数中，如果当前结点为空，直接返回，若当前结点孩值不等于 first，说明其肯定比 first 要大，然后我们看其是否比 second 小，小的话就更新 second，然后对当前结点的左右子结点分别调用递归函数即可

## 677. Map Sum Pairs

这道题目和题目 208 很像，不同的地方在于，对于每一个节点，我们设置一个 sum 参数，一个 isWord 参数，新添加一个字符串的时候，经过的每一个节点的 sum 都增加 val 数值。

如果到达字符串末尾，如果 isword 大于 0,说明之前访问过，那么再次遍历一下，这次遍历的时候就每次减去 val，到达末尾的时候更新 val。

sum 方法的时候，直接进行遍历到末尾，然后直接返回最后一个节点的 sum.

## 680. validPalindrome 2

双指针，首先正常判断是不是回文字符串，在出现两个字符不一致的情况下，继续判断里面的字符串是不是会问字符串，注意有交叉两种情况

## 684. Redundant Connection

这道题给我们了一个无向图，让删掉组成环的最后一条边，其实这道题跟之前那道 Graph Valid Tree 基本没什么区别，三种解法都基本相同。博主觉得老题稍微变一下就是一道新题，而 onsite 遇到原题的概率很小，大多情况下都会稍稍变一下，所以举一反三的能力真的很重要，要完全吃透一道题也不太容易，需要多下功夫。首先来看递归的解法，这种解法的思路是，每加入一条边，就进行环检测，一旦发现了环，就返回当前边。对于无向图，还是用邻接表来保存，建立每个结点和其所有邻接点的映射，由于两个结点之间不算有环，所以要避免这种情况 1->{2}, 2->{1} 的死循环，用一个变量 pre 记录上一次递归的结点，比如上一次遍历的是结点 1，那么在遍历结点 2 的邻接表时，就不会再次进入结点 1 了，这样有效的避免了死循环，使其能返回正确的结果

这道题最好的解法使用 Union Find 来做，论坛上清一色的都是用这种解法来做的，像博主用 DFS 和 BFS 这么清新脱俗的方法还真不多:) 其实 Union Find 的核心思想并不是很难理解，首先建立一个长度为 (n+1) 的数组 root，由于这道题并没有明确的说明 n 是多少，只是说了输入的二位数组的长度不超过 1000，那么 n 绝对不会超过 2000，加 1 的原因是由于结点值是从 1 开始的，而数组是从 0 开始的，懒得转换了，就多加一位得了。将这个数组都初始化为 -1，有些人喜欢初始化为 i，都可以。开始表示每个结点都是一个单独的组，所谓的 Union Find 就是要让结点之间建立关联，比如若 root[1] = 2，就表示结点 1 和结点 2 是相连的，root[2] = 3 表示结点 2 和结点 3 是相连的，如果此时新加一条边 [1, 3] 的话，我们通过 root[1] 得到 2，再通过 root[2] 得到 3，说明结点 1 有另一条路径能到结点 3，这样就说明环是存在的；如果没有这条路径，那么要将结点 1 和结点 3 关联起来，让 root[1] = 3 即可，

## 687. Longest Univalue Path

这道题让我们求最长的相同值路径，跟之前那道 Count Univalue Subtrees 十分的类似，解法也很类似。对于这种树的路径问题，递归是不二之选。在递归函数中，我们首先对其左右子结点调用递归函数，得到其左右子树的最大相同值路径长度，下面就要来看当前结点和其左右子结点之间的关系了，如果其左子结点存在且和当前节点值相同，则 left 自增 1，否则 left 重置 0；同理，如果其右子结点存在且和当前节点值相同，则 right 自增 1，否则 right 重置 0。然后用 left+right 来更新结果 res。而调用当前节点值的函数只能返回 left 和 right 中的较大值，因为如果还要跟父节点组 path，就只能在左右子节点中选一条 path，当然选值大的那个了，什么意思呢，举个例子来说吧，比如下面的这棵二叉树：

```
      1
     / \
    4   5
   / \   \
  4   4   5
 /
4
```

若此时的 node 是只有两个结点的第二层的那个结点 4，那么分别对其左右子结点调用递归，会得到 left = 1, right = 0，因为此时要跟结点 4 组成 path，所以肯定挑左子结点（有两个 4 的那条边），那你会问为啥不能连上右子结点的那个 4，这整条长度为 3 的 path（left+right，此时的 left 和 right 已经分别自增 1 了，left=2，right=1）其实我们已经用来更新过结果 res 了。需要注意的是我们的递归函数 helper 返回值的意义，并不是经过某个结点的最长路径的长度，最长路径长度保存在了结果 res 中，不是返回值，返回的是以该结点为终点的最长路径长度，这样回溯的时候，我们还可以继续连上其父结点，比如若根结点也是 4 的话，那么回溯到根结点的时候，路径长度又可以增加了

## 695. max-area-of-island

这道题目类似于 1091 这道题目，不同之处在于这道题目仅有四个方向可以拓展。至于每一个子区域遍历一遍，可以使用 BFS 也可以使用 DFS。BFS 可以求出最短路径，而 DFS 对于求出可达性会更快一些。

## 696. Count Binary Substrings

这道题目是让我们判断有多少个子字符串包含相同的‘0’和‘1’，且‘0’和‘1’都聚集在一起。

我们可以遍历整个数组，当遇到数字变化的时候，就是判断的时候，用一个数字 pre 代表上一堆相同的数字个数，用 cur_num 代表当前的数字个数。二者的较小值也就是公共部分，添加到最终结果里面。然后交替 pre=cur_sum，直到遍历到最后结束。注意开头的细节即可。

## 697. Degree of an Array

这道题给了我们一个数组，定义数组的度为某个或某些数字出现最多的次数，要我们找最短的子数组使其和原数组拥有相同的度。那么我们肯定需要统计每个数字出现的次数，就要用哈希表来建立每个数字和其出现次数之间的映射。由于我们要求包含原度的最小长度的子数组，那么最好的情况就是子数组的首位数字都是统计度的数字，即出现最多的数字。那么我们肯定要知道该数字的第一次出现的位置和最后一次出现的位置，由于我们开始不知道哪些数字会出现最多次，所以我们统计所有数字的首尾出现位置，那么我们再用一个哈希表，建立每个数字和其首尾出现的位置。我们用变量 degree 来表示数组的度。好，现在我们遍历原数组，累加当前数字出现的次数，当某个数字是第一次出现，那么我们用当前位置的来更新该数字出现的首尾位置，否则只更新尾位置。每遍历一个数，我们都更新一下 degree。当遍历完成后，我们已经有了数组的度，还有每个数字首尾出现的位置，下面就来找出现次数为 degree 的数组，然后计算其首尾位置差加 1 就是 candidate 数组的长度，由于出现次数为 degree 的数字不一定只有一个，我们遍历所有的，找出其中最小的即可

## 714. Best Time to Buy and Sell Stock with Transaction Fee

这道题目和 309 带冷却期的股票交易很像，只是没有冷却期了，添加了每次的手续费。

还是设计两个数组 have[i]与 nothave[i].代表第 i 天手里有或没有股票的最大收益。

递推公式就是在每次卖出的时候加上手续费就可以了

```c++
have[i] = max(have[i-1], nothave[i-1] - prices[i]);
nothave[i] = max(nothave[i-1], have[i-1] + prices[i] - fee);
```

## 725. Split Linked List in Parts

这道题给我们一个链表和一个正数 k，让我们分割链表成 k 部分，尽可能的平均分割，如果结点不够了，就用空结点，比如例子 1 中的。如果无法平均分，那么多余的结点就按顺序放在子链表中，如例子 2 中所示。我们要知道每个部分结点的个数，才能将整个链表断开成子链表，所以我们首先要统计链表中结点的总个数，然后除以 k，得到的商 avg 就是能分成的部分个数，余数 ext 就是包含有多余的结点的子链表的个数。我们开始 for 循环，循环的结束条件是 i 小于 k 且 root 存在，要生成 k 个子链表，在循环中，先把头结点加入结果 res 中对应的位置，然后就要遍历该子链表的结点个数了，首先每个子链表都一定包含有 avg 个结点，这是之前除法得到的商，然后还要有没有多余结点，如果 i 小于 ext，就说明当前子链表还得有一个多余结点，然后我们将指针向后移动一个，

## 739. Daily Temperatures

这道题给了我们一个数组，让我们找下一个比当前数字大的数字的距离，我们研究一下题目中给的例子，发现数组是无序的，所以没法用二分法快速定位下一个大的数字，那么最先考虑的方法就是暴力搜索了，写起来没有什么难度，但是 OJ 并不答应。实际上这道题应该使用递增栈来做，栈如果输出的话，是逐步递增的，思路是这样的，我们遍历数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是递减栈了，所以我们取出栈顶元素，那么由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，那么我们直接求出下标差就是二者的距离了，然后继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来了。

## 744. find smallest letter greater than target

二分查找法

## 763. partition label

构建一个 hash 表，记录每一个字母最后出现的位置，然后再遍历一边字符串，定义一个变量表示当前出现的字符的最右边的边界，如果当前索引等于当前出现字符的最右边边界，那么就认为可以切割了

## 766. Toeplitz Matrix

这道题目是要进行矩阵的 index 的特殊遍历，关键是找到 index 的变化转折位置，处理好边界条件。

## 769. Max Chunks To Make Sorted

这道题目是让我们计算可以将一个数组分成几个部分，使得对每部分排序后数组就为有序。

找到规律就是遍历数组，寻找当前的最大值，如果当前已经遍历的数组最大值刚好等于他在排序后应该在的位置（也就是当前最大值等于下标 index）,那么就说明前面这部分的数组是可以单独独立出来进行排序的，以此类推即可。

## 785. Is Graph Bipartite?

这道题目让我们判断一个图是不是二分图。二分图就是整个图的节点可以分为两组，同组的节点不相互连接，也就是一条边的两个节点不能时同一种节点。

我们可以涂色法，遍历整个图的节点，可以使用 BFS，也可以使用递归方法。

如果这个节点被访问过了，那么判断这个节点的颜色即将被涂上的颜色是不是相等，如果相等，那么对了，如果和即将被涂上的颜色不相等，那么就不是二分图。

如果这个节点没有被访问过，那么就直接涂色。

---

这道题博主在最开始做的时候，看了半天，愣是没弄懂输出数据的意思，博主开始以为给的是边，后来发现跟图对应不上，就懵逼了，后来是通过研究论坛上大神们的解法，才总算搞懂了题目的意思，原来输入数组中的 graph[i]，表示顶点 i 所有相邻的顶点，比如对于例子 1 来说，顶点 0 和顶点 1，3 相连，顶点 1 和顶点 0，2 相连，顶点 2 和结点 1，3 相连，顶点 3 和顶点 0，2 相连。这道题让我们验证给定的图是否是二分图，所谓二分图，就是可以将图中的所有顶点分成两个不相交的集合，使得同一个集合的顶点不相连。为了验证是否有这样的两个不相交的集合存在，我们采用一种很机智的染色法，大体上的思路是要将相连的两个顶点染成不同的颜色，一旦在染的过程中发现有两连的两个顶点已经被染成相同的颜色，说明不是二分图。这里我们使用两种颜色，分别用 1 和 -1 来表示，初始时每个顶点用 0 表示未染色，然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数，如果返回 false，那么说明不是二分图，则直接返回 false。如果循环退出后没有返回 false，则返回 true。在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回 true，否则返回 false。如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点，调用递归函数，如果返回 false 了，则当前递归函数的返回 false，循环结束返回 true

我们再来看一种迭代的解法，整体思路还是一样的，还是遍历整个顶点，如果未被染色，则先染色为 1，然后使用 BFS 进行遍历，将当前顶点放入队列 queue 中，然后 while 循环 queue 不为空，取出队首元素，遍历其所有相邻的顶点，如果相邻顶点未被染色，则染成和当前顶点相反的颜色，然后把相邻顶点加入 queue 中，否则如果当前顶点和相邻顶点颜色相同，直接返回 false，循环退出后返回 true，

## 1091. shortest path in binary matrix

BFS。注意要对八个可能方向都要添加进队列，可能会访问回以前遍历过的地方，那么就如果是更短的路径，就要更新，如果不是更短的路径，就不要更新。

## 1143. longest-common-subsequence

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：

当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。
当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。
