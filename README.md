# leetcode

[TOC]

---

- [二分搜索法总结](./docs/binary_search.md)

- [动态规划总结]

- [回溯法总结](./docs/backtracking.md)

- [位操作总结](./docs/bit.md)

- [剑指 offer 总结](./docs/jz-offer.md)

---

## 1. Two sum

使用 hash 表来记录已经存储的数据，新来的数据与 target 做差，判断是否在 hash 表中存在

## 2. 无重复字符的最长子串

这道题目可以使用 128 位的数组来表示所有字符。开始每个字符都初始化为-1

然后这道题目其实是维护一个滑动窗口。滑动窗口左边界是 left，右边界是当前访问的数组下标。

left 的更新策略是：

left = max(left, dp[s[i]]);

也就是如果一直没有被访问过重复字符，那么 left 一直维持在-1;窗口的长度就是当前下标减去 left.

然后如果出现了重复字符，那么 left 就立刻更新到之前出现的位置。

注意 dp[]数组也在不断更新，保存的是上一次出现的位置，用于如果出现了重复，可以把滑动窗口左边界拉过来。

## 5. Longest Palindromic Substring

正常方法要区分奇偶串，但是也可以首先便遍历中间重复的字符，将奇数偶数串统一处理

或者使用动态规划的方法，dp[i][j]表示这个 ij 区间内的是回文字符串，那么有递推公式：

```c++
dp[i][j] = true
{
if i==j
if j-1<2 && s[i]==s[j]
if dp[i+1][j-1]==true && s[i]==s[j]
}
```

## 6. zig-zag Conversion

o(n)time o(1)space 的算法是找到每一排循环的规律，是按照一定的周期循环的，或者可以使用 o(n)space ,不断的调整填充辅助数组的方向进行填充

## 7. reverse integer

这里要求时说如果 int 反转之后超如了有符号位 32 位大小的限制范围，那么就要返回 0，可以将结果先用 long 保存，然后在计算，并比较最后的结果是否超出了范围，并返回比较后的结果

## 8. 字符串转换整数 (atoi)

1. 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回 0.

2. 若第一个非空格字符是符号 +/-，则标记 sign 的真假，这道题还有个局限性，那就是在 c++ 里面，+-1 和-+1 都是认可的，都是 -1，而在此题里，则会返回 0.

3. 若下一个字符不是数字，则返回 0，完全不考虑小数点和自然数的情况，不过这样也好，起码省事了不少。

4. 如果下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。

5. 还需要考虑边界问题，如果超过了整型数的范围，则用边界值替代当前值。

判断是否超出了整数范围，可以这么判断：

```c
if(ans > INT_MAX / 10 || (ans == INT_MAX / 10 && str[right] > '7'))
```

## 9. Palindrome Number

这里如果是负数一定不是 Palindrome Number， 然后可以转化为字符串用双指针来做

还有一种方法就是，可以将数字进行反转，然后比较二者是否相等，或者可以比较一半，这种方法最快，就是将原本剩下砍掉的数字和新累乘的数字进行比较，知道新的数字大于剩下砍掉的数字，但是要注意边界条件，数字可以被 10 整除的是非常特殊的。

## 10. 正则表达式

这道求正则表达式匹配的题和那道 Wildcard Matching 的题很类似，不同点在于\*的意义不同，在之前那道题中，\*表示可以代替任意个数的字符，而这道题中的\*表示之前那个字符可以有 0 个，1 个或是多个，就是说，字符串 a\*b，可以表示 b 或是 aaab，即 a 的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归 Recursion 来解，大概思路如下：

- 若 p 为空，若 s 也为空，返回 true，反之返回 false。

- 若 p 的长度为 1，若 s 长度也为 1，且相同或是 p 为 '.' 则返回 true，反之返回 false。

- 若 p 的第二个字符不为\*，若此时 s 为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。

- 若 p 的第二个字符为\\\*，进行下列循环，条件是若 s 不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配 s 和去掉前两个字符的 p（这样做的原因是假设此时的星号的作用是让前面的字符出现 0 次，验证是否匹配），若匹配返回 true，否则 s 去掉首字母（因为此时首字母匹配了，我们可以去掉 s 的首字母，而 p 由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。

- 返回调用递归函数匹配 s 和去掉前两个字符的 p 的结果（这么做的原因是处理星号无法匹配的内容，比如 s="ab", p="a\*b"，直接进入 while 循环后，我们发现 "ab" 和 "b" 不匹配，所以 s 变成 "b"，那么此时跳出循环后，就到最后的 return 来比较 "b" 和 "b" 了，返回 true。再举个例子，比如 s="", p="a\*"，由于 s 为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）。

## 14. Longest Common Prefix

先排序，排好序找到最短的字符串的长度，然后遍历最短字符串长度，逐个比较排序后的第一个字符串和最后一个字符串

## 15. three-num

类似于 two num 题目的解法，但是不同的是要固定一个数字，然后找到另外两个数字，同时需要注意不要有重复的组合出现，解决方法是对于相同的数字，我们就将 index 跳过。

关键是如何排除相同的对象，尽量不要使用当前元素与 ans 里面的元素进行比较。

关键是要找到规律，如果发现元素相同（本质上就是相同等级的元素起得作用相同）的话，那么就跳过。

## 17. letter combination of a phone number

递归解法，类似于回溯的层级递归解法，整体的结构就是一个树形网络，在数行网络的最低端返回结果

补充：典型的回溯解法，就是设置 help 的参数一般包括&path，&paths,遇到层级底部，将 path 添加到 paths，然后函数返回并，将 path 最后一位去掉，这样就可以遍历所有情况。回溯和 DFS 很像，但是也有区别的地方，主要是以下几点：

Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在 可达性问题 ，这种问题只需要执行到特点的位置然后返回即可。
- 而 Backtracking 主要用于求解 排列组合 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

## 18. 四数之和

这道题目是三数之和的拓展，本质上原理和三数之和是一样的，只不过是再多循环一层，然后就是按照同样的规律排除相同的元素，防止结果里面出现同样的元素。

## 19. Remove Nth Node From End of List

这道题目让去除链表里面倒数第 n 个元素。

可以开始让 head 不断前进，然后 count 计数。如果计数大于等于 n，另一个指针 item 开始前进，当 head 到达末尾的时候，item 就到达了目标位置。需要注意的是细节的处理，使用 pre 指针很方便。

## 20. Valid Parentheses

判断括号的完整性质，使用堆栈实现即可。

## 21. Merge Two Sorted Lists

这道题目是将两个已经排序的链表进行融合，注意的一点就是设置一个 pre 指针，然后不断的添加就可以。

## 24. Swap Nodes in Pairs

这道题目是按照次序交换相邻的两个节点。注意处理好 next 的关系和循环停止条件。

## 34. find first ans last position of element in sorted array

二分查找，可以使用两次二分，也可以使用一次二分之后，将 target 加 1,继续进行二分。本质是一道二分查找第一个大于等于 target 的位置的题目。

## 39. combination

组合求和。这道题目要求根据提供的数字来组合出来和为 target 的数字组合，每个数字可以使用多次，但是最终的结果不能重复。

还是经典的组合问题，用回溯法进行解决。设计的关键有两点，一点是如何判断添加到 paths 的条件，这里就是 path 各个元素的和等于 target。另一个就是如何添加新的元素到 path，这里就是如果新的元素大于等于 path 的末尾元素，那么就可以添加进去，目的是确保没有重复的组合出现，因为 2，2, 3 和 2, 3, 2 是同一种组合。

## 40. combination-sum-2

组合求和 2. 这道题目还是根据提供的数字组合出来和为 target 的数字组合，但是备选数字有重复，而且每个位置的数字只能使用一次，最终结果也不能重复。

由于是组合，那么 2,2,3 和 2,3,2 是一个组合。

因此，还是经典的组合问题，使用回溯方法进行解决。需要注意的是，这里由于结果必须是不同的组合，因此最好先对数组进行排序，然后新添加的数字必须大于等于 path 最后一个数字。

又由于备选数字有重复，因此每次添加新数字的时候，如果前一个数字没有访问标记，并且当前数字等于前一个数字，那么说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此跳过。同时如果当前数字已经被访问过，那么也不能重复访问，也直接跳过。

## 46. permutation

这道题目是排列组合所有可能的数字组合，但是数字只能使用一次，且数字之间都是互不相同的。这是典型的组合问题，可以使用回溯方法进行解决。注意每次插入新的数字的时候，要插入和 path 里面已有的数字的不同的数字

## 47. permutations-2

这道题目是排列组合题目的一个变形，不同之处在于数字之间可能有重复，每个位置的数字可以使用一次。生成的最后结果不能相互有重复。

注意每次添加新的数字的时候，前一个数字如果没有访问标记（visit）,并且当前数字等于前一个数字，说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此直接跳过。同时，如果当前数字已经被标记（visit）,那么不重复访问，也直接跳过。

## 53. maximum subarray

有两种方法，一种是迭代的方法，就是分而治之。那么最大值就是左侧数组的最大值，右侧数组的最大值，以及从中间值向两边进行遍历，记录遍历过程中经过的最大值。那么最大值就是这三个最大值中的较大那个。

另一种方法是比较巧妙，设置两个变量，分别是总的最大值，一个是当前遍历的临时最大值。然后用临时最大值加上当前遍历的数值，如果和小于当前数值，那么说明前面的累计是负面效应的，还不如只用当前遍历的数字，那么就更新临时最大值为当前便利的数值。如果和大于当前数值，那么说明前面的累计是有正面作用的，将临时最大值更新为新的和。同时，在每次更新临时最大值的时候都更新总的最大值，用 max 函数，记录这些更新历史过程中的总的最大值，即为最后结果。

还可以使用动态规划。dp[i]表示以 nums[i]为结尾的子数组的最大值。

## 54 螺旋矩阵

按照框进行遍历。

## 62. unique-paths

典型的动态规划问题，要求是要寻找矩阵从左上角到右下角的所有可能的情况，那么某一点的情况是他左侧点的情况和上面点的情况的加和。注意最上边和最左边都是 1,然后遍历填满 dp 矩阵即可。

## 64. minimum-path-sum

典型的动态规划问题，由于是二维矩阵，建立一个二维 dp 数组比较合适。

递推关系式是到达 grid[i][j]的最短距离，取决于达到该点左侧和上侧最短距离之间的最小值，在加上该点的距离，然后 for 循环遍历一遍，填满 dp 数组就可以了。

## 65. 有效数字

这道题目很繁琐，要根据特殊情况一个一个补充。

关键：

1. 开始去除左右两侧的空格。
2. 设置几个标志位：数字，符号，自然底数，小数点，数字是否在自然底数后面，然后分门别类按照各自的类型处理
3. 对于第一个字符单独处理
4. 对于没有数字的字符串肯定不是，这个要单独判断一下

## 67. add-binary

实现二进制加法。

首先将 a 确保为较长的字符串（使用 swap 交换）,然后设计一个 up 参数，如果两个数相加等于 0, 等于 1，等于 2,等于 3,分别进行不同的处理。

最后注意，如果 up 最后还是等于 1,那么就在前面还要加一个 1.

## 69. sqrt-x

可以使用数学解法进行球见，就是找到等式，转化为牛顿法，牛顿法的递推公式就是 Xn+1 = Xn - fx / fx'。 还有一种通用的解法，就是使用二分法

## 70. 爬梯子

典型的动态规划题目，递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。`dp[i] = dp[i-1]+dp[i-2];`

## 72. edit-distance

这道题目是使用三种手段来将两个字符串变成一致，分别时删除，增加，修改。

使用 dp[i][j]用来表示字符串 1 的 0~i-1、字符串 2 的 0~j-1 的最小编辑距离；
我们可以知道边界情况：dp[i][0] = i、dp[0][j]=j；
同时对于两个字符串的子串，都能分为最后一个字符相等或者不等的情况：
如果 words[i-1] == words[j-1]：dp[i][j] = dp[i-1][j-1]；也就是说当前的编辑距离和位置 i 和 j 的字符无关；
如果 words[i-1] != words[j-1]：则存在三种可能的操作：

```
向 word1 插入：dp[i][j] = dp[i][j-1] + 1;
从 word1 删除：dp[i][j] = dp[i-1][j] + 1;
替换 word1 元素：dp[i][j] = dp[i-1][j-1] + 1;
```

## 75. sort colors

荷兰国旗问题，可以设置三个索引指针来进行解决，分别是左侧，当前，右侧

## 76. 最小覆盖子串

这道题给了我们一个原字符串 S，还有一个目标字符串 T，让在 S 中找到一个最短的子串，使得其包含了 T 中的所有的字母，并且限制了时间复杂度为 O(n)。这道题的要求是要在 O(n) 的时间度里实现找到这个最小窗口字串，暴力搜索 Brute Force 肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是 O(n)，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含 T 中所有的字母，那么对于 T 中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了 O(n)，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐 T.T），使用 HashMap，建立 T 中每个字母与其出现次数之间的映射，那么你可能会有疑问，为啥不用 HashSet 呢，别急，讲到后面你就知道用 HashMap 有多妙，简直妙不可言～

目前在脑子一片浆糊的情况下，我们还是从简单的例子来分析吧，题目例子中的 S 有点长，换个短的 S = "ADBANC"，T = "ABC"，那么肉眼遍历一遍 S 呗，首先第一个是 A，嗯很好，T 中有，第二个是 D，T 中没有，不理它，第三个是 B，嗯很好，T 中有，第四个又是 A，多了一个，礼多人不怪嘛，收下啦，第五个是 N，一边凉快去，第六个终于是 C 了，那么貌似好像需要整个 S 串，其实不然，注意之前有多一个 A，就算去掉第一个 A，也没事，因为第四个 A 可以代替之，第二个 D 也可以去掉，因为不在 T 串中，第三个 B 就不能再去掉了，不然就没有 B 了。所以最终的答案就"BANC"了。通过上面的描述，你有没有发现一个有趣的现象，先扩展，再收缩，就好像一个窗口一样，先扩大右边界，然后再收缩左边界，上面的例子中右边界无法扩大了后才开始收缩左边界，实际上对于复杂的例子，有可能是扩大右边界，然后缩小一下左边界，然后再扩大右边界等等。这就很像一个不停滑动的窗口了，这就是大名鼎鼎的滑动窗口 Sliding Window 了，简直是神器啊，能解很多子串，子数组，子序列等等的问题，是必须要熟练掌握的啊！

下面来考虑用代码来实现，先来回答一下前面埋下的伏笔，为啥要用 HashMap，而不是 HashSet，现在应该很显而易见了吧，因为要统计 T 串中字母的个数，而不是仅仅看某个字母是否在 T 串中出现。统计好 T 串中字母的个数了之后，开始遍历 S 串，对于 S 中的每个遍历到的字母，都在 HashMap 中的映射值减 1，如果减 1 后的映射值仍大于等于 0，说明当前遍历到的字母是 T 串中的字母，使用一个计数器 cnt，使其自增 1。当 cnt 和 T 串字母个数相等时，说明此时的窗口已经包含了 T 串中的所有字母，此时更新一个 minLen 和结果 res，这里的 minLen 是一个全局变量，用来记录出现过的包含 T 串所有字母的最短的子串的长度，结果 res 就是这个最短的子串。然后开始收缩左边界，由于遍历的时候，对映射值减了 1，所以此时去除字母的时候，就要把减去的 1 加回来，此时如果加 1 后的值大于 0 了，说明此时少了一个 T 中的字母，那么 cnt 值就要减 1 了，然后移动左边界 left。你可能会疑问，对于不在 T 串中的字母的映射值也这么加呀减呀的，真的大丈夫（带胶布）吗？其实没啥事，因为对于不在 T 串中的字母，减 1 后，变-1，cnt 不会增加，之后收缩左边界的时候，映射值加 1 后为 0，cnt 也不会减少，所以并没有什么影响啦，下面是具体的步骤啦：

- 先扫描一遍 T，把对应的字符及其出现的次数存到 HashMap 中。

- 然后开始遍历 S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减 1 后仍大于等于 0，cnt 自增 1。

- 如果 cnt 等于 T 串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是 T 串中不可缺少的字母，那么 cnt 自减 1，表示此时 T 串并没有完全匹配。

更优化的方法：

这道题也可以不用 HashMap，直接用个 int 的数组来代替，因为 ASCII 只有 256 个字符，所以用个大小为 256 的 int 数组即可代替 HashMap，但由于一般输入字母串的字符只有 128 个，所以也可以只用 128，其余部分的思路完全相同，虽然只改了一个数据结构，但是运行速度提高了一倍，说明数组还是比 HashMap 快啊。在热心网友 chAngelts 的提醒下，还可以进一步的优化，没有必要每次都计算子串，只要有了起始位置和长度，就能唯一的确定一个子串。这里使用一个全局变量 minLeft 来记录最终结果子串的起始位置，初始化为 -1，最终配合上 minLen，就可以得到最终结果了。注意在返回的时候要检测一下若 minLeft 仍为初始值 -1，需返回空串

## 77. conbination

这道题目属于比较经典的组合问题，只不过这道题目的组合的长度是自定义可以变化的，仅仅需要修改添加到 paths 的条件即可。

## 78. subsets

递归，回溯法。要设置的变量 paths , path， index, nums(输入变量)

## 79. word search

这道是一个典型的回溯的题目，回溯是 DFS 的一种，但是有一个区别就是回溯在每次调用函数进行递归结束之后要把标记删除掉，这样下次其他递归还可以使用相应的对象。普通 DFS 是找一个可达性，而回溯包括一些匹配与排列组合的概念在里面，因此一个排列组合不对，要把标记清楚，可能其他排列组合就用上了。

还有要注意的一点就是，对于结果是 bool 类型，要把 bool 结果作为函数进行返回，多个返回之间进行取或，因为或操作如果有一个是 true 就整体是 true，后面的就不需要判断了，因此这样能加快函数进行，如果放在&参数里面进行返回，那么每一种情况都会进行，会白跑一些情况。

## 83. Remove Duplicates from Sorted List

这道题目是去除有序链表里面的重复数组，关键的步骤就是如果判断 head->val == head->next->val 那么就 head->next = head->next->next;

## 84. Maximal Rectangle

使用类似于 84 的解法，将原来的矩阵从上到下，具有连续 1 的累加起来，不连续的变为 0，这样没一个新产生的行使用 84 的解法计算，找到最大值。

## 87. scramble-string

可以使用递归或者动态规划的解法。（1）递归解法就是遍历不同的切割方法，但是每种情况不仅要左右对称比较，还要左右交叉比较。需要注意的是，要预先比较两个字符串字符是不是字母都一样，如果不一样肯定返回 false，这样可以加快速度，否则递归会超时。（2）DP 解法是设计三维的 dp 矩阵，三个维度分别是左串起始，右串起始，长度。递推方案是先解决所有长度为 1 的情况，遍历即可。然后对于长度高一层级的情况，都有低一层级的所有子情况推出来，具体递推公式就是左右对称比较和交叉比较，然后逐渐升高长度大小，最终得到最终结果。

动态规划的过程可以看作就情况的逆过程，递推是从最高维度向下分解，但是分解的子情况可能有很多是重复的，这时候会增加计算量，动态情况是找到里面的构建规律，然后逐渐推倒到我们想要的结果，是从最简单情况到复杂情况的过程，而递推是复杂情况渐分解到最简单情况的过程。

## 88. merge-sorted-array

双指针。从尾部开始遍历，逐渐把较大的数字往后放。注意结束的条件是两种：2 数组先到头，那么直接结束，因为 1 数组前面的数字还在原来的位置上。另一种情况是 1 数组先到头，那么就不用比较了，直接将剩下的 2 数组内容依次填好。

## 90. subsets 2

求子集，这道题目是根据备选的数字，找到所有可能组合的子集。注意备选的数字可能有重复。

这里由于备选的数字有重复，因此对于前一个数字没有访问标记，但是当前数字和前一个数字相同的，说明处于同一个位置，那么直接跳过。

由于组合不能有重复，因此新的数字要大于等于 path 的末尾数字，同时对于当前已经正在访问的数组，直接跳过。

## 91. Decode Ways

动态规划解法，使用一个数组 dp 表示记录的数据，列写出动态规划的递推方程，dp[i]=dp[i-1]+dp[i-2],不过这里的递推公式因为边界条件不一样而有所不同。

## 93. restore ip addresses

使用回溯法进行解决，但是要主要判断几个条件不能当作 ip 地址中间的段，分别是：要在 0 ～ 255 之间，不能有 010,001 这样的情况，段的大小要和 i 相等，否则可能在最终结果中加入了相同的东西。

还可以暴力一点，四个 for 循环便利所有可能情况，并对总数目等于 s 大小的去进一步判断，判断每一个段是不是符合那几个条件，如果符合就是最终结果。

## 94. Binary Tree Inorder Traversal

可以使用递归的方法，也可以使用非递归的方法。

下面再来看非递归使用栈的解法，也是符合本题要求使用的解法之一，需要用栈来做，思路是从根节点开始，先将根节点压入栈，然后再将其所有左子结点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中。这样就保证了访问顺序为左-根-右，

## 95. unique binary search trees 2

分而治之思想，这里也可以使用记忆 hash 表或者记忆数组进行记录，本质上，使用记忆数组的递归是动态规划的一种。

## 101. symmetric-tree

使用递归的思想可以判断，判断右子树的左子树是不是相等，判断左子树的右子树是不是相等。

## 104. Maximum Depth of Binary Tree

计算树的高度，使用递归的思想可以完成。

## 108. Convert Sorted Array to Binary Search Tree

将一个有序数组转化为一个 BST,使用递归实现，逐步将最中间的数字作为根节点。

## 109. Convert Sorted List to Binary Search Tree

对于寻找一个链表的中点的问题，可以使用快慢指针实现。

## 110. Balanced Binary Tree

这道题目是判断是不是平衡二叉树，首先需要判断二叉树的高度，然后使用递归的思想判断是不是 BST,如果一个树是 BST，那么他的两个子树都是 BST，且两个子树的高度相差不超过 1。

## 111. Minimum Depth of Binary Tree

这道题目是计算根节点到叶子节点的最短路径，可以使用递归实现。

## 112. path sum

这道题目也可以使用递归进行判断，然后注意边界条件就可以。

## 121. Best Time to Buy and Sell Stock

设置两个变量一个是最大利润，一个是到当前之间为止，前面的最小买入价格，然后遍历，再每次遍历的时候，计算当前卖出价格和前面最小买入价格的差价

## 122. Best Time to Buy and Sell Stock 2

使用贪心的思想，只要后一天比前一天价格高，就会有利润，因此可以计算后一天比前一天收益大于 0 并累积

## 123. Best Time to Buy and Sell Stock III

这道是买股票的最佳时间系列问题中最难最复杂的一道，前面两道 Best Time to Buy and Sell Stock 和 Best Time to Buy and Sell Stock II 的思路都非常的简洁明了，算法也很简单。而这道是要求最多交易两次，找到最大利润，还是需要用动态规划 Dynamic Programming 来解，而这里我们需要两个递推公式来分别更新两个变量 local 和 global，参见网友 Code Ganker 的博客，我们其实可以求至少 k 次交易的最大利润，找到通解后可以设定 k = 2，即为本题的解答。我们定义 local[i][j]为在到达第 i 天时最多可进行 j 次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义 global[i][j]为在到达第 i 天时最多可进行 j 次交易的最大利润，此为全局最优。它们的递推式为：

local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)

global[i][j] = max(local[i][j], global[i - 1][j])

其中局部最优值是比较前一天并少交易一次的全局最优加上大于 0 的差值，和前一天的局部最优加上差值中取较大值，而全局最优比较局部最优和前一天的全局最优

---

这道题是 Best Time to Buy and Sell Stock 的扩展，现在我们最多可以进行两次交易。我们仍然使用动态规划来完成，事实上可以解决非常通用的情况，也就是最多进行 k 次交易的情况。
这里我们先解释最多可以进行 k 次交易的算法，然后最多进行两次我们只需要把 k 取成 2 即可。我们还是使用“局部最优和全局最优解法”。我们维护两种量，一个是当前到达第 i 天可以最多进行 j 次交易，最好的利润是多少（global[i][j]），另一个是当前到达第 i 天，最多可进行 j 次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j]）。下面我们来看递推式，全局的比较简单，

global[i][j]=max(local[i][j],global[i-1][j])，

也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。对于局部变量的维护，递推式是

local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)，

也就是看两个量，第一个是全局到 i-1 天进行 j-1 次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要 j-1 次交易，最后一次交易取当前天），第二个量则是取 local 第 i-1 天 j 次交易，然后加上今天的差值（这里因为 local[i-1][j]比如包含第 i-1 天卖出的交易，所以现在变成第 i 天卖出，并不会增加交易次数，而且这里无论 diff 是不是大于 0 都一定要加上，因为否则就不满足
local[i][j]必须在最后一天卖出的条件了）。
上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是 O(n\*k)，如果是最多进行两次交易，那么复杂度还是 O(n)。空间上只需要维护当天数据皆可以，所以是 O(k)，当 k=2，则是 O(1)。代码如下： 
————————————————
版权声明：本文为 CSDN 博主「Code_Ganker」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/linhuanmars/article/details/23236995

## 125. Valid Palindrome

双指针，两边开始便利，但是要注意边界条件：如果一个字母也没有

## 127. word ladder

BFS 查找，主要是要判断好只相差一个字母的两个字符串，如果只相差一个字母，就认为他们在图上是相邻的。

## 128. Longest Consecutive Sequence

这道题要求求最长连续序列，并给定了 O(n)复杂度限制，我们的思路是，使用一个集合 HashSet 存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后分别用两个变量 pre 和 next 算出其前一个数跟后一个数，然后在集合中循环查找，如果 pre 在集合中，那么将 pre 移除集合，然后 pre 再自减 1，直至 pre 不在集合之中，对 next 采用同样的方法，那么 next-pre-1 就是当前数字的最长连续序列，更新 res 即可。这里再说下，为啥当检测某数字在集合中存在当时候，都要移除数字。这是为了避免大量的重复计算，就拿题目中的例子来说吧，我们在遍历到 4 的时候，会向下遍历 3，2，1，如果都不移除数字的话，遍历到 1 的时候，还会遍历 2，3，4。同样，遍历到 3 的时候，向上遍历 4，向下遍历 2，1，等等等。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效，所以我们要从 HashSet 中移除数字，

## 130. surrounded regions

先遍历四周，将遍历的区域全部变为第三个字母，比如‘T’，然后全部扫描一遍，将 O 变成 X,将 T 变成 O,这里遍历可以使用 BFS 或者 DFS，同时，主要到 DFS 可以使用递归来实现，写一个 help 函数 dfs，如果找到联通的点，就递归进去，直到最深处在回来，和 DFS 的本质思想是一样的

## 131. palindrome-partition

这道题目是根据给定的字符串，然后找到所有可能将字符串进行分割，使得分开的每一个字符串都是一个回文序列。

首先写一个工具函数，判断是个字符串是不是回文序列。

然后因为本质上还是组合问题，因此仍然使用回溯法。回溯 help 函数参数包括 paths，path，和起始 index。 从起始 index 起始遍历所有长度 length, 直到起始 index+length==s.size()，判断子字符串是不是回文序列。

如果是回文序列，就添加到 path 里面，并继续深入进行探索，但是起始 index 要增加 length。

最终判断是否添加到 paths，就是看看起始 index 是否达到了 s 的大小，说明已经探索到了末尾。

## 136. single number

使用异或进行处理，异或满足交换率和结合率，可以将两个相同大小的数字消掉。

## 137. single number 2

使用标记的 ones twos 变量进行每一个位的 1 的个数的记录，也可以推广到其他的问题， 比如三个四个重复的数字

但是这种方法不好理解，下面这种方法比较好理解，虽然比较慢。

这道题是之前那道 Single Number 的延伸，那道题的解法就比较独特，是利用计算机按位储存数字的特性来做的，这道题就是除了一个单独的数字之外，数组中其他的数字都出现了三次，还是要利用位操作 Bit Manipulation 来解。可以建立一个 32 位的数字，来统计每一位上 1 出现的个数，如果某一位上为 1 的话，那么如果该整数出现了三次，对 3 取余为 0，这样把每个数的对应位都加起来对 3 取余，最终剩下来的那个数就是单独的数字

## 138. 复制带随机指针的链表

思路 用一个哈希表表示映射关系：键是原节点，值是复制的节点。

整体算法流程是：

第一次遍历，复制每个节点和 next 指针，并且保存“原节点-复制节点”的映射关系
第二次遍历，通过哈希表获得节点对应的复制节点，更新 random 指针

我们也 1 可以使用递归的解法，写起来相当的简洁，还是需要一个 HashMap 来建立原链表结点和拷贝链表结点之间的映射。在递归函数中，首先判空，若为空，则返回空指针。然后就是去 HashMap 中查找是否已经在拷贝链表中存在了该结点，是的话直接返回。否则新建一个拷贝结点 res，然后建立原结点和该拷贝结点之间的映射，然后就是要给拷贝结点的 next 和 random 指针赋值了，直接分别调用递归函数即可

## 139. word-break

这道题目是计算是否可以从备选的单词片段中组成目标单词。

dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。

该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 "leetcode"：

["lee", "tc", "cod"]

求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。

## 141. linked list cycle

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。如果快指针到达末尾，则说明没有环。

## 144. Binary Tree Preorder Traversal

前序遍历。可以递归，也可以使用栈进行 DFS。

## 145. Binary Tree Postorder Traversal

二叉树的后序遍历。可以使用递归实现

```
void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}
```

也可以使用非递归实现：
前序遍历为 root -> left -> right，后序遍历为 left -> right -> root。可以修改前序遍历成为 root -> right -> left，那么这个顺序就和后序遍历正好相反。

## [151] 翻转字符串里的单词

方法一：先全部反转，然后对每个单词进行反转。

方法二：使用 istringstream 可以很方便的对带空格的字符进行分割。

## 153. find minimum in rotated sorted array

二分查找，关键是找到二分查找的分割条件。

## 155. Min Stack

这道题目是实现一个可以随时返回堆栈里面最小值的堆栈。只需要设置两个堆栈即可，其中一个堆栈保持最小值。然后注意一些进入最小值的堆栈的细节即可。

## 160. Intersection of Two Linked Lists

这道题目是确定两个链表的相交焦点。

可以使用循环两次的方法，当其中一个链表到达结尾之后，跳转到另一个链表。

如果有焦点，那么循环两次之后一定在焦点相遇，如果没有焦点，那么一定在链表的末尾相遇，而且都是 NULL;

## 167. two sum 2

这里是用双指针，不断判断当前两个数字的和与 target 的大小，然后移动相应的指针，指导两个指针相遇或者找到了两个匹配的数字

## 168. excel-sheet-column-title

这里就是注意将输入的数字减一进行处理，可以用递归也可以不用递归

## 169. majority-element

寻找数组中最大 majority，即数目超过 n/2 的个数的数字，这里可以使用很多种方法：（1）排序，返回中间值。（2）摩尔计数。即确定一个摩尔基数器，开始赋值为 0,当预选数字和当前遍历的数字相等的时候，计数器加一，当不相等的时候，计数器减一。如果计数器等于 0 了，那么赋值当前预选数字为当前遍历的数字。所有数字全部遍历完成后，预选数字即为 majority。（3）位操作。如果一个数字是 majority，那么每一个位上面的最大个数的位（0 或 1），组成的二进制数字就是 majority，可以遍历每一个位来寻找。（4）递归+分而治之。可以分左右两个子数组进行递归，返回的左右结果如果相同，那么就是 majority，如果不同，需要比较两个数字的个数谁大。（5）hash 表。可以按顺序遍历，存放到 hash 表中，如果相同就加一，直到个数超过 n/2 就返回。

## 171. excel-sheet-column-number

和 168 本质是一样的，就是注意字母的对应关系是：数字减一与相应字母对应

## 172. Factorial Trailing Zeroes

这道题目是计算 n 的阶乘的末尾 0 的数量。

尾部的 0 由 2 \* 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。

对于一个数 N，它所包含 5 的个数为：N/5 + N/5^2 + N/5^3 + ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5^2 表示不大于 N 的数中 5^2 的倍数再贡献一个 5 ...。

## 188. Best Time to Buy and Sell Stock IV

这道题目是题目 123 的一般性推广，递推公式可以参考题目 123,但是需要注意的是，如果 k >= prices.size()/2,直接使用贪心算法计算即可（参考题目 122）。

## 190. reverse bits

移位操作即可。

也可以按照单独一个位一个位进行处理，也可以按照四个位或更多的位一起进行处理，但是要提前计算好对应的映射表

## 191. numbers of 1 bits

可以使用 n&(n-1)， 它的作用是可以把 n 的二进制表示中的最低位为 1 的改为 0，每更改一次计数器+1，直到 n=0 停止

## 198. house-robber

动态规划经典题目，递推公式是 dp[i] = max(dp[i-1], dp[i-2]+ nums[i]) 也可以修改为长量的额外空间算法，使用 pre 和 pre_pre 两个变量代表 dp[i-1]和 dp[i-2],并不断更新这两个变量

## 200. number of islands

BFS 或 DFS 和题目 695 很像，这道题目不需要计数，只需要遍历完毕之后，在总数目上面加 1 即可，不需要求最大面积。只需要求岛的个数。

## 204. count-primes

这道题目是计算小于 n 的所有质数，质数是因子仅仅包括自己和 1 的数字。1 不是质数。

这道题目的思想是： 从 2 开始遍历到 n，先找到第一个质数 2，然后将其所有的倍数全部标记出来，然后到下一个质数 3，标记其所有倍数，一次类推，直到根号 n，此时数组中未被标记的数字就是质数。我们需要一个 n-1 长度的 bool 型数组来记录每个数字是否被标记， 这就是实现埃拉托斯特尼筛法，难度并不是很大。

## 205. Isomorphic Strings

这道题目是判断两个字符串是不是同构的。

可以使用字符串数组 128 来代表所有字符，设计 t1,t2，题目说两个字符串的大小相等，那么开始遍历，将两个字符串当前的两个字符，都在 t1 与 t2 里面记录下来，记录下来的标记就是当前的下标加 1（为了与初始化的 t1 和 t2 区分开来）。

如果发现某一次 t1 和 t2 对应的位置不同，要么是一个被访问过，一个没被访问过，要么是两个都被访问过，但是二者上一次出现的位置不同，这两种情况都说明，这两个字符串不是同构的，返回 false 即可，全部遍历完成都没问题，那么返回 true 即可。

## 206. Reverse Linked List

链表反转。

包括迭代方法和递归方法。迭代方法就是设置一个 pre 指针，然后不断插入到 pre->next。递归方法就是不断进行递归，每次递归返回一个头指针，注意保存临时变量。

重要注意的点就是算清楚 next 的链接关系。

## 207. Course Schedule

这道课程清单的问题对于我们学生来说应该不陌生，因为我们在选课的时候经常会遇到想选某一门课程，发现选它之前必须先上了哪些课程，这道题给了很多提示，第一条就告诉我们了这道题的本质就是在有向图中检测环。 LeetCode 中关于图的题很少，有向图的仅此一道，还有一道关于无向图的题是 Clone Graph。个人认为图这种数据结构相比于树啊，链表啊什么的要更为复杂一些，尤其是有向图，很麻烦。第二条提示是在讲如何来表示一个有向图，可以用边来表示，边是由两个端点组成的，用两个点来表示边。第三第四条提示揭示了此题有两种解法，DFS 和 BFS 都可以解此题。我们先来看 BFS 的解法，我们定义二维数组 graph 来表示这个有向图，一维数组 in 来表示每个顶点的入度。我们开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后我们定义一个 queue 变量，将所有入度为 0 的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为 0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为 0，则说明环存在，返回 false，反之则返回 true。

下面我们来看 DFS 的解法，也需要建立有向图，还是用二维数组来建立，和 BFS 不同的是，我们像现在需要一个一维数组 visit 来记录访问状态，这里有三种状态，0 表示还未访问过，1 表示已经访问了，-1 表示有冲突。大体思路是，先建立好有向图，然后从第一个门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用 DFS 递归，直到出现新的课程已经访问过了，则返回 false，没有冲突的话返回 true，然后把标记为已访问的课程改为未访问。

## 208. Implement Trie (Prefix Tree)

这道题让我们实现一个重要但又有些复杂的数据结构-字典树， 又称前缀树或单词查找树，详细介绍可以参见[网友董的博客](http://dongxicheng.org/structure/trietree/)，例如，一个保存了 8 个键的 trie 结构，"A", "to", "tea", "ted", "ten", "i", "in", and "inn"

字典树主要有如下三点性质：

1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。

2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。

3. 每个节点的所有子节点包含的字符串不相同。

字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第 i 次循环找到前 i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。至于结点对儿子的指向，一般有三种方法：

1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；

2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；

3、使用左儿子右兄弟表示法记录这棵树。

三种方法，各有特点。第一种易实现，但实际的空间要求较大；第二种，较易实现，空间要求相对较小，但比较费时；第三种，空间要求最小，但相对费时且不易写。

我们这里只来实现第一种方法，这种方法实现起来简单直观，字母的字典树每个节点要定义一个大小为 26 的子节点指针数组，然后用一个标志符用来记录到当前位置为止是否为一个词，初始化的时候讲 26 个子节点都赋为空。那么 insert 操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，若不存在则新建一个，然后再查找下一个。查找词和找前缀操作跟 insert 操作都很类似，不同点在于若不存在子节点，则返回 false。查找次最后还要看标识位，而找前缀直接返回 true 即可

## 210. Course Schedule II

这道题目和题目 207 很像，就是让我们把课程记录下来，还是使用题目 207 一样的方法，比如使用迭代的方式，就是使用队列，关键是在每次队列弹出元素的时候，加入到 ans 就可以了。

## 213. house-robber2

这道题目也是典型的动态规划问题，可以得到递推公式就是当前所抢劫的户的最大钱数，等于到上上一个户的最大钱数加上当前户的钱数 与 抢劫到上一个户最大钱数的 的二者最大值。

这道题目多了一个要求，就是户是环型的，最后一个户和第一个户不能一起抢。那么可以将这个环问题拆开，我先只抢 0 ～ n-2，在抢 1 ～ n-1，这样第一个户和最后一个户不会被同时抢到，我们再取这两种情况的最大值就可以了。

## 215. kth largest element in an array

可以使用很多种方法：（1）使用 std 的函数 nth_element() 或者 partial_sort() (2) 使用小顶堆，维护一个 K 大小的大顶對，遍历数组，如果当前数字小于小顶堆的最小值，就添加进去，并删除堆顶元素。（3）使用大顶堆，将数组所有元素添加进去，然后不断弹出 K 次堆顶元素。（4）使用快速排序的思想，对数组进行分区。 对于使用堆的方法，可以使用 std 的 priority_queue 来构建，也可以使用 multiset()来构建，也可以使用自己构建的数组来自行构建堆结构。

## 216. combination-sum-3

组合求和，这道题目是根据 1-9 备选数字，选出特定组合求和等于 target 的组合，注意这个组合不能有重复的，而且数组 1-9 只能使用一次，而且长度等于 k 的组合。

这里组合不能有重复的，我们考虑后来新添加到 path 的数字必须大于 path 末尾的数字，这样就能保证数组之间没有重复的。

而且对于 path 能够进入 paths 的标准，如果 path_sum 大于 target,那么直接返回，如果 path 的长度达到了 k,那么判断 path_sum 如果等于 target，那么就可以进入 path_sum,如果不等于，那么就直接返回。

## 217. Contains Duplicate

使用 hash_set 实现即可。

## 225. Implement Stack using Queues

这道题目是用队列实现堆栈，使用一个队列即可，关键就是每次添加新的元素的时候，将原本的的元素都一次挪到后面，让新元素排到第一位。

## 226. Invert Binary Tree

这道题目是翻转二叉树，使用递归的思想即可以。

## 230. Kth Smallest Element in a BST

可以使用中序遍历，对于一个 BST 来说，他的中序遍历序列是递增的。

因此我们中序遍历，就可以很方便的寻找到第 k 个数字。

## 231. Power of Two

这道题目是让我们判断一个数字是不是 2 的 n 次方。

可以使用位操作来做，一个数是 2 的 n 次方，那么 n & (n-1) 一定等于 0

## 232. Implement Queue using Stacks

这道题目是使用堆栈实现队列，关键点就是设置两个堆栈。

## 233. 数字 1 的个数

可以找到规律如下所示：
找到两个关键数字：
a : 0 1 20 300 4000
b : 1 10 100 1000 10000

举例来说：413

其中 b 是如果当前数字最高位等于 1, 那么当前数字的最高位贡献 1 的个数,比如 100 ～ 199 里面一共 100 个 1, 10 ～ 19 里面 10 个 1，1 自己是一个 1。

a 是当前数组排除最高位贡献的 1 的个数，比如 0 ～ 999 里面 300 个 1，0 ～ 99 里面 20 个 1, 0 ～ 9 里面 1 个 1

他们的递推关系就是：
a = a \* 10 + b;
b = b \* 10;

那么拿 413 为例， 首先判断 3,大于 1,那么说明跨过了 1 的门槛，1 对应的区域全部满贯，而 1 没有更小的数字跟在后面了，那么直接就是 1 + 0;

然后判断 1,这个就是 10 位数了，这个数字等于 1,那么就说明 1 对应的区域没有满贯，这里就是他后面的数组加 1 个，也就是 3+1=4 个，然后在计算最高位贡献的 1,也就是 1\*1

然后判断 4, 这个就是百位数了，这个数字大于 1,说明 1 对应的区域已经满贯，也就是 100, 这个代表最高位等于 1 的个数，（100 ～ 199），然后计算尾部数字的 1 的个数，4 \* 20

所有加起来就是结果。

```c
class Solution {
public:
    int countDigitOne(int n) {
        int origin = n;
        int ans = 0;
        long a = 0, b = 1;
        while(n){
            int item = n % 10;
            if(item>1){
                ans += item * a + b;
            }else if(item==1) {
                ans += item * a + origin%b + 1;
            }

            a = a * 10 + b;
            b = b * 10;

            n = n / 10;
        }
        return ans;
    }
};
```

具体思想可以参考下面的文字：

---

问题转化：求最高位对 1 的贡献

例如输入 193，我们先求 1 作为最高位百位对 1 的贡献，假设结果为 c1；然后我们将最高位 1 去掉，就剩下 93，我们求得 9 作为最高位十位对 1 的贡献为 c2；同样我们去掉 9，剩下 3，我们求得 3 作为最高位个位对 1 的贡献是 c3。

答案 = c1+c2+c3。

那么，求最高位对 1 的贡献怎么求？按照以下规则：

如果 n 是一位数，最高位就是个位，由于没有比它更小的位数了，因此对 1 的贡献只有它本身（个位），如果各位数字大于等于 1，贡献是 1，否则贡献是 0。

如果 n 是两位数，最高位就是十位，因此对 1 的贡献分为 0-9 部分和十位本身。0-9：贡献能力是 1，再乘以十位数字就是贡献 1 的个数；十位：贡献大小取决于十位数字，如果十位数字大于 1，则贡献是 10；如果十位数字等于 1，则贡献是去掉十位剩下的数+1。

如果 n 是三位数，最高位就是百位，因此对 1 的贡献分为 0-99 部分和它本身（百位）。0-99：贡献能力是 20，百位：贡献大小取决于百位数字，如果百位数字大于 1，则贡献是 100；如果十位数字等于 1，则贡献是去掉百位剩下的数+1。

如果 n 是四位数，最高位就是千位，因此对 1 的贡献分为 0-999 部分和它本身（千位）。0-999：贡献能力是 300，千位：贡献大小取决于千位数字，如果千位数字大于 1，则贡献是 1000；如果千位数字等于 1，则贡献是去掉千位剩下的数+1。

以此类推。。。。。。

举例说明：

413 是个三位数，我们这里先考虑最高位 4 对 1 的贡献，根据上面的规则，贡献分为 0-99 部分和百位部分。首先说 0-99 贡献：0-99 共有 20 个 1，因此贡献能力是 20，一共有四次（0-99、100-199、200-299、300-399），因此共贡献了 4\*20 = 80 个 1；再说百位的贡献：因为百位数字是 4，大于 1，因此百位的贡献就是 100（100、101、...、199 一共 100 个 1）。因此，413 最高位 4 对 1 的贡献 = 4\*20+100 = 180。

你可能会问，这里只考虑最高位 4 对 1 的贡献，后面的 13 也贡献了 6 个 1。没错，因此我们考虑完 4 对 1 的贡献后，就要将 4 剔除，剩下 13，我们还是套用此规则。

13 是个两位数，我们这里只找最高位 1 对 1 的贡献，根据上面的规则，贡献分为 0-9 部分和十位部分。首先说 0-9 贡献：0-9 共有 1 个 1，因此贡献能力是 1，一共有 1 次（0-9），因此共贡献了 1\*1 = 1 个 1；再说十位的贡献：因为十位数字等于 1，因此十位的贡献就是 4（去掉十位后的数+1，即 3+1，因为 10、11、12、13）。因此，13 最高位十位 1 对 1 的贡献 = 1\*1+4 = 5。

然后剔除十位 1，只剩下 3 了，3 大于等于 1，所以贡献是 1。

因此结果 = 4\*20+100 + 1\*1+4 + 1 = 186。

0-9 贡献能力是 1，0-99 贡献能力是 20，0-999 贡献能力是 300，0-9999 贡献能力是 4000，这是怎么来的？

1\*10+10 = 20；20\*10+10^2=300；300\*10+10^3=400。就是这个规律。

## 234. Palindrome Linked List

这道题目判断链表是不是回文序列。
使用快慢指针，可以找到链表的最中间的位置，一个指针从头开始，一个指针从中间开始， 然后可以判断链表两半部分是不是相等。

## 235. Lowest Common Ancestor of a Binary Search Tree

这道题我们可以用递归来求解，我们首先来看题目中给的例子，由于二叉搜索树的特点是左<根<右，所以根节点的值一直都是中间值，大于左子树的所有节点值，小于右子树的所有节点值，那么我们可以做如下的判断，如果根节点的值大于 p 和 q 之间的较大值，说明 p 和 q 都在左子树中，那么此时我们就进入根节点的左子节点继续递归，如果根节点小于 p 和 q 之间的较小值，说明 p 和 q 都在右子树中，那么此时我们就进入根节点的右子节点继续递归，如果都不是，则说明当前根节点就是最小共同父节点，直接返回即可

## 236. Lowest Common Ancestor of a Binary Tree

这道求二叉树的最小共同父节点的题是之前那道 Lowest Common Ancestor of a Binary Search Tree 的 Follow Up。跟之前那题不同的地方是，这道题是普通是二叉树，不是二叉搜索树，所以就不能利用其特有的性质，我们只能在二叉树中来搜索 p 和 q，然后从路径中找到最后一个相同的节点即为父节点，可以用递归来实现，在递归函数中，首先看当前结点是否为空，若为空则直接返回空，若为 p 或 q 中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了 p 和 q 一定都在二叉树中存在，那么如果当前结点不等于 p 或 q，p 和 q 要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论：

- 若 p 和 q 分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回 p 和 q 结点的位置，而当前结点正好就是 p 和 q 的最小共同父结点，直接返回当前结点即可，这就是题目中的例子 1 的情况。

- 若 p 和 q 同时位于左子树，这里有两种情况，一种情况是 left 会返回 p 和 q 中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子 2 的情况。还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的左子树中的某个结点才是 p 和 q 的最小父结点，会被返回。

- 若 p 和 q 同时位于右子树，同样这里有两种情况，一种情况是 right 会返回 p 和 q 中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的右子树中的某个结点才是 p 和 q 的最小父结点，会被返回，写法很简洁

## 238. Product of Array Except Self

这道题给定我们一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限定了时间复杂度 O(n)，并且不让我们用除法。如果让用除法的话，那这道题就应该属于 Easy，因为可以先遍历一遍数组求出所有数字之积，然后除以对应位置的上的数字。但是这道题禁止我们使用除法，那么我们只能另辟蹊径。我们想，对于某一个数字，如果我们知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果，所以我们只要分别创建出这两个数组即可，分别从数组的两个方向遍历就可以分别创建出乘积累积数组。

我们可以对上面的方法进行空间上的优化，由于最终的结果都是要乘到结果 res 中，所以可以不用单独的数组来保存乘积，而是直接累积到结果 res 中，我们先从前面遍历一遍，将乘积的累积存入结果 res 中，然后从后面开始遍历，用到一个临时变量 right，初始化为 1，然后每次不断累积，最终得到正确结果.

## 239. 滑动窗口最大值

这道题给定了一个数组，还给了一个窗口大小 k，让我们每次向右滑动一个数字，每次返回窗口内的数字的最大值。难点就在于如何找出滑动窗口内的最大值（这不废话么，求得不就是这个），那么最狂野粗暴的方法就是每次遍历窗口，找最大值呗，OJ 说呵呵哒，no way！我们希望窗口内的数字是有序的，但是每次给新窗口排序又太费时了，所以最好能有一种类似二叉搜索树的结构，可以在 lgn 的时间复杂度内完成插入和删除操作，那么使用 STL 自带的 multiset 就能满足我们的需求，这是一种基于红黑树的数据结构，可以自动对元素进行排序，又允许有重复值，完美契合。所以我们的思路就是，遍历每个数字，即窗口右移，若超过了 k，则需要把左边界值删除，这里不能直接删除 nums[i-k]，因为集合中可能有重复数字，我们只想删除一个，而 erase 默认是将所有和目标值相同的元素都删掉，所以我们只能提供一个 iterator，代表一个确定的删除位置，先通过 find() 函数找到左边界 nums[i-k] 在集合中的位置，再删除即可。然后将当前数字插入到集合中，此时看若 i >= k-1，说明窗口大小正好是 k，就需要将最大值加入结果 res 中，而由于 multiset 是按升序排列的，最大值在最后一个元素，我们可以通过 rbegin() 来取出。

我们也可以使用优先队列来做，即最大堆，不过此时我们里面放一个 pair 对儿，由数字和其所在位置组成的，这样我们就可以知道每个数字的位置了，而不用再进行搜索了。在遍历每个数字时，进行 while 循环，假如优先队列中最大的数字此时不在窗口中了，就要移除，判断方法就是将队首元素的 pair 对儿中的 second（位置坐标）跟 i-k 对比，小于等于就移除。然后将当前数字和其位置组成 pair 对儿加入优先队列中。此时看若 i >= k-1，说明窗口大小正好是 k，就将最大值加入结果 res 中即可

## 240. Search a 2D Matrix II

突然发现 LeetCode 很喜欢从 LintCode 上盗题，这是逼我去刷 LintCode 的节奏么?! 这道题让我们在一个二维数组中快速的搜索的一个数字，这个二维数组各行各列都是按递增顺序排列的，是之前那道 Search a 2D Matrix 搜索一个二维矩阵的延伸，那道题的不同在于每行的第一个数字比上一行的最后一个数字大，是一个整体蛇形递增的数组。所以那道题可以将二维数组展开成一个一位数组用一次二查搜索。而这道题没法那么做，这道题有它自己的特点。如果我们观察题目中给的那个例子，我们可以发现有两个位置的数字很有特点，左下角和右上角的数。左下角的 18，往上所有的数变小，往右所有数增加，那么我们就可以和目标数相比较，如果目标数大，就往右搜，如果目标数小，就往上搜。这样就可以判断目标数是否存在。当然我们也可以把起始数放在右上角，往左和下搜，停止条件设置正确就行

## 241. different ways to add parentheses

可以使用分而治之进行解决，改进一点是可以使用 hash 表记录一些映射，以时间换空间提高计算效率。本题就是按照计算符号将原来的子符串分为两边，两边分别调用原来函数递归得到结果。对于左右的结果，分别遍历交叉计算得到最终的结果。

## 242. Valid Anagram

这道题目让我们判断两个字符串是不是相同字母的。

可以使用 hashmap 来进行统计，又因为这里面仅仅涉及到字母，可以使用大小为 26 的数组，若涉及到各种所有字符，那么可以使用大小为 128 数组。

这里面如果使用 hashmap 空间复杂度计算的时候 O(n),但是使用固定大小的数组的空间复杂度是 O(1)

## 260. Single Number 3

这道题是之前那两道 Single Number 和 Single Number II 的再次延伸，说实话，这类位操作 Bit Manipulation 的题，如果之前没有遇到过类似的题目，楞想是很难相出来的，于是我只能上网搜大神们的解法，发现还真是巧妙啊。这道题其实是很巧妙的利用了 Single Number 的解法，因为那道解法是可以准确的找出只出现了一次的数字，但前提是其他数字必须出现两次才行。而这题有两个数字都只出现了一次，那么我们如果能想办法把原数组分为两个小数组，不相同的两个数字分别在两个小数组中，这样分别调用 Single Number 的解法就可以得到答案。那么如何实现呢，首先我们先把原数组全部异或起来，那么我们会得到一个数字，这个数字是两个不相同的数字异或的结果，我们取出其中任意一位为 ‘1’ 的位，为了方便起见，我们用 a &= -a 来取出最右端为 ‘1’ 的位，具体来说下这个是如何操作的吧。就拿题目中的例子来说，如果我们将其全部 '异或' 起来，我们知道相同的两个数 '异或' 的话为 0，那么两个 1，两个 2，都抵消了，就剩 3 和 5 '异或' 起来，那么就是二进制的 11 和 101 '异或' ，得到 110。然后我们进行 a &= -a 操作。首先变负数吧，在二进制中负数采用补码的形式，而补码就是反码 +1，那么 110 的反码是 11...1001，那么加 1 后是 11...1010，然后和 110 相与，得到了 10，就是代码中的 diff 变量。得到了这个 diff，就可以将原数组分为两个数组了。为啥呢，我们想阿，如果两个相同的数字 '异或' ，每位都会是 0，而不同的数字 '异或' ，一定会有对应位不同，一个 0 一个 1，这样 '异或' 是 1。比如 3 和 5 的二进制 11 和 101，如果从低往高看，最开始产生不同的就是第二位，那么我们用第二位来和数组中每个数字相与，根据结果的不同，一定可以把 3 和 5 区分开来，而其他的数字由于是成对出现，所以区分开来也是成对的，最终都会 '异或' 成 0，不会 3 和 5 产生影响。分别将两个小组中的数字都异或起来，就可以得到最终结果了，

## 264. 丑数 II

这道题是之前那道 Ugly Number 的拓展，这里让找到第 n 个丑陋数，还好题目中给了很多提示，基本上相当于告诉我们解法了，根据提示中的信息，丑陋数序列可以拆分为下面 3 个子列表：

(1) 1x2, 2x2, 2x2, 3x2, 3x2, 4x2, 5x2...
(2) 1x3, 1x3, 2x3, 2x3, 2x3, 3x3, 3x3...
(3) 1x5, 1x5, 1x5, 1x5, 2x5, 2x5, 2x5...
仔细观察上述三个列表，可以发现每个子列表都是一个丑陋数分别乘以 2，3，5，而要求的丑陋数就是从已经生成的序列中取出来的，每次都从三个列表中取出当前最小的那个加入序列

## 268. Missing Number

这道题给我们 n 个数字，是 0 到 n 之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。那么最直观的一个方法是用等差数列的求和公式求出 0 到 n 之间所有的数字之和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字

这题还有一种解法，使用位操作 Bit Manipulation 来解的，用到了异或操作的特性，相似的题目有 Single Number 单独的数字, Single Number II 单独的数字之二和 Single Number III 单独的数字之三。那么思路是既然 0 到 n 之间少了一个数，我们将这个少了一个数的数组合 0 到 n 之间完整的数组异或一下，那么相同的数字都变为 0 了，剩下的就是少了的那个数字了

这道题还可以用二分查找法来做，我们首先要对数组排序，然后我们用二分查找法算出中间元素的下标，然后用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，此时将 right 赋为 mid，反之则将 left 赋为 mid+1。那么看到这里，作为读者的你可能会提出，排序的时间复杂度都不止 O(n)，何必要多此一举用二分查找，还不如用上面两种方法呢。对，你说的没错，但是在面试的时候，有可能人家给你的数组就是排好序的，那么此时用二分查找法肯定要优于上面两种方法，所以这种方法最好也要掌握以下~

## 278. first bad version

二分查找

## 279. perfect squares

动态规划。将原问题思考为最初始的简单问题的汇总，这里就是从 n=1 开始，逐渐增加 n,递推关系为 dp[i] = min(dp[i - j * j] + 1, dp[i]);也可以使用 BFS，思路就是假想有一个 graph，里面每个节点如果满足 i=j+squares 即代表二者相连（Node j is connected to node i via an edge if  
and only if either j = i + (a perfect square number) or i = j + (a perfect square number).）。使用广度优先便利即可以找到最短路径。

## 283. Move Zeroes

这道题目让我们将一个数组的所有 0 放在最后面，同时不改变其他数字的相对次序，同时不使用额外的空间。

这个可以使用双指针进行实现。

左边的指针从头开始遍历，右边的指针从第一个 0 数组开始遍历。

然后两个指针一起前进，如果左指针等于 0,右指针非 0,那么交换这两个数字。

如果左指针非 0，那么直接前进，如果右指针等于 0,那么直接前进，直到右指针到达末尾为之。

## 287. Find the Duplicate Number

这道题给了我们 n+1 个数，所有的数都在 [1, n] 区域内，首先让证明必定会有一个重复数，这不禁让博主想起了小学华罗庚奥数中的抽屉原理(又叫鸽巢原理)，即如果有十个苹果放到九个抽屉里，如果苹果全在抽屉里，则至少有一个抽屉里有两个苹果，这里就不证明了，直接来做题吧。题目要求不能改变原数组，即不能给原数组排序，又不能用多余空间，那么哈希表神马的也就不用考虑了，又说时间小于 O(n2)，也就不能用 brute force 的方法，那也就只能考虑用二分搜索法了，在区间 [1, n] 中搜索，首先求出中点 mid，然后遍历整个数组，统计所有小于等于 mid 的数的个数，如果个数小于等于 mid，则说明重复值在 [mid+1, n] 之间，反之，重复值应在 [1, mid-1] 之间，然后依次类推，直到搜索完成，此时的 low 就是我们要求的重复值

## 295. 找出数据流的中位数

这道题给我们一个数据流，让我们找出中位数，由于数据流中的数据并不是有序的，所以我们首先应该想个方法让其有序。如果我们用 vector 来保存数据流的话，每进来一个新数据都要给数组排序，很不高效。所以之后想到用 multiset 这个数据结构，是有序保存数据的，但是它不能用下标直接访问元素，找中位数也不高效。这里用到的解法十分巧妙，我们使用大小堆来解决问题，其中大堆保存右半段较大的数字，小堆保存左半段较小的数组。这样整个数组就被中间分为两段了，由于堆的保存方式是由大到小，我们希望大堆里面的数据是从小到大，这样取第一个来计算中位数方便。我们用到一个小技巧，就是存到大堆里的数先取反再存，这样由大到小存下来的顺序就是实际上我们想要的从小到大的顺序。当大堆和小堆中的数字一样多时，我们取出大堆小堆的首元素求平均值，当小堆元素多时，取小堆首元素为中位数

## 297. 二叉树的序列化与反序列化

这道题让我们对二叉树进行序列化和去序列化的操作。序列化就是将一个数据结构或物体转化为一个位序列，可以存进一个文件或者内存缓冲器中，然后通过网络连接在相同的或者另一个电脑环境中被还原，还原的过程叫做去序列化。现在让我们来序列化和去序列化一个二叉树，并给了我们例子。这题有两种解法，分别为先序遍历的递归解法和层序遍历的非递归解法。先来看先序遍历的递归解法，非常的简单易懂，我们需要接入输入和输出字符串流 istringstream 和 ostringstream，对于序列化，我们从根节点开始，如果节点存在，则将值存入输出字符串流，然后分别对其左右子节点递归调用序列化函数即可。对于去序列化，我们先读入第一个字符，以此生成一个根节点，然后再对根节点的左右子节点递归调用去序列化函数即可，

另一种方法是层序遍历的非递归解法，这种方法略微复杂一些，我们需要借助 queue 来做，本质是 BFS 算法，也不是很难理解，就是 BFS 算法的常规套路稍作修改即可

## 300. longest-increasing-subsquence

这道题目是求最长子序列。可以使用动态规划进行求解

设计一个数组 dp，dp[i]代表以 nums[i]结尾的最长子序列的长度，然后对于 nums[i],遍历前面的 nums[i](j < i), 如果 nums[i] > nums[j] ，就在 dp[j]上加 1, 说明 nums[j]可以添加到后面的序列中，统计最大值作为 dp[i],然后不断迭代更新。

## 303. range-sum-query-immutable

这道题目比较特殊，构造函数使用一次，子函数调用很多次，所以要求构造函数多做一些任务，子函数做的任务小一些。

这里题目的作用就是返回 i 到 j 之间的求和，那么在构造函数里面，就创建一个数组，数组 i 存储累计到 i 为止的所有元素的和。

子函数直接计算 j-i 就是 i 到 j 之间的和了。

## 309. Best Time to Buy and Sell Stock with Cooldown

这道题目计算股票的最大收益，但是添加了一个条件就是卖出后有一天的冷却期。

设计两个数组，分别是：

have[i],代表第 i 天手里持有股票时的最大收益。

nothave[i]，代表第 i 天手里没有股票是的最大收益。

递推关系式是：

```c++
have[i] = max(have[i-1], (i>=2 ? nothave[i-2] : 0) - prices[i]);
nothave[i] = max(nothave[i-1], have[i-1] + prices[i]);
```

第 i 天 have[i]说明手里有股票，如果没有操作，那么取决于 have[i-1],如果是当天买了，那么取决于 nothave[i-2] - prices[i]，因为有冷却期，取决于前天卖出的最大收益。

第 i 天 nothave[i]说明手里没有股票，如果没有操作，那么取决于 nothave[i-1]，如果当天是卖出，那么取决于 have[i-1]。

## 318. Maximum Product of Word Lengths

题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。

本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数的各个位来表示字母的出现。

如果两个字符串没有相同的字符，那么两个数字进行位与操作一定是 0,这样判断起来就很快。

## 322. coin-change

这道题目是完全背包问题：想比于普通背包问题，也叫 01 背包问题（例如题目 416），二者区别在于：

> 1. 完全背包问题可以使用无限次物品
> 2. 01 背包问题只能使用一次物品

具体就是体现在循环队列是正序还是倒序列。

我知道，背包问题的递推公式如下：

```c
dp[i] = min(dp[i], dp[i-num]+1);
```

在进行循环遍历的样子如下：

完全背包：

```c
for(int num : coins){
    for(int i=num;i<=amount;i++){
        dp[i] = min(dp[i], dp[i-num]+1);
    }
}
```

01 背包：

```c
for(int num : coins){
    for(int i=amount;i>=num;i--){
        dp[i] = min(dp[i], dp[i-num]+1);
    }
}
```

为什么 01 背包要倒序呢，这是因为 01 背包必须物品只能使用一次，如果正序的话，比如 dp[3]更新了一次，说明使用了当前遍历的物品，那么后续遍历的时候，dp[8]可能用到了 dp[3],又更新一次，那么这个物品又被使用了一次，这是不符合 01 背包物品只能使用一次的规则的。因此倒序进行，先更新 dp[8],这时候使用的 dp[3]肯定是没有被更新过得，保证整个遍历的过程中，物品仅仅被使用一次。

那么对于完全背包问题，由于物品可以使用无限次，那么必须使用正序，倒序反而不合适。

## 326. Power of Three

这道题目是判断 n 是不是 3 的倍数。

一种巧妙的方法，利用对数的换底公式来做，高中学过的换底公式为 logab = logcb / logca，那么如果 n 是 3 的倍数，则 log3n 一定是整数，我们利用换底公式可以写为 log3n = log10n / log103，注意这里一定要用 10 为底数，不能用自然数或者 2 为底数，否则当 n=243 时会出错，原因请看这个帖子。现在问题就变成了判断 log10n / log103 是否为整数，在 c++中判断数字 a 是否为整数，我们可以用 a - int(a) == 0 来判断

## 328. odd even linked list

这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。我们可以使用两个指针来做，pre 指向奇节点，cur 指向偶节点，然后把偶节点 cur 后面的那个奇节点提前到 pre 的后面，然后 pre 和 cur 各自前进一步，此时 cur 又指向偶节点，pre 指向当前奇节点的末尾，以此类推直至把所有的偶节点都提前了即可

## 337. house-robber 3

这道题是之前那两道 House Robber II 和 House Robber 的拓展，这个小偷又偷出新花样了，沿着二叉树开始偷，碉堡了，题目中给的例子看似好像是要每隔一个偷一次，但实际上不一定只隔一个，比如如下这个例子：

```
        4
       /
      1
     /
    2
   /
  3
```

如果隔一个偷，那么是 4+2=6，其实最优解应为 4+3=7，隔了两个，所以说纯粹是怎么多怎么来，那么这种问题是很典型的递归问题，可以利用回溯法来做，因为当前的计算需要依赖之前的结果，那么对于某一个节点，如果其左子节点存在，通过递归调用函数，算出不包含左子节点返回的值，同理，如果右子节点存在，算出不包含右子节点返回的值，那么此节点的最大值可能有两种情况，一种是该节点值加上不包含左子节点和右子节点的返回值之和，另一种是左右子节点返回值之和不包含当期节点值，取两者的较大值返回即可，但是这种方法无法通过 OJ，超时了，所以必须优化这种方法，这种方法重复计算了很多地方，比如要完成一个节点的计算，就得一直找左右子节点计算，可以把已经算过的节点用 HashMap 保存起来，以后递归调用的时候，现在 HashMap 里找，如果存在直接返回，如果不存在，等计算出来后，保存到 HashMap 中再返回，这样方便以后再调用，

## 338. Counting Bits

这道题给我们一个整数 n，然我们统计从 0 到 n 每个数的二进制写法的 1 的个数，存入一个一维数组中返回，题目中明确表示不希望我们一个数字一个数字，一位一位的傻算，而是希望我们找出规律，而且题目中也提示了我们注意 [2-3], [4-7], [8-15] 这些区间的规律，那么我们写出 0 到 15 的数的二进制和 1 的个数如下：

```
0    0000    0
-------------
1    0001    1
-------------
2    0010    1
3    0011    2
-------------
4    0100    1
5    0101    2
6    0110    2
7    0111    3
-------------
8    1000    1
9    1001    2
10   1010    2
11   1011    3
12   1100    2
13   1101    3
14   1110    3
15   1111    4
```

我最先看出的规律是这样的，除去前两个数字 0 个 1，从 2 开始，2 和 3，是 [21, 22) 区间的，值为 1 和 2。而 4 到 7 属于 [22, 23) 区间的，值为 1,2,2,3，前半部分 1 和 2 和上一区间相同，2 和 3 是上面的基础上每个数字加 1。再看 8 到 15，属于 [23, 24) 区间的，同样满足上述规律

## 342. Power of Four

这道题目让我们判断一个数字是不是 4 的倍数。

首先判断是不是小于等于 0,然后判断是不是 2 的倍数，然后进行位操作，逐渐移位统计 1 后面 0 的个数，如果统计 0 的个数是偶数个，那么就是 4 的倍数。

## 343. integer-break

这道题目是将一个整数进行拆分，以计算拆分后的各部分积求得最大值。

这道题目一个技巧就是，拆分越多的 3,最终的积的最大。所以拆分求得 3 越多越好，再把剩下的部分乘进去。如果剩下的是>=5,那么继续拆分，如果是 4,那么就乘进去。

还可以用动态规划进行求解，任意一个数字 n，设计一个动态规划数组 dp，代表可以求得的最大积，逐步计算到 dp[n]

对于一个数字 i,可以遍历他其中的一个和因子 j,那么他的另外一部分就是 i-j.

如果不对 i-j 进行拆分，那么求积就是 j\*(i-j), 如果对 i-j 进行拆分，那么求积就是 j\*(dp[i-j]), 二者取最大就是最大积。

## 345. reverse vowels of a string

可以使用 hash 表存储元音字母，然后使用双指针从两边遍历，如果是元音，则交换。另一种方法是 find_last_of 与 find_first_of 函数，不使用 hash 表

## 347. top k frequent elements

使用 hashmap 储存每个数据出现的次数，然后可以使用大顶堆来选出 top k,也可以使用桶排序来计算，桶排序就是将相同出现次数的数字放在一个桶中，然后全部放进去之后，从后向前遍历桶

## 367. Valid Perfect Square

遍历从 2 到 n/2 的范围，检测是否 i\*i==num，如果检测大于 num，那么直接 false，如果等于 num，那么直接 true。

## 371. Sum of Two Integers

这道题是 CareerCup 上的一道原题，可参加我之前的博客 18.1 Add Two Numbers。让我们实现两数相加，但是不能用加号或者其他什么数学运算符号，那么我们只能回归计算机运算的本质，位操作 Bit Manipulation，我们在做加法运算的时候，每位相加之后可能会有进位 Carry 产生，然后在下一位计算时需要加上进位一起运算，那么我们能不能将两部分拆开呢，我们来看一个例子 759+674

1. 如果我们不考虑进位，可以得到 323

2. 如果我们只考虑进位，可以得到 1110

3. 我们把上面两个数字假期 323+1110=1433 就是最终结果了

然后我们进一步分析，如果得到上面的第一第二种情况，我们在二进制下来看，不考虑进位的加，0+0=0，0+1=1, 1+0=1，1+1=0，这就是异或的运算规则，如果只考虑进位的加 0+0=0, 0+1=0, 1+0=0, 1+1=1，而这其实这就是'与'的运算，而第三步在将两者相加时，我们再递归调用这个算法，终止条件是当进位为 0 时，直接返回第一步的结果。一切都是如此的美好，突然有一天，博主的所有方法都无法通过 OJ 了，不知为何，原因不明。在热心网友 GGGGITFK 的提示下，终于知道了错误的原因：

runtime error: left shift of negative value -2147483648，对 INT_MIN 左移位。

就是 LeetCode 自己的编译器比较 strict，不能对负数进行左移，就是说最高位符号位必须要为 0，才能左移（此处应有尼克杨问号脸？！），好吧，你赢了。那么我们在 a 和 b 相'与'之后，再'与'上一个最高位为 0，其余位都为 1 的数 0x7fffffff，这样可以强制将最高位清零，然后再进行左移，终于，世界清静了

## 376. wiggle-subsequence

这道题目求最长摆动子序列。 动态规划方式进行解决，设计两个数组 up 和 down, 代表到 i 为止以上升沿和下降沿为止的摆动序列的最长长度。

如果 nums[i] > nums[i-1], 则上升沿数组更新（在 down[i-1]上加一），下降沿数组维持上一个不变。如果 nums[i] < nums[i-1], 则下降沿数组更新（在 up[i-1]上加一），上升沿数组维持上一个不变。

## 377. combination-sum-4

这是一道完全背包问题，里面的数字可以使用很多次，而且计算可以组成 target 的序列，顺序是有区别的，比如{1,2,1}和{1,1,2}是两个答案，这个可以使用动态规划来进行计算。

如果使用递归来进行计算会耗时很严重，因为它只需要计算个数，所以我们使用动态规划来解决。

经典的完全背包形式：

```c++
    dp[0] = 1;

    for(long i=1;i<=target;i++){
        for(long num : nums){
            if(i >= num){
                dp[i] += dp[i-num];
            }
        }
    }
```

## 378. Kth Smallest Element in a Sorted Matrix

这道题让我们求有序矩阵中第 K 小的元素，这道题的难点在于数组并不是蛇形有序的，意思是当前行的最后一个元素并不一定会小于下一行的首元素，所以我们并不能直接定位第 K 小的元素，所以只能另辟蹊径。先来看一种利用堆的方法，我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数是否大于 k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求。

这题我们也可以用二分查找法来做，我们由于是有序矩阵，那么左上角的数字一定是最小的，而右下角的数字一定是最大的，所以这个是我们搜索的范围，然后我们算出中间数字 mid，由于矩阵中不同行之间的元素并不是严格有序的，所以我们要在每一行都查找一下 mid，我们使用 upper_bound，这个函数是查找第一个大于目标数的元素，如果目标数在比该行的尾元素大，则 upper_bound 返回该行元素的个数，如果目标数比该行首元素小，则 upper_bound 返回 0, 我们遍历完所有的行可以找出中间数是第几小的数，然后 k 比较，进行二分查找，left 和 right 最终会相等，并且会变成数组中第 k 小的数字。举个例子来说吧，比如数组为:

[1 2
12 100]
k = 3

那么刚开始 left = 1, right = 100, mid = 50, 遍历完 cnt = 3，此时 right 更新为 50
此时 left = 1, right = 50, mid = 25, 遍历完之后 cnt = 3, 此时 right 更新为 25
此时 left = 1, right = 25, mid = 13, 遍历完之后 cnt = 3, 此时 right 更新为 13
此时 left = 1, right = 13, mid = 7, 遍历完之后 cnt = 2, 此时 left 更新为 8
此时 left = 8, right = 13, mid = 10, 遍历完之后 cnt = 2, 此时 left 更新为 11
此时 left = 11, right = 12, mid = 11, 遍历完之后 cnt = 2, 此时 left 更新为 12
循环结束，left 和 right 均为 12，任意返回一个即可。

## 392. is subsequence

遍历母数组，设置子数组遍历 index，如果可以匹配上，那么 index++，如果子数组可以遍历完全，那么代表是子串。

## 400. 第 n 个数字

这道题目也是找规律的题目。

那么我们首先来分析自然数序列和其位数的关系，前九个数都是 1 位的，然后 10 到 99 总共 90 个数字都是两位的，100 到 999 这 900 个数都是三位的，那么这就很有规律了

规律就是先找到所寻找的数字所在的区间，比如在 10 ～ 99 之间。

然后找到这个区间最开始的数字，比如 10, 然后这个区间的每个数字的长度是 2,那么就(n-start)/len 就是我们所寻找的数字距离 start 的距离。移动到这个数字，确定这个数字的大小。

然后(n-start)%len 就是所寻找的数字里面第几个字母。就是最后的答案。

## 404. Sum of Left Leaves

这道题目是计算所有左叶子节点的总和，可以使用递归实现。

## 405. Convert a Number to Hexadecimal

对正数进行 16 进制转换，对负数以补码的形式进行 16 进制转换。

```c++
for(int i=0;num && i<8;i++){
    int item = num & 0x0f;
    if(item>=10){
        ans = map[item-10] + ans;
    }else{
        ans = to_string(item) + ans;
    }
    num = num >> 4;

}
```

使用位操作可以对正负数进行相同的操作。

## 406. queue reconstruction height

首先要确定好如何进行排序，要先安排个子高的同学，然后再去插入个子低的同学。所以排序方式就是先按照个子排序，对于个子相同的，按照第二个数字小的放在前面

## Arithmetic Slices

这道题目是求出数字序列可以拆分成为等差递增序列的个数。

设计一个 dp 数组，其含义是以 A[i]数字为结尾的等差序列的个数。其递推关系式是 dp[i] = dp[i-1] + 1

然后再遍历 dp 数组求和，就可以得到所有的个数了。

## 409. Longest Palindrome

这道题目是根据给定的字符串，判断可以组成的最长回文序列的长度。

注意这里可以使用 hashmap 进行统计每一个字符串的个数。对于偶数，肯定可以加入进去，但是对于奇数，其中的偶数部分也是可以加入进去的。然后如果存在奇数，那么最后还要加 1.

## 415. Add Strings

这道题目是字符串相加，和题目 67 很类似，套路是一样的。

## 416. Partition Equal Subset Sum

动态规划题目，题目要求是确定是否可以将一个序列划分为两个和相等的子序列。

本质上是求是否可以在一个序列中，寻求一个子集，使得和可以等于一个数字 target.

设计一个数组 dp, dp[i]代表是否可能组成 i. 当遍历到 nums[i]和目标 target = j 的时候，dp[j]是否是 true，取决于 dp[ j-nums[i] ]是否为 true, 同时，如果 dp[j] 已经等于 true，当然还要保持 true, 因此，递推关系式是： dp[j] = dp[j - nums[i] ] || dp[j]

这里需要特别注意的是，第二个 for 循环一定要从 target 遍历到 nums[i]，而不能反过来，想想为什么呢？因为如果从 nums[i] 遍历到 target 的话，假如 nums[i]=1 的话，那么 [1, target] 中所有的 dp 值都是 true，因为 dp[0] 是 true，dp[1] 会或上 dp[0]，为 true，dp[2] 会或上 dp[1]，为 true，依此类推，完全使的 dp 数组失效了。

## 417. pacific atlantic water flow

可以使用 BFS 或者 DFS 来进行遍历，遍历就是先从左上边缘进行，对于遍历到的点将 P 相应位置赋值为 TRUE，对于右下角的边缘进行遍历，遍历到的点 A 相应位置赋值为 TRUE，然后再从头遍历一变，如果 P 和 A 都是 true，那么就是均可以流入太平洋和大西洋的点。

## 435. non overlapping intervals

先对待排序的区间进行排序，然后比较两个区间的是否有重叠。根据每个区间的 start 来做升序排序，然后开始要查找重叠区间，判断方法是看如果前一个区间的 end 大于后一个区间的 start，那么一定是重复区间，此时结果 res 自增 1，我们需要删除一个，那么此时究竟该删哪一个呢，为了保证总体去掉的区间数最小，我们去掉那个 end 值较大的区间。具体并不是删掉，而是使用索引指针的形式。

## 437. path sum 3

这道题让我们求二叉树的路径的和等于一个给定值，说明了这条路径不必要从根节点开始，可以是中间的任意一段，而且二叉树的节点值也是有正有负。那么我们可以用递归来做，相当于先序遍历二叉树，对于每一个节点都有记录了一条从根节点到当前节点到路径，同时用一个变量 curSum 记录路径节点总和，然后我们看 curSum 和 sum 是否相等，相等的话结果 res 加 1，不等的话我们来继续查看子路径和有没有满足题意的，做法就是每次去掉一个节点，看路径和是否等于给定值，注意最后必须留一个节点，不能全去掉了，因为如果全去掉了，路径之和为 0，而如果给定值刚好为 0 的话就会有问题

## 445. Add Two Numbers II

这道题是之前那道 Add Two Numbers 的拓展，我们可以看到这道题的最高位在链表首位置，如果我们给链表翻转一下的话就跟之前的题目一样了，这里我们来看一些不修改链表顺序的方法。由于加法需要从最低位开始运算，而最低位在链表末尾，链表只能从前往后遍历，没法取到前面的元素，那怎么办呢？

我们可以利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字了，我们首先遍历两个链表，将所有数字分别压入两个栈 s1 和 s2 中。

然后遍历栈不为空，直到两个栈都为空，设计一个指针 pre，不断插入新的节点到 pre 指针后面。

## 451.sort character by frequency

hashmap 可以得到计数与元素的映射，然后可以使用桶排序或者堆排序来进行计算，看具体的题目要求来决定选择哪一种方法

## 452. minimum number of arrows to burst balloons

类似于计算重叠区间个数，注意在计算重叠区间的时候，要计算公共重叠区间来进行比较，这个区间是逐渐缩小的。

## 455. assign cookies

贪心算法，将两个数组首先进行排序，然后在逐个安排

## 461. Hamming Distanc

对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可

## 462. Minimum Moves to Equal Array Elements II

这道题是之前那道 Minimum Moves to Equal Array Elements 的拓展，现在我们可以每次对任意一个数字加 1 或者减 1，让我们用最少的次数让数组所有值相等。一般来说这种题目是不能用暴力方法算出所有情况，因为 OJ 一般是不会答应的。那么这道题是否像上面一道题一样，有巧妙的方法呢？答案是肯定的。下面这种解法实际上利用了之前一道题 Best Meeting Point 的思想，是不感觉很 amazing，看似完全不相干的两道题，居然有着某种内部联系。我们首先给数组排序，那么我们最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个数字；如果是偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数实际上就是两端数字的距离，讲到这里发现是不是就和这道题 Best Meeting Point 的思路是一样了。那么我们就两对两对的累加它们的差值就可以了

## 474. ones-and-zeros

这道题是一道典型的应用 DP 来解的题，如果我们看到这种求总数，而不是列出所有情况的题，十有八九都是用 DP 来解，重中之重就是在于找出递推式。如果你第一反应没有想到用 DP 来做，想得是用贪心算法来做，比如先给字符串数组排个序，让长度小的字符串在前面，然后遍历每个字符串，遇到 0 或者 1 就将对应的 m 和 n 的值减小，这种方法在有的时候是不对的，比如对于{"11", "01", "10"}，m=2，n=2 这个例子，我们将遍历完“11”的时候，把 1 用完了，那么对于后面两个字符串就没法处理了，而其实正确的答案是应该组成后面两个字符串才对。所以我们需要建立一个二维的 DP 数组，其中 dp[i][j]表示有 i 个 0 和 j 个 1 时能组成的最多字符串的个数，而对于当前遍历到的字符串，我们统计出其中 0 和 1 的个数为 zeros 和 ones，然后 dp[i - zeros][j - ones]表示当前的 i 和 j 减去 zeros 和 ones 之前能拼成字符串的个数，那么加上当前的 zeros 和 ones 就是当前 dp[i][j]可以达到的个数，我们跟其原有数值对比取较大值即可，所以递推式如下：

dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);

有了递推式，我们就可以很容易的写出代码

## 476. Number Complement

计算一个数字的反码，但是是部分反，不是全部反。

位操作，统计输入数字有效位的个数，然后得到对应个数的 1,将数组与这个对应个数的 1 构成的数字异或。因为与 1 异或相当于取反。

## 480. 滑动窗口中位数

使用滑动窗口和大小堆实现。

大小堆使用 multiset 实现起来比较方便，因为相比于 priority_queue, multiset 实现的大小堆可以访问中间的数字，而且可以查找中间的数字，而且可以遍历数字，因为其中的数字顺序都是有序的，所以大堆和小堆都是一样的数据结构就可以，只需要看你取最前面的还是最後面的，还可以使用 next(),以及 prev()函数移动指针。

求中位值，可以直接考虑使用大小堆。

这道题目关键是处理好删除数据，更关键是添加新数据的时候，如果维护好两个堆的大小关键，调整数字，使得小堆的 size 总是等于或仅大 1 大堆的数字。

## 485. Max Consecutive Ones

这道题目要计算连续 1 的个数。很简单，遍历即可。

## 494. target-sum

可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：

```
sum(P) - sum(N) = target

sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)

2 \* sum(P) = target + sum(nums)
```

因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。

这道题目本质上还是求一个序列里面子集等于 target，不过这里不是求是否存在，而是求有几个，和题目 416 很像。

主要就是 dp[i] = dp[i] + dp[ i-nums[j] ], 解释就是 dp[i]代表 target = i 的有几种组合法。

当前 dp[i]的个数，依赖于历史可以组成 dp[i]的个数，以及 dp[i-nums[j]]个数之和。

然后注意第二层遍历要倒序遍历。

## 501. Find Mode in Binary Search Tree

这道题让我们求二分搜索树中的众数，这里定义的二分搜索树中左根右结点之间的关系是小于等于的，有些题目中是严格小于的，所以一定要看清题目要求。所谓的众数就是出现最多次的数字，可以有多个，那么这道题比较直接点思路就是利用一个哈希表来记录数字和其出现次数之前的映射，然后维护一个变量 mx 来记录当前最多的次数值，这样在遍历完树之后，根据这个 mx 值就能把对应的元素找出来。那么用这种方法的话就不需要用到二分搜索树的性质了，随意一种遍历方式都可以。

题目中的 follow up 说了让我们不用除了递归中的隐含栈之外的额外空间，那么我们就不能用哈希表了，不过这也不难，由于是二分搜索树，那么我们中序遍历出来的结果就是有序的，这样我们只要比较前后两个元素是否相等，就等统计出现某个元素出现的次数，因为相同的元素肯定是都在一起的。我们需要一个结点变量 pre 来记录上一个遍历到的结点，然后 mx 还是记录最大的次数，cnt 来计数当前元素出现的个数，我们在中序遍历的时候，如果 pre 不为空，说明当前不是第一个结点，我们和之前一个结点值比较，如果相等，cnt 自增 1，如果不等，cnt 重置 1。如果此时 cnt 大于了 mx，那么我们清空结果 res，并把当前结点值加入结果 res，如果 cnt 等于 mx，那我们直接将当前结点值加入结果 res，然后 mx 赋值为 cnt。最后我们要把 pre 更新为当前结点

## 503. Next Greater Element II

这道题目和题目 739 很像，但是由于这里的数组是循环的，所以在遍历的时候需要循环遍历两次数组。

## 504. base-7

这道题目是将一个数字转化为 7 进制。

核心的递推公式是：

```c++
    while (item) {
        ans = to_string(item % 7) + ans;
        item = item / 7;
    }
```

注意负数的处理和 0 的处理。

## 513. Find Bottom Left Tree Value

二叉树的层次遍历。

## 518. coin-change-2

这道题目是计算可以凑出目标钱数目的所有硬币组合，这是一个完全背包问题，本质和题目 322 是一样的。

就是递推公式不一样,该题目的递推公式为：

```
    dp[i] = dp[i] + dp[i - coin];

```

需要注意的是，这是完全背包，需要正序遍历。

同时 dp[0] = 1

## 524. Longest Word in Dictionary through Deleting

这个类似于比较一个字符串是不是另一个字符串的子字符串。遍历字典中的字符串，如果当前遍历的字符串是 s 的子字符串，那么就赋值给 ans，然后继续遍历，如果当前遍历的字符串大小小于 ans 或者等于 ans 大小，但是字典排序在 ans 后面，那么就跳过，继续便利。

## 530. Minimum Absolute Difference in BST

计算 BST 两个节点的最小的差值，可以使用中序遍历实现，计算相邻节点的最小差值。

## 538. Convert BST to Greater Tree

这道题目可以使用中序遍历来实现，但是是反过来的中序遍历，这样逐渐从大到小遍历，这样就可以将比 n 大的所有数字都加起来。

## 540. single element in a sorted array

属于能够找到准确值的二分查找

## 543. Diameter of Binary Tree

这道题让我们求二叉树的直径，并告诉了我们直径就是两点之间的最远距离，根据题目中的例子也不难理解题意。我们再来仔细观察例子中的那两个最长路径[4,2,1,3] 和 [5,2,1,3]，我们转换一种角度来看，是不是其实就是根结点 1 的左右两个子树的深度之和呢。那么我们只要对每一个结点求出其左右子树深度之和，这个值作为一个候选值，然后再对左右子结点分别调用求直径对递归函数，这三个值相互比较，取最大的值更新结果 res，因为直径不一定会经过根结点，所以才要对左右子结点再分别算一次。为了减少重复计算，我们用哈希表建立每个结点和其深度之间的映射，这样某个结点的深度之前计算过了，就不用再次计算了

## 547. friend Circles

这道题目是查找联通区域的个数，可以使用 BFS 或者 DFS 来进行遍历，然后统计联通区域的个数即可。这道题目还有一种解法比较巧妙，就是 union find. 核心思想是设置一个数组 root,root 里面存储的是索引链接关系，开始给每一个对象的 root 索引都是自己，各个对象都是独立的，然后如果判断一个对象和另一个对象属于同一类，就把后者的 root 索引链接到前者。这样二者就变为了同一类，最后在总的类别数目上减一。

## [565] Array Nesting

这道题目是让我们计算嵌套数组的最大长度。可以找到的规律就是，如果是嵌套数组，那么一定是循环的，即首位链接嵌套的，那么我们就可以对于访问过的数字进行标记，对于每一个没有被访问过的数字，循环深入潜逃下去，直到发现回到了起点为止，计算他的长度。

## 566. Reshape the Matrix

这道题目是让我实现矩阵的 reshap 函数。我们就按照行进行依次遍历填入数据即可。

## 572. subtree-of-another-tree

这道题让我们求一个数是否是另一个树的子树，从题目中的第二个例子中可以看出，子树必须是从叶结点开始的，中间某个部分的不能算是子树，那么我们转换一下思路，是不是从 s 的某个结点开始，跟 t 的所有结构都一样，那么问题就转换成了判断两棵树是否相同，也就是 Same Tree 的问题了，这点想通了其实代码就很好写了，用递归来写十分的简洁，我们先从 s 的根结点开始，跟 t 比较，如果两棵树完全相同，那么返回 true，否则就分别对 s 的左子结点和右子结点调用递归再次来判断是否相同，只要有一个返回 true 了，就表示可以找得到

## 583. Delete Operation for Two Strings

这道题目是计算多少次删除，可以让两个字符串相等。

本质上这道题目是求最长公共子序列，和题目 1143 是一样的。

## 594. Longest Harmonious Subsequence

我们还可以用 HashMap 来做，先遍历一遍，建立每个数字跟其出现次数之间的映射，然后再遍历每个数字的时候，只需在 HashMap 中查找该数字加 1 是否存在，存在就更新结果 res，这样更简单一些

## 605. can place flowers

这里类似于确定连续 0 的个数 n，然后计算(n-1)/2 即为可以种花的个数，但是要注意，这个是假设两边均种花，如果是位于边界的花，需要单独进行处理。左边界的条件可以事先设置起始 count=1,右边界的话，因为最后遍历完成之后，如果右边界是连续的 0,那么右面连续的 0 还没有统计进去，再统计进去的可以使用 n/2

## 617. merge two binary Trees

这道题目是将两个树进行合并。可以使用递归的思路进行合并。

## 628. maximun-product-of-three-numbers

这道题博主刚开始看的时候，心想直接排序，然后最后三个数字相乘不就完了，心想不会这么 Easy 吧，果然被 OJ 无情打脸，没有考虑到负数和 0 的情况。这道题给了数组的范围，至少三个，那么如果是三个的话，就无所谓了，直接相乘返回即可，但是如果超过了 3 个，而且有负数存在的话，情况就可能不一样，我们来考虑几种情况，如果全是负数，三个负数相乘还是负数，为了让负数最大，那么其绝对值就该最小，而负数排序后绝对值小的都在末尾，所以是末尾三个数字相乘，这个跟全是正数的情况一样。那么重点在于前半段是负数，后半段是正数，那么最好的情况肯定是两个最小的负数相乘得到一个正数，然后跟一个最大的正数相乘，这样得到的肯定是最大的数，所以我们让前两个数相乘，再和数组的最后一个数字相乘，就可以得到这种情况下的最大的乘积。实际上我们并不用分情况讨论数组的正负，只要把这两种情况的乘积都算出来，比较二者取较大值，就能涵盖所有的情况，从而得到正确的结果，

## 633. sum of aqure numbers

这道题目和 two sum 2 很类似，都是在排序好的数组内寻找两个数字，只不过一个是和，一个是平方和，可以使用双指针来实现，但是要注意的是右指针的初始化可以直接初始化为 target 的根号值

## 637. Average of Levels in Binary Tree

二叉树的层次遍历。

## 645. Set Mismatch

这道题给了我们一个长度为 n 的数组，说里面的数字是从 1 到 n，但是有一个数字重复出现了一次，从而造成了另一个数字的缺失，让我们找出重复的数字和缺失的数字。那么最直接的一种解法就是统计每个数字出现的次数了，然后再遍历次数数组，如果某个数字出现了两次就是重复数，如果出现了 0 次，就是缺失数。

另外一种思想就是通过交换数组元素，使得数组上的元素在正确的位置上。然后再遍历一遍数组，如果某一个位置的数字不符合要求，就可以得到我们想要的答案。

## 647. Palindromic substrings

这道题目是计算一个字符串的所有可能的所有字串有多少回文字符串。

关键点就是我们要对于输入的字符串进行拆分，一个回文字符串是有中间线的，这个中间线在原字符串的位置就是 0, 0.5, 1, 1.5, ... 如果是偶数回文，那么中间线就是包含 0.5, 如果是奇数回文，那么中间线就是纯整数。我们遍历这些中间线，然后向两侧遍历，如果相等，ans 就加 1,如果不相等直接 break.

## 650. 2 Keys Keyboard

这道题目关键是找出规律，

递推公式是 dp[i] = min(dp[i], dp[j] + i / j)

其中 i 是准备求的目标数字，j 是 i 的所有可以整除的因子。

## 653. Two Sum IV - Input is a BST

这道题又是一道 2sum 的变种题，博主一直强调，平生不识 TwoSum，刷尽 LeetCode 也枉然！只要是两数之和的题，一定要记得先尝试用 HashSet 来做，这道题只不过是把数组变成了一棵二叉树而已，换汤不换药，我们遍历二叉树就行，然后用一个 HashSet，在递归函数函数中，如果 node 为空，返回 false。如果 k 减去当前结点值在 HashSet 中存在，直接返回 true；否则就将当前结点值加入 HashSet，然后对左右子结点分别调用递归函数并且或起来返回即可

## 665. non decreasing array

判断 i 是否小于 i-1，如果小于，那么就需要修改，但是具体要修改哪个呢，需要看情况而定，如果 i-2 不存在，那么直接修改 i-1,如果 i-2 小于 i，那么修改 i-1,如果 i-2 大于 i，那么修改 i

## 667. Beautiful Arrangement II

这道题目让我们输出一个数组，数组由 1 ～ n 组成，但是每个相邻数字的之间的绝对值要满足在 1 ～ k 之间。

这道题目我们可以寻找一个规律，就是对于 1 ～ 8 这个为例，那么假设 k=7，那么就可以这么找规律：

1 8 2 7 3 6 4 5

就是设计两个变量，left = 1 和 right = 1+k 他俩交替填入到数组里面去，然后直到 left 和 right 相遇，然后处理一个边界问题即可。

## 669. Trim a Binary Search Tree

这道题让我们修剪一棵二叉搜索树，给了个边界范围[L, R], 所有不在这个范围内的结点应该被移除掉，但是仍需要保留二叉搜索树的性质，即左<根<右，有时候是小于等于。博主最开始的想法是先遍历一遍二叉树，将在返回内的结点值都放到一个数组后，遍历结束后再根据数组重建一棵二叉搜索树。这种方法会在某些 test case 上 fail 掉，可能会改变原来的二叉搜索树的结构，所以我们只能换一种思路。正确方法其实应该是在遍历的过程中就修改二叉树，移除不合题意的结点。当然对于二叉树的题，十有八九都是要用递归来解的。首先判断如果 root 为空，那么直接返回空即可。然后就是要看根结点是否在范围内，如果根结点值小于 L，那么返回对其右子结点调用递归函数的值；如果根结点大于 R，那么返回对其左子结点调用递归函数的值。如果根结点在范围内，将其左子结点更新为对其左子结点调用递归函数的返回值，同样，将其右子结点更新为对其右子结点调用递归函数的返回值。最后返回 root 即可，

## 671. Second Minimum Node In a Binary Tree

这道题让我们找二叉树中的第二小的结点值，并且给该二叉树做了一些限制，比如对于任意一个结点，要么其没有子结点，要么就同时有两个子结点，而且父结点值是子结点值中较小的那个，当然两个子结点值可以相等。那么直接上暴力搜索呗，根据该树的附加条件可知，根结点一定是最小的结点值 first，那么我们只要找出第二小的值 second 即可，初始化为整型的最大值。然后对根结点调用递归函数，将 first 和 second 当作参数传进去即可。在递归函数中，如果当前结点为空，直接返回，若当前结点孩值不等于 first，说明其肯定比 first 要大，然后我们看其是否比 second 小，小的话就更新 second，然后对当前结点的左右子结点分别调用递归函数即可

## 677. Map Sum Pairs

这道题目和题目 208 很像，不同的地方在于，对于每一个节点，我们设置一个 sum 参数，一个 isWord 参数，新添加一个字符串的时候，经过的每一个节点的 sum 都增加 val 数值。

如果到达字符串末尾，如果 isword 大于 0,说明之前访问过，那么再次遍历一下，这次遍历的时候就每次减去 val，到达末尾的时候更新 val。

sum 方法的时候，直接进行遍历到末尾，然后直接返回最后一个节点的 sum.

## 680. validPalindrome 2

双指针，首先正常判断是不是回文字符串，在出现两个字符不一致的情况下，继续判断里面的字符串是不是会问字符串，注意有交叉两种情况

## 684. Redundant Connection

这道题给我们了一个无向图，让删掉组成环的最后一条边，其实这道题跟之前那道 Graph Valid Tree 基本没什么区别，三种解法都基本相同。博主觉得老题稍微变一下就是一道新题，而 onsite 遇到原题的概率很小，大多情况下都会稍稍变一下，所以举一反三的能力真的很重要，要完全吃透一道题也不太容易，需要多下功夫。首先来看递归的解法，这种解法的思路是，每加入一条边，就进行环检测，一旦发现了环，就返回当前边。对于无向图，还是用邻接表来保存，建立每个结点和其所有邻接点的映射，由于两个结点之间不算有环，所以要避免这种情况 1->{2}, 2->{1} 的死循环，用一个变量 pre 记录上一次递归的结点，比如上一次遍历的是结点 1，那么在遍历结点 2 的邻接表时，就不会再次进入结点 1 了，这样有效的避免了死循环，使其能返回正确的结果

这道题最好的解法使用 Union Find 来做，论坛上清一色的都是用这种解法来做的，像博主用 DFS 和 BFS 这么清新脱俗的方法还真不多:) 其实 Union Find 的核心思想并不是很难理解，首先建立一个长度为 (n+1) 的数组 root，由于这道题并没有明确的说明 n 是多少，只是说了输入的二位数组的长度不超过 1000，那么 n 绝对不会超过 2000，加 1 的原因是由于结点值是从 1 开始的，而数组是从 0 开始的，懒得转换了，就多加一位得了。将这个数组都初始化为 -1，有些人喜欢初始化为 i，都可以。开始表示每个结点都是一个单独的组，所谓的 Union Find 就是要让结点之间建立关联，比如若 root[1] = 2，就表示结点 1 和结点 2 是相连的，root[2] = 3 表示结点 2 和结点 3 是相连的，如果此时新加一条边 [1, 3] 的话，我们通过 root[1] 得到 2，再通过 root[2] 得到 3，说明结点 1 有另一条路径能到结点 3，这样就说明环是存在的；如果没有这条路径，那么要将结点 1 和结点 3 关联起来，让 root[1] = 3 即可，

## 687. Longest Univalue Path

这道题让我们求最长的相同值路径，跟之前那道 Count Univalue Subtrees 十分的类似，解法也很类似。对于这种树的路径问题，递归是不二之选。在递归函数中，我们首先对其左右子结点调用递归函数，得到其左右子树的最大相同值路径长度，下面就要来看当前结点和其左右子结点之间的关系了，如果其左子结点存在且和当前节点值相同，则 left 自增 1，否则 left 重置 0；同理，如果其右子结点存在且和当前节点值相同，则 right 自增 1，否则 right 重置 0。然后用 left+right 来更新结果 res。而调用当前节点值的函数只能返回 left 和 right 中的较大值，因为如果还要跟父节点组 path，就只能在左右子节点中选一条 path，当然选值大的那个了，什么意思呢，举个例子来说吧，比如下面的这棵二叉树：

```
      1
     / \
    4   5
   / \   \
  4   4   5
 /
4
```

若此时的 node 是只有两个结点的第二层的那个结点 4，那么分别对其左右子结点调用递归，会得到 left = 1, right = 0，因为此时要跟结点 4 组成 path，所以肯定挑左子结点（有两个 4 的那条边），那你会问为啥不能连上右子结点的那个 4，这整条长度为 3 的 path（left+right，此时的 left 和 right 已经分别自增 1 了，left=2，right=1）其实我们已经用来更新过结果 res 了。需要注意的是我们的递归函数 helper 返回值的意义，并不是经过某个结点的最长路径的长度，最长路径长度保存在了结果 res 中，不是返回值，返回的是以该结点为终点的最长路径长度，这样回溯的时候，我们还可以继续连上其父结点，比如若根结点也是 4 的话，那么回溯到根结点的时候，路径长度又可以增加了

## 693. Binary Number with Alternating Bits

直接位操作就可以了

## 695. max-area-of-island

这道题目类似于 1091 这道题目，不同之处在于这道题目仅有四个方向可以拓展。至于每一个子区域遍历一遍，可以使用 BFS 也可以使用 DFS。BFS 可以求出最短路径，而 DFS 对于求出可达性会更快一些。

## 696. Count Binary Substrings

这道题目是让我们判断有多少个子字符串包含相同的‘0’和‘1’，且‘0’和‘1’都聚集在一起。

我们可以遍历整个数组，当遇到数字变化的时候，就是判断的时候，用一个数字 pre 代表上一堆相同的数字个数，用 cur_num 代表当前的数字个数。二者的较小值也就是公共部分，添加到最终结果里面。然后交替 pre=cur_sum，直到遍历到最后结束。注意开头的细节即可。

## 697. Degree of an Array

这道题给了我们一个数组，定义数组的度为某个或某些数字出现最多的次数，要我们找最短的子数组使其和原数组拥有相同的度。那么我们肯定需要统计每个数字出现的次数，就要用哈希表来建立每个数字和其出现次数之间的映射。由于我们要求包含原度的最小长度的子数组，那么最好的情况就是子数组的首位数字都是统计度的数字，即出现最多的数字。那么我们肯定要知道该数字的第一次出现的位置和最后一次出现的位置，由于我们开始不知道哪些数字会出现最多次，所以我们统计所有数字的首尾出现位置，那么我们再用一个哈希表，建立每个数字和其首尾出现的位置。我们用变量 degree 来表示数组的度。好，现在我们遍历原数组，累加当前数字出现的次数，当某个数字是第一次出现，那么我们用当前位置的来更新该数字出现的首尾位置，否则只更新尾位置。每遍历一个数，我们都更新一下 degree。当遍历完成后，我们已经有了数组的度，还有每个数字首尾出现的位置，下面就来找出现次数为 degree 的数组，然后计算其首尾位置差加 1 就是 candidate 数组的长度，由于出现次数为 degree 的数字不一定只有一个，我们遍历所有的，找出其中最小的即可

## 714. Best Time to Buy and Sell Stock with Transaction Fee

这道题目和 309 带冷却期的股票交易很像，只是没有冷却期了，添加了每次的手续费。

还是设计两个数组 have[i]与 nothave[i].代表第 i 天手里有或没有股票的最大收益。

递推公式就是在每次卖出的时候加上手续费就可以了

```c++
have[i] = max(have[i-1], nothave[i-1] - prices[i]);
nothave[i] = max(nothave[i-1], have[i-1] + prices[i] - fee);
```

## 725. Split Linked List in Parts

这道题给我们一个链表和一个正数 k，让我们分割链表成 k 部分，尽可能的平均分割，如果结点不够了，就用空结点，比如例子 1 中的。如果无法平均分，那么多余的结点就按顺序放在子链表中，如例子 2 中所示。我们要知道每个部分结点的个数，才能将整个链表断开成子链表，所以我们首先要统计链表中结点的总个数，然后除以 k，得到的商 avg 就是能分成的部分个数，余数 ext 就是包含有多余的结点的子链表的个数。我们开始 for 循环，循环的结束条件是 i 小于 k 且 root 存在，要生成 k 个子链表，在循环中，先把头结点加入结果 res 中对应的位置，然后就要遍历该子链表的结点个数了，首先每个子链表都一定包含有 avg 个结点，这是之前除法得到的商，然后还要有没有多余结点，如果 i 小于 ext，就说明当前子链表还得有一个多余结点，然后我们将指针向后移动一个，

## 739. Daily Temperatures

这道题给了我们一个数组，让我们找下一个比当前数字大的数字的距离，我们研究一下题目中给的例子，发现数组是无序的，所以没法用二分法快速定位下一个大的数字，那么最先考虑的方法就是暴力搜索了，写起来没有什么难度，但是 OJ 并不答应。实际上这道题应该使用递增栈来做，栈如果输出的话，是逐步递增的，思路是这样的，我们遍历数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是递减栈了，所以我们取出栈顶元素，那么由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，那么我们直接求出下标差就是二者的距离了，然后继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来了。

## 744. find smallest letter greater than target

二分查找法

## 763. partition label

构建一个 hash 表，记录每一个字母最后出现的位置，然后再遍历一边字符串，定义一个变量表示当前出现的字符的最右边的边界，如果当前索引等于当前出现字符的最右边边界，那么就认为可以切割了

## 766. Toeplitz Matrix

这道题目是要进行矩阵的 index 的特殊遍历，关键是找到 index 的变化转折位置，处理好边界条件。

## 769. Max Chunks To Make Sorted

这道题目是让我们计算可以将一个数组分成几个部分，使得对每部分排序后数组就为有序。

找到规律就是遍历数组，寻找当前的最大值，如果当前已经遍历的数组最大值刚好等于他在排序后应该在的位置（也就是当前最大值等于下标 index）,那么就说明前面这部分的数组是可以单独独立出来进行排序的，以此类推即可。

## 785. Is Graph Bipartite?

这道题目让我们判断一个图是不是二分图。二分图就是整个图的节点可以分为两组，同组的节点不相互连接，也就是一条边的两个节点不能时同一种节点。

我们可以涂色法，遍历整个图的节点，可以使用 BFS，也可以使用递归方法。

如果这个节点被访问过了，那么判断这个节点的颜色即将被涂上的颜色是不是相等，如果相等，那么对了，如果和即将被涂上的颜色不相等，那么就不是二分图。

如果这个节点没有被访问过，那么就直接涂色。

---

这道题博主在最开始做的时候，看了半天，愣是没弄懂输出数据的意思，博主开始以为给的是边，后来发现跟图对应不上，就懵逼了，后来是通过研究论坛上大神们的解法，才总算搞懂了题目的意思，原来输入数组中的 graph[i]，表示顶点 i 所有相邻的顶点，比如对于例子 1 来说，顶点 0 和顶点 1，3 相连，顶点 1 和顶点 0，2 相连，顶点 2 和结点 1，3 相连，顶点 3 和顶点 0，2 相连。这道题让我们验证给定的图是否是二分图，所谓二分图，就是可以将图中的所有顶点分成两个不相交的集合，使得同一个集合的顶点不相连。为了验证是否有这样的两个不相交的集合存在，我们采用一种很机智的染色法，大体上的思路是要将相连的两个顶点染成不同的颜色，一旦在染的过程中发现有两连的两个顶点已经被染成相同的颜色，说明不是二分图。这里我们使用两种颜色，分别用 1 和 -1 来表示，初始时每个顶点用 0 表示未染色，然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数，如果返回 false，那么说明不是二分图，则直接返回 false。如果循环退出后没有返回 false，则返回 true。在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回 true，否则返回 false。如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点，调用递归函数，如果返回 false 了，则当前递归函数的返回 false，循环结束返回 true

我们再来看一种迭代的解法，整体思路还是一样的，还是遍历整个顶点，如果未被染色，则先染色为 1，然后使用 BFS 进行遍历，将当前顶点放入队列 queue 中，然后 while 循环 queue 不为空，取出队首元素，遍历其所有相邻的顶点，如果相邻顶点未被染色，则染成和当前顶点相反的颜色，然后把相邻顶点加入 queue 中，否则如果当前顶点和相邻顶点颜色相同，直接返回 false，循环退出后返回 true，

## 946. 验证栈序列

使用一个栈，和双指针。

如果压入队列等于弹出队列，那么直接 i++,j++;

如果压入队列和弹出队列不相等，那么分两种情况：

如果栈 s 不为空且头顶数字等于弹出队列，那么栈 s 弹出，且弹出队列加 1.
如果栈顶数字与弹出队列不相等，那么就栈 s 加入这个数字，且弹出队列加 1.

当遍历压入队列遍历完毕之后，如果栈 s 还有数字，那么就看看栈里面的数字和剩下的弹出队列是不是一样的。

## 992. K 个不同整数的子数组

滑动窗口。

这道题目也是使用滑动窗口可以进行解决。

核心思想就是窗口右边界开拓，遇到限制条件了之后，那么开始收缩左边界。

使用两个关键变量：ans 最后的计数个数，cnt 滑动窗口里面不同数字的个数。

而且使用一个 hashmap 或者固定数组来计数，确定好计数条件来表示什么时候是新数字，什么时候不是新数字，以此区分来影响对 cnt 的效果。

这道题目和题目 76 很像。

## 1091. shortest path in binary matrix

BFS。注意要对八个可能方向都要添加进队列，可能会访问回以前遍历过的地方，那么就如果是更短的路径，就要更新，如果不是更短的路径，就不要更新。

## 1143. longest-common-subsequence

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：

当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。
当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。
