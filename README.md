# leetcode

[TOC]

---

- [二分搜索法总结](./docs/binary_search.md)

- [动态规划总结](./docs/dp.md)

- [回溯法总结](./docs/backtracking.md)

- [位操作总结](./docs/bit.md)

- [剑指 offer 总结](./docs/jz-offer.md)

---

## 1. Two sum

使用 hash 表来记录已经存储的数据，新来的数据与 target 做差，判断是否在 hash 表中存在

## 3. 无重复字符的最长子串

这道题目可以使用 128 位的数组来表示所有字符。开始每个字符都初始化为-1

然后这道题目其实是维护一个滑动窗口。滑动窗口左边界是 left，右边界是当前访问的数组下标。

left 的更新策略是：

left = max(left, dp[s[i]]);

也就是如果一直没有被访问过重复字符，那么 left 一直维持在-1;窗口的长度就是当前下标减去 left.

然后如果出现了重复字符，那么 left 就立刻更新到之前出现的位置。

注意 dp[]数组也在不断更新，保存的是上一次出现的位置，用于如果出现了重复，可以把滑动窗口左边界拉过来。

## 4. 寻找两个有序数组的中位数

这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为 O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。但是这道题被定义为 Hard 也是有其原因的，难就难在要在两个未合并的有序数组之间使用二分法，如果这道题只有一个有序数组，让求中位数的话，估计就是个 Easy 题。对于这道题来说，可以将两个有序数组混合起来成为一个有序数组再做吗，图样图森破，这个时间复杂度限制的就是告诉你金坷垃别想啦。还是要用二分法，而且是在两个数组之间使用，感觉很高端啊。回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为 m 和 n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，使用一个小 trick，分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。若 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以 2，还是其本身。

好，这里需要定义一个函数来在两个有序数组中找到第 K 个元素，下面重点来看如何实现找到第 K 个元素。首先，为了避免拷贝产生新的数组从而增加时间复杂度，使用两个变量 i 和 j 分别来标记数组 nums1 和 nums2 的起始位置。然后来处理一些 corner cases，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果 K=1 的话，只要比较 nums1 和 nums2 的起始位置 i 和 j 上的数字就可以了。难点就在于一般的情况怎么处理？因为需要在两个有序数组中找到第 K 个元素，为了加快搜索的速度，可以使用二分法，那么对谁二分呢，数组么？其实要对 K 二分，意思是需要分别在 nums1 和 nums2 中查找第 K/2 个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以需要先 check 一下，数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个整型最大值（目的是要在 nums1 或者 nums2 中先淘汰 K/2 个较小的数字，判断的依据就是看 midVal1 和 midVal2 谁更小，但如果某个数组的个数都不到 K/2 个，自然无法淘汰，所以将其对应的 midVal 值设为整型最大值，以保证其不会被淘汰），若某个数组没有第 K/2 个数字，则淘汰另一个数组的前 K/2 个数字即可。举个例子来说吧，比如 nums1 = {3}，nums2 = {2, 4, 5, 6, 7}，K=4，要找两个数组混合中第 4 个数字，则分别在 nums1 和 nums2 中找第 2 个数字，而 nums1 中只有一个数字，不存在第二个数字，则 nums2 中的前 2 个数字可以直接跳过，为啥呢，因为要求的是整个混合数组的第 4 个数字，不管 nums1 中的那个数字是大是小，第 4 个数字绝不会出现在 nums2 的前两个数字中，所以可以直接跳过。

有没有可能两个数组都不存在第 K/2 个数字呢，这道题里是不可能的，因为 K 不是任意给的，而是给的 m+n 的中间值，所以必定至少会有一个数组是存在第 K/2 个数字的。最后就是二分法的核心啦，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，如果第一个数组的第 K/2 个数字小的话，那么说明要找的数字肯定不在 nums1 中的前 K/2 个数字，可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的 K 也自减去 K/2，调用递归，举个例子来说吧，比如 nums1 = {1, 3}，nums2 = {2, 4, 5}，K=4，要找两个数组混合中第 4 个数字，那么分别在 nums1 和 nums2 中找第 2 个数字，nums1 中的第 2 个数字是 3，nums2 中的第 2 个数字是 4，由于 3 小于 4，所以混合数组中第 4 个数字肯定在 nums2 中，可以将 nums1 的起始位置向后移动 K/2 个。反之，淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的 K 也自减去 K/2，调用递归即可，参见代码

---

另一种解释：

上边的两种思路，时间复杂度都达不到题目的要求 O(log(m+n)O(log(m+n)。看到 log，很明显，我们只有用到二分的方法才能达到。我们不妨用另一种思路，题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。

解法二中，我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k/2 个数。看下边一个例子。

假设我们要找第 7 小的数字。

我们比较两个数组的第 k/2 个数字，如果 k 是奇数，向下取整。也就是比较第 33 个数字，上边数组中的 44 和下边数组中的 33，如果哪个小，就表明该数组的前 k/2 个数字都不是第 k 小数字，所以可以排除。也就是 11，22，33 这三个数字不可能是第 77 小的数字，我们可以把它排除掉。将 13491349 和 4567891045678910 两个数组作为新的数组进行比较。

更一般的情况 `A[1] ，A[2] ，A[3]，A[k/2] ... ，B[1]，B[2]，B[3]，B[k/2]` ... ，如果 `A[k/2]<B[k/2]` ，那么 `A[1]，A[2]，A[3]，A[k/2]`都不可能是第 k 小的数字。

A 数组中比 A[k/2] 小的数有 k/2-1 个，B 数组中，B[k/2] 比 A[k/2] 小，假设 B[k/2] 前边的数字都比 A[k/2] 小，也只有 k/2-1 个，所以比 A[k/2] 小的数字最多有 k/1-1+k/2-1=k-2 个，所以 A[k/2] 最多是第 k-1 小的数。而比 A[k/2] 小的数更不可能是第 k 小的数了，所以可以把它们排除。

橙色的部分表示已经去掉的数字。

由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 = 4 小的数字就可以了，也就是 k = 4。此时两个数组，比较第 2 个数字，3 < 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。

我们又排除掉 2 个数字，所以现在找第 4 - 2 = 2 小的数字就可以了。此时比较两个数组中的第 k / 2 = 1 个数，4 == 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 > 4 吧，所以此时将下边的 4 去掉。

由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。

所以第 7 小的数字是 4。

我们每次都是取 k/2 的数进行比较，有时候可能会遇到数组长度小于 k/2 的时候。

此时 k / 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 < 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。

由于 2 个元素被排除，所以此时 k = 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。

从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。

所以我们采用递归的思路，为了防止数组长度小于 k/2，所以每次比较 min(k/2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k=1 或者其中一个数字长度是 0 了

参考链接：

https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/

## 5. Longest Palindromic Substring

正常方法要区分奇偶串，但是也可以首先便遍历中间重复的字符，将奇数偶数串统一处理

或者使用动态规划的方法，dp[i][j]表示这个 ij 区间内的是回文字符串，那么有递推公式：

```c++
dp[i][j] = true
{
if i==j
if j == i+1 && s[i]==s[j]
if dp[i+1][j-1]==true && s[i]==s[j]
}
```

## 6. zig-zag Conversion

o(n)time o(1)space 的算法是找到每一排循环的规律，是按照一定的周期循环的，或者可以使用 o(n)space ,不断的调整填充辅助数组的方向进行填充

## 7. reverse integer

这里要求时说如果 int 反转之后超如了有符号位 32 位大小的限制范围，那么就要返回 0，可以将结果先用 long 保存，然后在计算，并比较最后的结果是否超出了范围，并返回比较后的结果

## 8. 字符串转换整数 (atoi)

1. 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回 0.

2. 若第一个非空格字符是符号 +/-，则标记 sign 的真假，这道题还有个局限性，那就是在 c++ 里面，+-1 和-+1 都是认可的，都是 -1，而在此题里，则会返回 0.

3. 若下一个字符不是数字，则返回 0，完全不考虑小数点和自然数的情况，不过这样也好，起码省事了不少。

4. 如果下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。

5. 还需要考虑边界问题，如果超过了整型数的范围，则用边界值替代当前值。

判断是否超出了整数范围，可以这么判断：

```c
if(ans > INT_MAX / 10 || (ans == INT_MAX / 10 && str[right] > '7'))
```

## 9. Palindrome Number

这里如果是负数一定不是 Palindrome Number， 然后可以转化为字符串用双指针来做

还有一种方法就是，可以将数字进行反转，然后比较二者是否相等，或者可以比较一半，这种方法最快，就是将原本剩下砍掉的数字和新累乘的数字进行比较，知道新的数字大于剩下砍掉的数字，但是要注意边界条件，数字可以被 10 整除的是非常特殊的。

## 10. 正则表达式

这道求正则表达式匹配的题和那道 Wildcard Matching 的题很类似，不同点在于\*的意义不同，在之前那道题中，\*表示可以代替任意个数的字符，而这道题中的\*表示之前那个字符可以有 0 个，1 个或是多个，就是说，字符串 a\*b，可以表示 b 或是 aaab，即 a 的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归 Recursion 来解，大概思路如下：

- 若 p 为空，若 s 也为空，返回 true，反之返回 false。

- 若 p 的长度为 1，若 s 长度也为 1，且相同或是 p 为 '.' 则返回 true，反之返回 false。

- 若 p 的第二个字符不为\*，若此时 s 为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。

- 若 p 的第二个字符为\\\*，进行下列循环，条件是若 s 不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配 s 和去掉前两个字符的 p（这样做的原因是假设此时的星号的作用是让前面的字符出现 0 次，验证是否匹配），若匹配返回 true，否则 s 去掉首字母（因为此时首字母匹配了，我们可以去掉 s 的首字母，而 p 由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。

- 返回调用递归函数匹配 s 和去掉前两个字符的 p 的结果（这么做的原因是处理星号无法匹配的内容，比如 s="ab", p="a\*b"，直接进入 while 循环后，我们发现 "ab" 和 "b" 不匹配，所以 s 变成 "b"，那么此时跳出循环后，就到最后的 return 来比较 "b" 和 "b" 了，返回 true。再举个例子，比如 s="", p="a\*"，由于 s 为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）。

## 14. Longest Common Prefix

先排序，排好序找到最短的字符串的长度，然后遍历最短字符串长度，逐个比较排序后的第一个字符串和最后一个字符串

## 15. three-num

类似于 two num 题目的解法，但是不同的是要固定一个数字，然后找到另外两个数字，同时需要注意不要有重复的组合出现，解决方法是对于相同的数字，我们就将 index 跳过。

关键是如何排除相同的对象，尽量不要使用当前元素与 ans 里面的元素进行比较。

关键是要找到规律，如果发现元素相同（本质上就是相同等级的元素起得作用相同）的话，那么就跳过。

## 17. letter combination of a phone number

递归解法，类似于回溯的层级递归解法，整体的结构就是一个树形网络，在数行网络的最低端返回结果

补充：典型的回溯解法，就是设置 help 的参数一般包括&path，&paths,遇到层级底部，将 path 添加到 paths，然后函数返回并，将 path 最后一位去掉，这样就可以遍历所有情况。回溯和 DFS 很像，但是也有区别的地方，主要是以下几点：

Backtracking（回溯）属于 DFS。

- 普通 DFS 主要用在 可达性问题 ，这种问题只需要执行到特点的位置然后返回即可。
- 而 Backtracking 主要用于求解 排列组合 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

- 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
- 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。

## 18. 四数之和

这道题目是三数之和的拓展，本质上原理和三数之和是一样的，只不过是再多循环一层，然后就是按照同样的规律排除相同的元素，防止结果里面出现同样的元素。

## 19. Remove Nth Node From End of List

这道题目让去除链表里面倒数第 n 个元素。

可以开始让 head 不断前进，然后 count 计数。如果计数大于等于 n，另一个指针 item 开始前进，当 head 到达末尾的时候，item 就到达了目标位置。需要注意的是细节的处理，使用 pre 指针很方便。

## 20. Valid Parentheses

判断括号的完整性质，使用堆栈实现即可。

## 21. Merge Two Sorted Lists

这道题目是将两个已经排序的链表进行融合，注意的一点就是设置一个 pre 指针，然后不断的添加就可以。

## 22 括号生成

在 LeetCode 中有关括号的题共有七道，除了这一道的另外六道是 Score of Parentheses，Valid Parenthesis String， Remove Invalid Parentheses，Different Ways to Add Parentheses，Valid Parentheses 和 Longest Valid Parentheses。这道题给定一个数字 n，让生成共有 n 个括号的所有正确的形式，对于这种列出所有结果的题首先还是考虑用递归 Recursion 来解，由于字符串只有左括号和右括号两种字符，而且最终结果必定是左括号 3 个，右括号 3 个，所以这里定义两个变量 left 和 right 分别表示剩余左右括号的个数，如果在某次递归时，左括号的个数大于右括号的个数，说明此时生成的字符串中右括号的个数大于左括号的个数，即会出现 ')(' 这样的非法串，所以这种情况直接返回，不继续处理。如果 left 和 right 都为 0，则说明此时生成的字符串已有 3 个左括号和 3 个右括号，且字符串合法，则存入结果中后返回。如果以上两种情况都不满足，若此时 left 大于 0，则调用递归函数，注意参数的更新，若 right 大于 0，则调用递归函数，同样要更新参数，

## 23 合并 K 个排序链表

在基于合并两个有序链表的基础上，使用归并排序的思想实现。

## 24. Swap Nodes in Pairs

这道题目是按照次序交换相邻的两个节点。注意处理好 next 的关系和循环停止条件。

## 33. 搜索旋转排序数组

结合了题目 153 和二分查找来解决。

## 34. find first ans last position of element in sorted array

二分查找，可以使用两次二分，也可以使用一次二分之后，将 target 加 1,继续进行二分。本质是一道二分查找第一个大于等于 target 的位置的题目。

## 39. combination

组合求和。这道题目要求根据提供的数字来组合出来和为 target 的数字组合，每个数字可以使用多次，但是最终的结果不能重复。

还是经典的组合问题，用回溯法进行解决。设计的关键有两点，一点是如何判断添加到 paths 的条件，这里就是 path 各个元素的和等于 target。另一个就是如何添加新的元素到 path，这里就是如果新的元素大于等于 path 的末尾元素，那么就可以添加进去，目的是确保没有重复的组合出现，因为 2，2, 3 和 2, 3, 2 是同一种组合。

## 40. combination-sum-2

组合求和 2. 这道题目还是根据提供的数字组合出来和为 target 的数字组合，但是备选数字有重复，而且每个位置的数字只能使用一次，最终结果也不能重复。

由于是组合，那么 2,2,3 和 2,3,2 是一个组合。

因此，还是经典的组合问题，使用回溯方法进行解决。需要注意的是，这里由于结果必须是不同的组合，因此最好先对数组进行排序，然后新添加的数字必须大于等于 path 最后一个数字。

又由于备选数字有重复，因此每次添加新数字的时候，如果前一个数字没有访问标记，并且当前数字等于前一个数字，那么说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此跳过。同时如果当前数字已经被访问过，那么也不能重复访问，也直接跳过。

## 41. 缺失的第一个正数

将数组视为哈希表
由于题目要求我们“只能使用常数级别的空间”，而要找的数一定在 [1, N + 1] 左闭右闭（这里 N 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组；
我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1；
那么，我们可以采取这样的思路：就把 11 这个数放到下标为 00 的位置， 22 这个数放到下标为 11 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 11 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。
这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。

## 42. 接雨水

只需要遍历一次即可的解法，这个算法需要 left 和 right 两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是 left 指向的值，则从左向右扫描，如果较小值是 right 指向的值，则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至 left 和 right 指针重合，

另外一个比较简单的解法。思路就是 1. 扫描一遍，找到最高的柱子，这个柱子将数组分为两半; 2. 处理左边一半; 3. 处理右边一半。

## 46. permutation

这道题目是排列组合所有可能的数字组合，但是数字只能使用一次，且数字之间都是互不相同的。这是典型的组合问题，可以使用回溯方法进行解决。注意每次插入新的数字的时候，要插入和 path 里面已有的数字的不同的数字

## 47. permutations-2

这道题目是排列组合题目的一个变形，不同之处在于数字之间可能有重复，每个位置的数字可以使用一次。生成的最后结果不能相互有重复。

注意每次添加新的数字的时候，前一个数字如果没有访问标记（visit）,并且当前数字等于前一个数字，说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此直接跳过。同时，如果当前数字已经被标记（visit）,那么不重复访问，也直接跳过。

## 51. N 皇后

经典的 N 皇后问题，基本所有的算法书中都会包含的问题。可能有些人对国际象棋不太熟悉，大家都知道中国象棋中最叼的是车，横竖都能走，但是在国际象棋中还有更叼的，就是皇后，不但能横竖走，还能走两个斜线，有如 bug 一般的存在。所以经典的八皇后问题就应运而生了，在一个 8x8 大小的棋盘上如果才能放 8 个皇后，使得两两之间不能相遇，所谓一山不能容二虎，而这里有八个母老虎，互相都不能相遇。对于这类问题，没有太简便的方法，只能使用穷举法，就是尝试所有的组合，每放置一个新的皇后的时候，必须要保证跟之前的所有皇后不能冲突，若发生了冲突，说明当前位置不能放，要重新找地方，这个逻辑非常适合用递归来做。我们先建立一个长度为 nxn 的全是点的数组 queens，然后从第 0 行开始调用递归。在递归函数中，我们首先判断当前行数是否已经为 n，是的话，说明所有的皇后都已经成功放置好了，所以我们只要将 queens 数组加入结果 res 中即可。否则的话，我们遍历该行的所有列的位置，行跟列的位置都确定后，我们要验证当前位置是否会产生冲突，那么就需要使用一个子函数来判断了，首先验证该列是否有冲突，就遍历之前的所有行，若某一行相同列也有皇后，则冲突返回 false；再验证两个对角线是否冲突，就是一些坐标转换，主要不要写错了，若都没有冲突，则说明该位置可以放皇后，放了新皇后之后，再对下一行调用递归即可，注意递归结束之后要返回状态

## 52. N 皇后 2

和 51 一样，仅仅修改 res，从记录数组变为统计计数就可以。

## 53. maximum subarray

有两种方法，一种是迭代的方法，就是分而治之。那么最大值就是左侧数组的最大值，右侧数组的最大值，以及从中间值向两边进行遍历，记录遍历过程中经过的最大值。那么最大值就是这三个最大值中的较大那个。

另一种方法是比较巧妙，设置两个变量，分别是总的最大值，一个是当前遍历的临时最大值。然后用临时最大值加上当前遍历的数值，如果和小于当前数值，那么说明前面的累计是负面效应的，还不如只用当前遍历的数字，那么就更新临时最大值为当前便利的数值。如果和大于当前数值，那么说明前面的累计是有正面作用的，将临时最大值更新为新的和。同时，在每次更新临时最大值的时候都更新总的最大值，用 max 函数，记录这些更新历史过程中的总的最大值，即为最后结果。

还可以使用动态规划。dp[i]表示以 nums[i]为结尾的子数组的最大值。

## 54 螺旋矩阵

按照框进行遍历。

## 56. 合并区间

判断前一个区间的尾巴和下一区间的脑袋是不是重叠，如果重叠就把下一个区间融合进去。

设置一个变量 left 表示接受改变的区间，right 变量表示不断候选准备融合进去的区间。

如果不重合，那么 left = right, right = left + 1

## 57. 插入区间

本质上和合并区间一样，先插入进去一段区间，然后排序，再然后合并区间。

## 62. unique-paths

典型的动态规划问题，要求是要寻找矩阵从左上角到右下角的所有可能的情况，那么某一点的情况是他左侧点的情况和上面点的情况的加和。注意最上边和最左边都是 1,然后遍历填满 dp 矩阵即可。

## 64. minimum-path-sum

典型的动态规划问题，由于是二维矩阵，建立一个二维 dp 数组比较合适。

递推关系式是到达 grid[i][j]的最短距离，取决于达到该点左侧和上侧最短距离之间的最小值，在加上该点的距离，然后 for 循环遍历一遍，填满 dp 数组就可以了。

## 65. 有效数字

这道题目很繁琐，要根据特殊情况一个一个补充。

关键：

1. 开始去除左右两侧的空格。
2. 设置几个标志位：数字，符号，自然底数，小数点，数字是否在自然底数后面，然后分门别类按照各自的类型处理
3. 对于第一个字符单独处理
4. 对于没有数字的字符串肯定不是，这个要单独判断一下

## 67. add-binary

实现二进制加法。

首先将 a 确保为较长的字符串（使用 swap 交换）,然后设计一个 up 参数，如果两个数相加等于 0, 等于 1，等于 2,等于 3,分别进行不同的处理。

最后注意，如果 up 最后还是等于 1,那么就在前面还要加一个 1.

## 69. sqrt-x

可以使用数学解法进行球见，就是找到等式，转化为牛顿法，牛顿法的递推公式就是 Xn+1 = Xn - fx / fx'。 还有一种通用的解法，就是使用二分法

## 70. 爬梯子

典型的动态规划题目，递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。`dp[i] = dp[i-1]+dp[i-2];`

## 72. edit-distance

这道题目是使用三种手段来将两个字符串变成一致，分别时删除，增加，修改。

使用 dp[i][j]用来表示字符串 1 的 0~i-1、字符串 2 的 0~j-1 的最小编辑距离；
我们可以知道边界情况：dp[i][0] = i、dp[0][j]=j；
同时对于两个字符串的子串，都能分为最后一个字符相等或者不等的情况：
如果 words[i-1] == words[j-1]：dp[i][j] = dp[i-1][j-1]；也就是说当前的编辑距离和位置 i 和 j 的字符无关；
如果 words[i-1] != words[j-1]：则存在三种可能的操作：

```
向 word1 插入：dp[i][j] = dp[i][j-1] + 1;
从 word1 删除：dp[i][j] = dp[i-1][j] + 1;
替换 word1 元素：dp[i][j] = dp[i-1][j-1] + 1;
```

## 75. sort colors

荷兰国旗问题，可以设置三个索引指针来进行解决，分别是左侧，当前，右侧

## 76. 最小覆盖子串

这道题给了我们一个原字符串 S，还有一个目标字符串 T，让在 S 中找到一个最短的子串，使得其包含了 T 中的所有的字母，并且限制了时间复杂度为 O(n)。这道题的要求是要在 O(n) 的时间度里实现找到这个最小窗口字串，暴力搜索 Brute Force 肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么来想一下，时间复杂度卡的这么严，说明必须在一次遍历中完成任务，当然遍历若干次也是 O(n)，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然要包含 T 中所有的字母，那么对于 T 中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了 O(n)，肯定不想在这里还浪费时间，就用空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐 T.T），使用 HashMap，建立 T 中每个字母与其出现次数之间的映射，那么你可能会有疑问，为啥不用 HashSet 呢，别急，讲到后面你就知道用 HashMap 有多妙，简直妙不可言～

目前在脑子一片浆糊的情况下，我们还是从简单的例子来分析吧，题目例子中的 S 有点长，换个短的 S = "ADBANC"，T = "ABC"，那么肉眼遍历一遍 S 呗，首先第一个是 A，嗯很好，T 中有，第二个是 D，T 中没有，不理它，第三个是 B，嗯很好，T 中有，第四个又是 A，多了一个，礼多人不怪嘛，收下啦，第五个是 N，一边凉快去，第六个终于是 C 了，那么貌似好像需要整个 S 串，其实不然，注意之前有多一个 A，就算去掉第一个 A，也没事，因为第四个 A 可以代替之，第二个 D 也可以去掉，因为不在 T 串中，第三个 B 就不能再去掉了，不然就没有 B 了。所以最终的答案就"BANC"了。通过上面的描述，你有没有发现一个有趣的现象，先扩展，再收缩，就好像一个窗口一样，先扩大右边界，然后再收缩左边界，上面的例子中右边界无法扩大了后才开始收缩左边界，实际上对于复杂的例子，有可能是扩大右边界，然后缩小一下左边界，然后再扩大右边界等等。这就很像一个不停滑动的窗口了，这就是大名鼎鼎的滑动窗口 Sliding Window 了，简直是神器啊，能解很多子串，子数组，子序列等等的问题，是必须要熟练掌握的啊！

下面来考虑用代码来实现，先来回答一下前面埋下的伏笔，为啥要用 HashMap，而不是 HashSet，现在应该很显而易见了吧，因为要统计 T 串中字母的个数，而不是仅仅看某个字母是否在 T 串中出现。统计好 T 串中字母的个数了之后，开始遍历 S 串，对于 S 中的每个遍历到的字母，都在 HashMap 中的映射值减 1，如果减 1 后的映射值仍大于等于 0，说明当前遍历到的字母是 T 串中的字母，使用一个计数器 cnt，使其自增 1。当 cnt 和 T 串字母个数相等时，说明此时的窗口已经包含了 T 串中的所有字母，此时更新一个 minLen 和结果 res，这里的 minLen 是一个全局变量，用来记录出现过的包含 T 串所有字母的最短的子串的长度，结果 res 就是这个最短的子串。然后开始收缩左边界，由于遍历的时候，对映射值减了 1，所以此时去除字母的时候，就要把减去的 1 加回来，此时如果加 1 后的值大于 0 了，说明此时少了一个 T 中的字母，那么 cnt 值就要减 1 了，然后移动左边界 left。你可能会疑问，对于不在 T 串中的字母的映射值也这么加呀减呀的，真的大丈夫（带胶布）吗？其实没啥事，因为对于不在 T 串中的字母，减 1 后，变-1，cnt 不会增加，之后收缩左边界的时候，映射值加 1 后为 0，cnt 也不会减少，所以并没有什么影响啦，下面是具体的步骤啦：

- 先扫描一遍 T，把对应的字符及其出现的次数存到 HashMap 中。

- 然后开始遍历 S，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减 1 后仍大于等于 0，cnt 自增 1。

- 如果 cnt 等于 T 串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是 T 串中不可缺少的字母，那么 cnt 自减 1，表示此时 T 串并没有完全匹配。

更优化的方法：

这道题也可以不用 HashMap，直接用个 int 的数组来代替，因为 ASCII 只有 256 个字符，所以用个大小为 256 的 int 数组即可代替 HashMap，但由于一般输入字母串的字符只有 128 个，所以也可以只用 128，其余部分的思路完全相同，虽然只改了一个数据结构，但是运行速度提高了一倍，说明数组还是比 HashMap 快啊。在热心网友 chAngelts 的提醒下，还可以进一步的优化，没有必要每次都计算子串，只要有了起始位置和长度，就能唯一的确定一个子串。这里使用一个全局变量 minLeft 来记录最终结果子串的起始位置，初始化为 -1，最终配合上 minLen，就可以得到最终结果了。注意在返回的时候要检测一下若 minLeft 仍为初始值 -1，需返回空串

## 77. conbination

这道题目属于比较经典的组合问题，只不过这道题目的组合的长度是自定义可以变化的，仅仅需要修改添加到 paths 的条件即可。

## 78. subsets

递归，回溯法。要设置的变量 paths , path， index, nums(输入变量)

处理一组给定元素的排列和组合。 Subsets 模式描述了一种有效的广度优先搜索（BFS）方法来处理所有这些问题。
例如给定一个数组 `[1, 5, 3]`

另外一种方法:
首先初始化一个空数组： [[ ]]
将第一个数字(1)添加到所有现有子集，以创建新的子集: `[[], [1]]`
继续添加`[[], [1], [5], [1, 5]] [[], [1], [5], [1, 5], [3], [1, 3], [5, 3], [1, 5, 3]]`

## 79. word search

这道是一个典型的回溯的题目，回溯是 DFS 的一种，但是有一个区别就是回溯在每次调用函数进行递归结束之后要把标记删除掉，这样下次其他递归还可以使用相应的对象。普通 DFS 是找一个可达性，而回溯包括一些匹配与排列组合的概念在里面，因此一个排列组合不对，要把标记清楚，可能其他排列组合就用上了。

还有要注意的一点就是，对于结果是 bool 类型，要把 bool 结果作为函数进行返回，多个返回之间进行取或，因为或操作如果有一个是 true 就整体是 true，后面的就不需要判断了，因此这样能加快函数进行，如果放在&参数里面进行返回，那么每一种情况都会进行，会白跑一些情况。

## 83. Remove Duplicates from Sorted List

这道题目是去除有序链表里面的重复数组，关键的步骤就是如果判断 head->val == head->next->val 那么就 head->next = head->next->next;

## 84. Largest Rectangle in Histogram 直方图中最大的矩形

后来又在网上发现一种比较流行的解法，是利用栈来解，可参见网友实验室小纸贴校外版的博客，但是经过仔细研究，其核心思想跟上面那种剪枝的方法有异曲同工之妙，这里维护一个栈，用来保存递增序列，相当于上面那种方法的找局部峰值。我们可以看到，直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高。有点像木桶原理一样，总是最低的那块板子决定桶的装水量。那么既然需要用单调栈来做，首先要考虑到底用递增栈，还是用递减栈来做。我们想啊，递增栈是维护递增的顺序，当遇到小于栈顶元素的数就开始处理，而递减栈正好相反，维护递减的顺序，当遇到大于栈顶元素的数开始处理。那么根据这道题的特点，我们需要按从高板子到低板子的顺序处理，先处理最高的板子，宽度为 1，然后再处理旁边矮一些的板子，此时长度为 2，因为之前的高板子可组成矮板子的矩形 ，因此我们需要一个递增栈，当遇到大的数字直接进栈，而当遇到小于栈顶元素的数字时，就要取出栈顶元素进行处理了，那取出的顺序就是从高板子到矮板子了，于是乎遇到的较小的数字只是一个触发，表示现在需要开始计算矩形面积了，为了使得最后一块板子也被处理，这里用了个小 trick，在高度数组最后面加上一个 0，这样原先的最后一个板子也可以被处理了。由于栈顶元素是矩形的高度，那么关键就是求出来宽度，那么跟之前那道 Trapping Rain Water 一样，单调栈中不能放高度，而是需要放坐标。由于我们先取出栈中最高的板子，那么就可以先算出长度为 1 的矩形面积了，然后再取下一个板子，此时根据矮板子的高度算长度为 2 的矩形面积，以此类推，知道数字大于栈顶元素为止，再次进栈，巧妙的一比！关于单调栈问题可以参见博主的一篇总结帖 LeetCode Monotonous Stack Summary 单调栈小结，

## 85. Maximal Rectangle

使用类似于 84 的解法，将原来的矩阵从上到下，具有连续 1 的累加起来，不连续的变为 0，这样没一个新产生的行使用 84 的解法计算，找到最大值。

## 87. scramble-string

可以使用递归或者动态规划的解法。（1）递归解法就是遍历不同的切割方法，但是每种情况不仅要左右对称比较，还要左右交叉比较。需要注意的是，要预先比较两个字符串字符是不是字母都一样，如果不一样肯定返回 false，这样可以加快速度，否则递归会超时。（2）DP 解法是设计三维的 dp 矩阵，三个维度分别是左串起始，右串起始，长度。递推方案是先解决所有长度为 1 的情况，遍历即可。然后对于长度高一层级的情况，都有低一层级的所有子情况推出来，具体递推公式就是左右对称比较和交叉比较，然后逐渐升高长度大小，最终得到最终结果。

动态规划的过程可以看作就情况的逆过程，递推是从最高维度向下分解，但是分解的子情况可能有很多是重复的，这时候会增加计算量，动态情况是找到里面的构建规律，然后逐渐推倒到我们想要的结果，是从最简单情况到复杂情况的过程，而递推是复杂情况渐分解到最简单情况的过程。

## 88. merge-sorted-array

双指针。从尾部开始遍历，逐渐把较大的数字往后放。注意结束的条件是两种：2 数组先到头，那么直接结束，因为 1 数组前面的数字还在原来的位置上。另一种情况是 1 数组先到头，那么就不用比较了，直接将剩下的 2 数组内容依次填好。

## 89. 格雷编码

参考维基百科上关于格雷码的性质，有一条是说镜面排列的，n 位元的格雷码可以从 n-1 位元的格雷码以上下镜射后加上新位元的方式快速的得到

## 90. subsets 2

求子集，这道题目是根据备选的数字，找到所有可能组合的子集。注意备选的数字可能有重复。

这里由于备选的数字有重复，因此对于前一个数字没有访问标记，但是当前数字和前一个数字相同的，说明处于同一个位置，那么直接跳过。

由于组合不能有重复，因此新的数字要大于等于 path 的末尾数字，同时对于当前已经正在访问的数组，直接跳过。

## 91. Decode Ways

动态规划解法，使用一个数组 dp 表示记录的数据，列写出动态规划的递推方程，dp[i]=dp[i-1]+dp[i-2],不过这里的递推公式因为边界条件不一样而有所不同。

## 92. 反转链表 II

和反转链表 1 的迭代解法很像，还是设置一个头节点。

但是，要注意的是计数变量的不同情况下的处理方式。

## 93. restore ip addresses

使用回溯法进行解决，但是要主要判断几个条件不能当作 ip 地址中间的段，分别是：要在 0 ～ 255 之间，不能有 010,001 这样的情况，段的大小要和 i 相等，否则可能在最终结果中加入了相同的东西。

还可以暴力一点，四个 for 循环便利所有可能情况，并对总数目等于 s 大小的去进一步判断，判断每一个段是不是符合那几个条件，如果符合就是最终结果。

## 94. Binary Tree Inorder Traversal

可以使用递归的方法，也可以使用非递归的方法。

下面再来看非递归使用栈的解法，也是符合本题要求使用的解法之一，需要用栈来做，思路是从根节点开始，先将根节点压入栈，然后再将其所有左子结点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中。这样就保证了访问顺序为左-根-右，

## 95. unique binary search trees 2

分而治之思想，这里也可以使用记忆 hash 表或者记忆数组进行记录，本质上，使用记忆数组的递归是动态规划的一种。

## 101. symmetric-tree

使用递归的思想可以判断，判断右子树的左子树是不是相等，判断左子树的右子树是不是相等。

## 102. 二叉树的层次遍历

数的层次遍历

## 103. 二叉树的锯齿形层次遍历

二叉树层次遍历 + 反转数组

## 104. Maximum Depth of Binary Tree

计算树的高度，使用递归的思想可以完成。

## 106. 从中序与后序遍历序列构造二叉树

递归实现，主要使用多个变量分割字符串的区间。

## 108. Convert Sorted Array to Binary Search Tree

将一个有序数组转化为一个 BST,使用递归实现，逐步将最中间的数字作为根节点。

## 109. Convert Sorted List to Binary Search Tree

对于寻找一个链表的中点的问题，可以使用快慢指针实现。

## 110. Balanced Binary Tree

这道题目是判断是不是平衡二叉树，首先需要判断二叉树的高度，然后使用递归的思想判断是不是 BST,如果一个树是 BST，那么他的两个子树都是 BST，且两个子树的高度相差不超过 1。

## 111. Minimum Depth of Binary Tree

这道题目是计算根节点到叶子节点的最短路径，可以使用递归实现。

## 112. path sum

这道题目也可以使用递归进行判断，然后注意边界条件就可以。

## 121. Best Time to Buy and Sell Stock

设置两个变量一个是最大利润，一个是到当前之间为止，前面的最小买入价格，然后遍历，再每次遍历的时候，计算当前卖出价格和前面最小买入价格的差价

## 122. Best Time to Buy and Sell Stock 2

使用贪心的思想，只要后一天比前一天价格高，就会有利润，因此可以计算后一天比前一天收益大于 0 并累积

## 123. Best Time to Buy and Sell Stock III

这道是买股票的最佳时间系列问题中最难最复杂的一道，前面两道 Best Time to Buy and Sell Stock 和 Best Time to Buy and Sell Stock II 的思路都非常的简洁明了，算法也很简单。而这道是要求最多交易两次，找到最大利润，还是需要用动态规划 Dynamic Programming 来解，而这里我们需要两个递推公式来分别更新两个变量 local 和 global，参见网友 Code Ganker 的博客，我们其实可以求至少 k 次交易的最大利润，找到通解后可以设定 k = 2，即为本题的解答。我们定义 local[i][j]为在到达第 i 天时最多可进行 j 次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义 global[i][j]为在到达第 i 天时最多可进行 j 次交易的最大利润，此为全局最优。它们的递推式为：

local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)

global[i][j] = max(local[i][j], global[i - 1][j])

其中局部最优值是比较前一天并少交易一次的全局最优加上大于 0 的差值，和前一天的局部最优加上差值中取较大值，而全局最优比较局部最优和前一天的全局最优

---

这道题是 Best Time to Buy and Sell Stock 的扩展，现在我们最多可以进行两次交易。我们仍然使用动态规划来完成，事实上可以解决非常通用的情况，也就是最多进行 k 次交易的情况。
这里我们先解释最多可以进行 k 次交易的算法，然后最多进行两次我们只需要把 k 取成 2 即可。我们还是使用“局部最优和全局最优解法”。我们维护两种量，一个是当前到达第 i 天可以最多进行 j 次交易，最好的利润是多少（global[i][j]），另一个是当前到达第 i 天，最多可进行 j 次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j]）。下面我们来看递推式，全局的比较简单，

global[i][j]=max(local[i][j],global[i-1][j])，

也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。对于局部变量的维护，递推式是

local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)，

也就是看两个量，第一个是全局到 i-1 天进行 j-1 次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要 j-1 次交易，最后一次交易取当前天），第二个量则是取 local 第 i-1 天 j 次交易，然后加上今天的差值（这里因为 local[i-1][j]比如包含第 i-1 天卖出的交易，所以现在变成第 i 天卖出，并不会增加交易次数，而且这里无论 diff 是不是大于 0 都一定要加上，因为否则就不满足
local[i][j]必须在最后一天卖出的条件了）。
上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是 O(n\*k)，如果是最多进行两次交易，那么复杂度还是 O(n)。空间上只需要维护当天数据皆可以，所以是 O(k)，当 k=2，则是 O(1)。代码如下：

## 124. 二叉树中的最大路径和

树的递归解法一般都是递归到叶节点，然后开始边处理边回溯到根节点。这里就假设此时已经递归到结点 7 了，其没有左右子节点，如果以结点 7 为根结点的子树最大路径和就是 7。然后回溯到结点 11，如果以结点 11 为根结点的子树，最大路径和为 7+11+2=20。但是当回溯到结点 4 的时候，对于结点 11 来说，就不能同时取两条路径了，只能取左路径，或者是右路径，所以当根结点是 4 的时候，那么结点 11 只能取其左子结点 7，因为 7 大于 2。所以，对于每个结点来说，要知道经过其左子结点的 path 之和大还是经过右子节点的 path 之和大。递归函数返回值就可以定义为以当前结点为根结点，到叶节点的最大路径之和，然后全局路径最大值放在参数中，用结果 res 来表示。

在递归函数中，如果当前结点不存在，直接返回 0。否则就分别对其左右子节点调用递归函数，由于路径和有可能为负数，这里当然不希望加上负的路径和，所以和 0 相比，取较大的那个，就是要么不加，加就要加正数。然后来更新全局最大值结果 res，就是以左子结点为终点的最大 path 之和加上以右子结点为终点的最大 path 之和，还要加上当前结点值，这样就组成了一个条完整的路径。而返回值是取 left 和 right 中的较大值加上当前结点值，因为返回值的定义是以当前结点为终点的 path 之和，所以只能取 left 和 right 中较大的那个值，而不是两个都要

## 125. Valid Palindrome

双指针，两边开始便利，但是要注意边界条件：如果一个字母也没有

## 127. word ladder

BFS 查找，主要是要判断好只相差一个字母的两个字符串，如果只相差一个字母，就认为他们在图上是相邻的。

## 128. Longest Consecutive Sequence

这道题要求求最长连续序列，并给定了 O(n)复杂度限制，我们的思路是，使用一个集合 HashSet 存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后分别用两个变量 pre 和 next 算出其前一个数跟后一个数，然后在集合中循环查找，如果 pre 在集合中，那么将 pre 移除集合，然后 pre 再自减 1，直至 pre 不在集合之中，对 next 采用同样的方法，那么 next-pre-1 就是当前数字的最长连续序列，更新 res 即可。这里再说下，为啥当检测某数字在集合中存在当时候，都要移除数字。这是为了避免大量的重复计算，就拿题目中的例子来说吧，我们在遍历到 4 的时候，会向下遍历 3，2，1，如果都不移除数字的话，遍历到 1 的时候，还会遍历 2，3，4。同样，遍历到 3 的时候，向上遍历 4，向下遍历 2，1，等等等。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效，所以我们要从 HashSet 中移除数字，

## 129. 求根到叶子节点数字之和

回溯法即可。

## 130. surrounded regions

先遍历四周，将遍历的区域全部变为第三个字母，比如‘T’，然后全部扫描一遍，将 O 变成 X,将 T 变成 O,这里遍历可以使用 BFS 或者 DFS，同时，主要到 DFS 可以使用递归来实现，写一个 help 函数 dfs，如果找到联通的点，就递归进去，直到最深处在回来，和 DFS 的本质思想是一样的

## 131. palindrome-partition

这道题目是根据给定的字符串，然后找到所有可能将字符串进行分割，使得分开的每一个字符串都是一个回文序列。

首先写一个工具函数，判断是个字符串是不是回文序列。

然后因为本质上还是组合问题，因此仍然使用回溯法。回溯 help 函数参数包括 paths，path，和起始 index。 从起始 index 起始遍历所有长度 length, 直到起始 index+length==s.size()，判断子字符串是不是回文序列。

如果是回文序列，就添加到 path 里面，并继续深入进行探索，但是起始 index 要增加 length。

最终判断是否添加到 paths，就是看看起始 index 是否达到了 s 的大小，说明已经探索到了末尾。

## 136. single number

使用异或进行处理，异或满足交换率和结合率，可以将两个相同大小的数字消掉。

## 137. single number 2

使用标记的 ones twos 变量进行每一个位的 1 的个数的记录，也可以推广到其他的问题， 比如三个四个重复的数字

但是这种方法不好理解，下面这种方法比较好理解，虽然比较慢。

这道题是之前那道 Single Number 的延伸，那道题的解法就比较独特，是利用计算机按位储存数字的特性来做的，这道题就是除了一个单独的数字之外，数组中其他的数字都出现了三次，还是要利用位操作 Bit Manipulation 来解。可以建立一个 32 位的数字，来统计每一位上 1 出现的个数，如果某一位上为 1 的话，那么如果该整数出现了三次，对 3 取余为 0，这样把每个数的对应位都加起来对 3 取余，最终剩下来的那个数就是单独的数字

## 138. 复制带随机指针的链表

思路 用一个哈希表表示映射关系：键是原节点，值是复制的节点。

整体算法流程是：

第一次遍历，复制每个节点和 next 指针，并且保存“原节点-复制节点”的映射关系
第二次遍历，通过哈希表获得节点对应的复制节点，更新 random 指针

我们也 1 可以使用递归的解法，写起来相当的简洁，还是需要一个 HashMap 来建立原链表结点和拷贝链表结点之间的映射。在递归函数中，首先判空，若为空，则返回空指针。然后就是去 HashMap 中查找是否已经在拷贝链表中存在了该结点，是的话直接返回。否则新建一个拷贝结点 res，然后建立原结点和该拷贝结点之间的映射，然后就是要给拷贝结点的 next 和 random 指针赋值了，直接分别调用递归函数即可

## 139. word-break

这道题目是计算是否可以从备选的单词片段中组成目标单词。

dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。

该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 "leetcode"：

["lee", "tc", "cod"]

求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。

## 141. linked list cycle

使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。如果快指针到达末尾，则说明没有环。

## 142. linked list cycle 2

这个求单链表中的环的起始点是之前那个判断单链表中是否有环的延伸，可参之前那道 Linked List Cycle。这里还是要设快慢指针，不过这次要记录两个指针相遇的位置，当两个指针相遇了后，让其中一个指针从链表头开始，一步两步，一步一步似爪牙，似魔鬼的步伐。。。哈哈，打住打住。。。此时再相遇的位置就是链表中环的起始位置，为啥是这样呢，这里直接贴上热心网友「飞鸟想飞」的解释哈，因为快指针每次走 2，慢指针每次走 1，快指针走的距离是慢指针的两倍。而快指针又比慢指针多走了一圈。所以 head 到环的起点+环的起点到他们相遇的点的距离 与 环一圈的距离相等。现在重新开始，head 运行到环起点 和 相遇点到环起点 的距离也是相等的，相当于他们同时减掉了 环的起点到他们相遇的点的距离

## 144. Binary Tree Preorder Traversal

前序遍历。可以递归，也可以使用栈进行 DFS。

## 145. Binary Tree Postorder Traversal

二叉树的后序遍历。可以使用递归实现

```
void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}
```

也可以使用非递归实现：
前序遍历为 root -> left -> right，后序遍历为 left -> right -> root。可以修改前序遍历成为 root -> right -> left，那么这个顺序就和后序遍历正好相反。

## 151. 翻转字符串里的单词

方法一：先全部反转，然后对每个单词进行反转。

方法二：使用 istringstream 可以很方便的对带空格的字符进行分割。

## 153. find minimum in rotated sorted array

二分查找，关键是找到二分查找的分割条件。

## 155. Min Stack

这道题目是实现一个可以随时返回堆栈里面最小值的堆栈。只需要设置两个堆栈即可，其中一个堆栈保持最小值。然后注意一些进入最小值的堆栈的细节即可。

## 160. Intersection of Two Linked Lists

这道题目是确定两个链表的相交焦点。

可以使用循环两次的方法，当其中一个链表到达结尾之后，跳转到另一个链表。

如果有焦点，那么循环两次之后一定在焦点相遇，如果没有焦点，那么一定在链表的末尾相遇，而且都是 NULL;

## 167. two sum 2

这里是用双指针，不断判断当前两个数字的和与 target 的大小，然后移动相应的指针，指导两个指针相遇或者找到了两个匹配的数字

## 168. excel-sheet-column-title

这里就是注意将输入的数字减一进行处理，可以用递归也可以不用递归

## 169. majority-element

寻找数组中最大 majority，即数目超过 n/2 的个数的数字，这里可以使用很多种方法：（1）排序，返回中间值。（2）摩尔计数。即确定一个摩尔基数器，开始赋值为 0,当预选数字和当前遍历的数字相等的时候，计数器加一，当不相等的时候，计数器减一。如果计数器等于 0 了，那么赋值当前预选数字为当前遍历的数字。所有数字全部遍历完成后，预选数字即为 majority。（3）位操作。如果一个数字是 majority，那么每一个位上面的最大个数的位（0 或 1），组成的二进制数字就是 majority，可以遍历每一个位来寻找。（4）递归+分而治之。可以分左右两个子数组进行递归，返回的左右结果如果相同，那么就是 majority，如果不同，需要比较两个数字的个数谁大。（5）hash 表。可以按顺序遍历，存放到 hash 表中，如果相同就加一，直到个数超过 n/2 就返回。

## 171. excel-sheet-column-number

和 168 本质是一样的，就是注意字母的对应关系是：数字减一与相应字母对应

## 172. Factorial Trailing Zeroes

这道题目是计算 n 的阶乘的末尾 0 的数量。

尾部的 0 由 2 \* 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。

对于一个数 N，它所包含 5 的个数为：N/5 + N/5^2 + N/5^3 + ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5^2 表示不大于 N 的数中 5^2 的倍数再贡献一个 5 ...。

## 188. Best Time to Buy and Sell Stock IV

这道题目是题目 123 的一般性推广，递推公式可以参考题目 123,但是需要注意的是，如果 k >= prices.size()/2,直接使用贪心算法计算即可（参考题目 122）。

## 190. reverse bits

移位操作即可。

也可以按照单独一个位一个位进行处理，也可以按照四个位或更多的位一起进行处理，但是要提前计算好对应的映射表

## 191. numbers of 1 bits

可以使用 n&(n-1)， 它的作用是可以把 n 的二进制表示中的最低位为 1 的改为 0，每更改一次计数器+1，直到 n=0 停止

## 198. house-robber

动态规划经典题目，递推公式是 dp[i] = max(dp[i-1], dp[i-2]+ nums[i]) 也可以修改为长量的额外空间算法，使用 pre 和 pre_pre 两个变量代表 dp[i-1]和 dp[i-2],并不断更新这两个变量

## 200. number of islands

BFS 或 DFS 和题目 695 很像，这道题目不需要计数，只需要遍历完毕之后，在总数目上面加 1 即可，不需要求最大面积。只需要求岛的个数。

## 204. count-primes

这道题目是计算小于 n 的所有质数，质数是因子仅仅包括自己和 1 的数字。1 不是质数。

这道题目的思想是： 从 2 开始遍历到 n，先找到第一个质数 2，然后将其所有的倍数全部标记出来，然后到下一个质数 3，标记其所有倍数，一次类推，直到根号 n，此时数组中未被标记的数字就是质数。我们需要一个 n-1 长度的 bool 型数组来记录每个数字是否被标记， 这就是实现埃拉托斯特尼筛法，难度并不是很大。

## 205. Isomorphic Strings

这道题目是判断两个字符串是不是同构的。

可以使用字符串数组 128 来代表所有字符，设计 t1,t2，题目说两个字符串的大小相等，那么开始遍历，将两个字符串当前的两个字符，都在 t1 与 t2 里面记录下来，记录下来的标记就是当前的下标加 1（为了与初始化的 t1 和 t2 区分开来）。

如果发现某一次 t1 和 t2 对应的位置不同，要么是一个被访问过，一个没被访问过，要么是两个都被访问过，但是二者上一次出现的位置不同，这两种情况都说明，这两个字符串不是同构的，返回 false 即可，全部遍历完成都没问题，那么返回 true 即可。

## 206. Reverse Linked List

链表反转。

包括迭代方法和递归方法。迭代方法就是设置一个 pre 指针，然后不断插入到 pre->next。递归方法就是不断进行递归，每次递归返回一个头指针，注意保存临时变量。

重要注意的点就是算清楚 next 的链接关系。

还要学会递归实现

## 207. Course Schedule

这道课程清单的问题对于我们学生来说应该不陌生，因为我们在选课的时候经常会遇到想选某一门课程，发现选它之前必须先上了哪些课程，这道题给了很多提示，第一条就告诉我们了这道题的本质就是在有向图中检测环。 LeetCode 中关于图的题很少，有向图的仅此一道，还有一道关于无向图的题是 Clone Graph。个人认为图这种数据结构相比于树啊，链表啊什么的要更为复杂一些，尤其是有向图，很麻烦。第二条提示是在讲如何来表示一个有向图，可以用边来表示，边是由两个端点组成的，用两个点来表示边。第三第四条提示揭示了此题有两种解法，DFS 和 BFS 都可以解此题。我们先来看 BFS 的解法，我们定义二维数组 graph 来表示这个有向图，一维数组 in 来表示每个顶点的入度。我们开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后我们定义一个 queue 变量，将所有入度为 0 的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为 0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为 0，则说明环存在，返回 false，反之则返回 true。

下面我们来看 DFS 的解法，也需要建立有向图，还是用二维数组来建立，和 BFS 不同的是，我们像现在需要一个一维数组 visit 来记录访问状态，这里有三种状态，0 表示还未访问过，1 表示已经访问了，-1 表示有冲突。大体思路是，先建立好有向图，然后从第一个门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用 DFS 递归，直到出现新的课程已经访问过了，则返回 false，没有冲突的话返回 true，然后把标记为已访问的课程改为未访问。

## 208. Implement Trie (Prefix Tree)

这道题让我们实现一个重要但又有些复杂的数据结构-字典树， 又称前缀树或单词查找树，详细介绍可以参见[网友董的博客](http://dongxicheng.org/structure/trietree/)，例如，一个保存了 8 个键的 trie 结构，"A", "to", "tea", "ted", "ten", "i", "in", and "inn"

字典树主要有如下三点性质：

1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。

2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。

3. 每个节点的所有子节点包含的字符串不相同。

字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第 i 次循环找到前 i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。至于结点对儿子的指向，一般有三种方法：

1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；

2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；

3、使用左儿子右兄弟表示法记录这棵树。

三种方法，各有特点。第一种易实现，但实际的空间要求较大；第二种，较易实现，空间要求相对较小，但比较费时；第三种，空间要求最小，但相对费时且不易写。

我们这里只来实现第一种方法，这种方法实现起来简单直观，字母的字典树每个节点要定义一个大小为 26 的子节点指针数组，然后用一个标志符用来记录到当前位置为止是否为一个词，初始化的时候讲 26 个子节点都赋为空。那么 insert 操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，若不存在则新建一个，然后再查找下一个。查找词和找前缀操作跟 insert 操作都很类似，不同点在于若不存在子节点，则返回 false。查找次最后还要看标识位，而找前缀直接返回 true 即可

## 209. 长度最小的子数组

可以使用滑动窗口实现，先拓展右边界，然后回来缩短左边界。

下面再来看看 O(nlgn) 的解法，这个解法要用到二分查找法，思路是，建立一个比原数组长一位的 sums 数组，其中 sums[i] 表示 nums 数组中 [0, i - 1] 的和，然后对于 sums 中每一个值 sums[i]，用二分查找法找到子数组的右边界位置，使该子数组之和大于 sums[i] + s，然后更新最短长度的距离即可。

## 210. Course Schedule II

这道题目和题目 207 很像，就是让我们把课程记录下来，还是使用题目 207 一样的方法，比如使用迭代的方式，就是使用队列，关键是在每次队列弹出元素的时候，加入到 ans 就可以了。

## 213. house-robber2

这道题目也是典型的动态规划问题，可以得到递推公式就是当前所抢劫的户的最大钱数，等于到上上一个户的最大钱数加上当前户的钱数 与 抢劫到上一个户最大钱数的 的二者最大值。

这道题目多了一个要求，就是户是环型的，最后一个户和第一个户不能一起抢。那么可以将这个环问题拆开，我先只抢 0 ～ n-2，在抢 1 ～ n-1，这样第一个户和最后一个户不会被同时抢到，我们再取这两种情况的最大值就可以了。

## 215. kth largest element in an array

可以使用很多种方法：（1）使用 std 的函数 nth_element() 或者 partial_sort() (2) 使用小顶堆，维护一个 K 大小的大顶對，遍历数组，如果当前数字小于小顶堆的最小值，就添加进去，并删除堆顶元素。（3）使用大顶堆，将数组所有元素添加进去，然后不断弹出 K 次堆顶元素。（4）使用快速排序的思想，对数组进行分区。 对于使用堆的方法，可以使用 std 的 priority_queue 来构建，也可以使用 multiset()来构建，也可以使用自己构建的数组来自行构建堆结构。

## 216. combination-sum-3

组合求和，这道题目是根据 1-9 备选数字，选出特定组合求和等于 target 的组合，注意这个组合不能有重复的，而且数组 1-9 只能使用一次，而且长度等于 k 的组合。

这里组合不能有重复的，我们考虑后来新添加到 path 的数字必须大于 path 末尾的数字，这样就能保证数组之间没有重复的。

而且对于 path 能够进入 paths 的标准，如果 path_sum 大于 target,那么直接返回，如果 path 的长度达到了 k,那么判断 path_sum 如果等于 target，那么就可以进入 path_sum,如果不等于，那么就直接返回。

## 217. Contains Duplicate

使用 hash_set 实现即可。

## 225. Implement Stack using Queues

这道题目是用队列实现堆栈，使用一个队列即可，关键就是每次添加新的元素的时候，将原本的的元素都一次挪到后面，让新元素排到第一位。

## 226. Invert Binary Tree

这道题目是翻转二叉树，使用递归的思想即可以。

## 230. Kth Smallest Element in a BST

可以使用中序遍历，对于一个 BST 来说，他的中序遍历序列是递增的。

因此我们中序遍历，就可以很方便的寻找到第 k 个数字。

## 231. Power of Two

这道题目是让我们判断一个数字是不是 2 的 n 次方。

可以使用位操作来做，一个数是 2 的 n 次方，那么 n & (n-1) 一定等于 0

## 232. Implement Queue using Stacks

这道题目是使用堆栈实现队列，关键点就是设置两个堆栈。

## 233. 数字 1 的个数

给一个数 n，输出 0 ~ n 中的数字中 1 出现的个数。

解法一 暴力
直接想到的当然就是暴力的方法，一个数一个数的判断，一位一位的判断。

```java
public int countDigitOne(int n) {
    int num = 0;
    for (int i = 1; i <= n; i++) {
        int temp = i;
        while (temp > 0) {
            if (temp % 10 == 1) {
                num++;
            }
            temp /= 10;
        }
    }
    return num;
}
```

但这个解法会超时。

解法二
自己也没想到别的方法，讲一下 这里 的思路。

总体思想就是分类，先求所有数中个位是 1 的个数，再求十位是 1 的个数，再求百位是 1 的个数...

假设 n = xyzdabc，此时我们求千位是 1 的个数，也就是 d 所在的位置。

那么此时有三种情况，

d == 0，那么千位上 1 的个数就是 xyz _ 1000
d == 1，那么千位上 1 的个数就是 xyz _ 1000 + abc + 1
d > 1，那么千位上 1 的个数就是 xyz \* 1000 + 1000
为什么呢？

当我们考虑千位是 1 的时候，我们将千位定为 1，也就是 xyz1abc。

对于 xyz 的话，可以取 0,1,2...(xyz-1)，也就是 xyz 种可能。

当 xyz 固定为上边其中的一个数的时候，abc 可以取 0,1,2...999，也就是 1000 种可能。

这样的话，总共就是 xyz\*1000 种可能。

注意到，我们前三位只取到了 xyz-1，那么如果取 xyz 呢？

此时就出现了上边的三种情况，取决于 d 的值。

d == 1 的时候，千位刚好是 1，此时 abc 可以取的值就是 0 到 abc ，所以多加了 abc + 1。

d > 1 的时候，d 如果取 1，那么 abc 就可以取 0 到 999，此时就多加了 1000。

再看一个具体的例子。

```c
如果 n = 4560234
让我们统计一下千位有多少个 1
xyz 可以取 0 到 455, abc 可以取 0 到 999
4551000 to 4551999 (1000)
4541000 to 4541999 (1000)
4531000 to 4531999 (1000)
...
21000 to 21999 (1000)
11000 to 11999 (1000)
 1000 to 1999 (1000)
总共就是 456 \* 1000

如果 n = 4561234
xyz 可以取 0 到 455, abc 可以取 0 到 999
4551000 to 4551999 (1000)
4541000 to 4541999 (1000)
4531000 to 4531999 (1000)
...
1000 to 1999 (1000)
xyz 还可以取 456, abc 可以取 0 到 234
4561000 to 4561234 (234 + 1)
总共就是 456 \* 1000 + 234 + 1

如果 n = 4563234
xyz 可以取 0 到 455, abc 可以取 0 到 999
4551000 to 4551999 (1000)
4541000 to 4541999 (1000)
4531000 to 4531999 (1000)
...
1000 to 1999 (1000)
xyz 还可以取 456, abc 可以取 0 到 999
4561000 to 4561999 (1000)
总共就是 456 \* 1000 + 1000
```

至于其它位的话是一样的道理。

链接：https://leetcode-cn.com/problems/number-of-digit-one/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-50/

## 234. Palindrome Linked List

这道题目判断链表是不是回文序列。
使用快慢指针，可以找到链表的最中间的位置，一个指针从头开始，一个指针从中间开始， 然后可以判断链表两半部分是不是相等。

## 235. Lowest Common Ancestor of a Binary Search Tree

这道题我们可以用递归来求解，我们首先来看题目中给的例子，由于二叉搜索树的特点是左<根<右，所以根节点的值一直都是中间值，大于左子树的所有节点值，小于右子树的所有节点值，那么我们可以做如下的判断，如果根节点的值大于 p 和 q 之间的较大值，说明 p 和 q 都在左子树中，那么此时我们就进入根节点的左子节点继续递归，如果根节点小于 p 和 q 之间的较小值，说明 p 和 q 都在右子树中，那么此时我们就进入根节点的右子节点继续递归，如果都不是，则说明当前根节点就是最小共同父节点，直接返回即可

## 236. Lowest Common Ancestor of a Binary Tree

这道求二叉树的最小共同父节点的题是之前那道 Lowest Common Ancestor of a Binary Search Tree 的 Follow Up。跟之前那题不同的地方是，这道题是普通是二叉树，不是二叉搜索树，所以就不能利用其特有的性质，我们只能在二叉树中来搜索 p 和 q，然后从路径中找到最后一个相同的节点即为父节点，可以用递归来实现，在递归函数中，首先看当前结点是否为空，若为空则直接返回空，若为 p 或 q 中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了 p 和 q 一定都在二叉树中存在，那么如果当前结点不等于 p 或 q，p 和 q 要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论：

- 若 p 和 q 分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回 p 和 q 结点的位置，而当前结点正好就是 p 和 q 的最小共同父结点，直接返回当前结点即可，这就是题目中的例子 1 的情况。

- 若 p 和 q 同时位于左子树，这里有两种情况，一种情况是 left 会返回 p 和 q 中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子 2 的情况。还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的左子树中的某个结点才是 p 和 q 的最小父结点，会被返回。

- 若 p 和 q 同时位于右子树，同样这里有两种情况，一种情况是 right 会返回 p 和 q 中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的右子树中的某个结点才是 p 和 q 的最小父结点，会被返回，写法很简洁

## 238. Product of Array Except Self

这道题给定我们一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限定了时间复杂度 O(n)，并且不让我们用除法。如果让用除法的话，那这道题就应该属于 Easy，因为可以先遍历一遍数组求出所有数字之积，然后除以对应位置的上的数字。但是这道题禁止我们使用除法，那么我们只能另辟蹊径。我们想，对于某一个数字，如果我们知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果，所以我们只要分别创建出这两个数组即可，分别从数组的两个方向遍历就可以分别创建出乘积累积数组。

我们可以对上面的方法进行空间上的优化，由于最终的结果都是要乘到结果 res 中，所以可以不用单独的数组来保存乘积，而是直接累积到结果 res 中，我们先从前面遍历一遍，将乘积的累积存入结果 res 中，然后从后面开始遍历，用到一个临时变量 right，初始化为 1，然后每次不断累积，最终得到正确结果.

## 239. 滑动窗口最大值

这道题给定了一个数组，还给了一个窗口大小 k，让我们每次向右滑动一个数字，每次返回窗口内的数字的最大值。难点就在于如何找出滑动窗口内的最大值（这不废话么，求得不就是这个），那么最狂野粗暴的方法就是每次遍历窗口，找最大值呗，OJ 说呵呵哒，no way！我们希望窗口内的数字是有序的，但是每次给新窗口排序又太费时了，所以最好能有一种类似二叉搜索树的结构，可以在 lgn 的时间复杂度内完成插入和删除操作，那么使用 STL 自带的 multiset 就能满足我们的需求，这是一种基于红黑树的数据结构，可以自动对元素进行排序，又允许有重复值，完美契合。所以我们的思路就是，遍历每个数字，即窗口右移，若超过了 k，则需要把左边界值删除，这里不能直接删除 nums[i-k]，因为集合中可能有重复数字，我们只想删除一个，而 erase 默认是将所有和目标值相同的元素都删掉，所以我们只能提供一个 iterator，代表一个确定的删除位置，先通过 find() 函数找到左边界 nums[i-k] 在集合中的位置，再删除即可。然后将当前数字插入到集合中，此时看若 i >= k-1，说明窗口大小正好是 k，就需要将最大值加入结果 res 中，而由于 multiset 是按升序排列的，最大值在最后一个元素，我们可以通过 rbegin() 来取出。

我们也可以使用优先队列来做，即最大堆，不过此时我们里面放一个 pair 对儿，由数字和其所在位置组成的，这样我们就可以知道每个数字的位置了，而不用再进行搜索了。在遍历每个数字时，进行 while 循环，假如优先队列中最大的数字此时不在窗口中了，就要移除，判断方法就是将队首元素的 pair 对儿中的 second（位置坐标）跟 i-k 对比，小于等于就移除。然后将当前数字和其位置组成 pair 对儿加入优先队列中。此时看若 i >= k-1，说明窗口大小正好是 k，就将最大值加入结果 res 中即可

## 240. Search a 2D Matrix II

突然发现 LeetCode 很喜欢从 LintCode 上盗题，这是逼我去刷 LintCode 的节奏么?! 这道题让我们在一个二维数组中快速的搜索的一个数字，这个二维数组各行各列都是按递增顺序排列的，是之前那道 Search a 2D Matrix 搜索一个二维矩阵的延伸，那道题的不同在于每行的第一个数字比上一行的最后一个数字大，是一个整体蛇形递增的数组。所以那道题可以将二维数组展开成一个一位数组用一次二查搜索。而这道题没法那么做，这道题有它自己的特点。如果我们观察题目中给的那个例子，我们可以发现有两个位置的数字很有特点，左下角和右上角的数。左下角的 18，往上所有的数变小，往右所有数增加，那么我们就可以和目标数相比较，如果目标数大，就往右搜，如果目标数小，就往上搜。这样就可以判断目标数是否存在。当然我们也可以把起始数放在右上角，往左和下搜，停止条件设置正确就行

## 241. different ways to add parentheses

可以使用分而治之进行解决，改进一点是可以使用 hash 表记录一些映射，以时间换空间提高计算效率。本题就是按照计算符号将原来的子符串分为两边，两边分别调用原来函数递归得到结果。对于左右的结果，分别遍历交叉计算得到最终的结果。

## 242. Valid Anagram

这道题目让我们判断两个字符串是不是相同字母的。

可以使用 hashmap 来进行统计，又因为这里面仅仅涉及到字母，可以使用大小为 26 的数组，若涉及到各种所有字符，那么可以使用大小为 128 数组。

这里面如果使用 hashmap 空间复杂度计算的时候 O(n),但是使用固定大小的数组的空间复杂度是 O(1)

## 260. Single Number 3

这道题是之前那两道 Single Number 和 Single Number II 的再次延伸，说实话，这类位操作 Bit Manipulation 的题，如果之前没有遇到过类似的题目，楞想是很难相出来的，于是我只能上网搜大神们的解法，发现还真是巧妙啊。这道题其实是很巧妙的利用了 Single Number 的解法，因为那道解法是可以准确的找出只出现了一次的数字，但前提是其他数字必须出现两次才行。而这题有两个数字都只出现了一次，那么我们如果能想办法把原数组分为两个小数组，不相同的两个数字分别在两个小数组中，这样分别调用 Single Number 的解法就可以得到答案。那么如何实现呢，首先我们先把原数组全部异或起来，那么我们会得到一个数字，这个数字是两个不相同的数字异或的结果，我们取出其中任意一位为 ‘1’ 的位，为了方便起见，我们用 a &= -a 来取出最右端为 ‘1’ 的位，具体来说下这个是如何操作的吧。就拿题目中的例子来说，如果我们将其全部 '异或' 起来，我们知道相同的两个数 '异或' 的话为 0，那么两个 1，两个 2，都抵消了，就剩 3 和 5 '异或' 起来，那么就是二进制的 11 和 101 '异或' ，得到 110。然后我们进行 a &= -a 操作。首先变负数吧，在二进制中负数采用补码的形式，而补码就是反码 +1，那么 110 的反码是 11...1001，那么加 1 后是 11...1010，然后和 110 相与，得到了 10，就是代码中的 diff 变量。得到了这个 diff，就可以将原数组分为两个数组了。为啥呢，我们想阿，如果两个相同的数字 '异或' ，每位都会是 0，而不同的数字 '异或' ，一定会有对应位不同，一个 0 一个 1，这样 '异或' 是 1。比如 3 和 5 的二进制 11 和 101，如果从低往高看，最开始产生不同的就是第二位，那么我们用第二位来和数组中每个数字相与，根据结果的不同，一定可以把 3 和 5 区分开来，而其他的数字由于是成对出现，所以区分开来也是成对的，最终都会 '异或' 成 0，不会 3 和 5 产生影响。分别将两个小组中的数字都异或起来，就可以得到最终结果了，

## 264. 丑数 II

这道题是之前那道 Ugly Number 的拓展，这里让找到第 n 个丑陋数，还好题目中给了很多提示，基本上相当于告诉我们解法了，根据提示中的信息，丑陋数序列可以拆分为下面 3 个子列表：

(1) 1x2, 2x2, 2x2, 3x2, 3x2, 4x2, 5x2...
(2) 1x3, 1x3, 2x3, 2x3, 2x3, 3x3, 3x3...
(3) 1x5, 1x5, 1x5, 1x5, 2x5, 2x5, 2x5...
仔细观察上述三个列表，可以发现每个子列表都是一个丑陋数分别乘以 2，3，5，而要求的丑陋数就是从已经生成的序列中取出来的，每次都从三个列表中取出当前最小的那个加入序列

## 268. Missing Number

这道题给我们 n 个数字，是 0 到 n 之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。那么最直观的一个方法是用等差数列的求和公式求出 0 到 n 之间所有的数字之和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字

这题还有一种解法，使用位操作 Bit Manipulation 来解的，用到了异或操作的特性，相似的题目有 Single Number 单独的数字, Single Number II 单独的数字之二和 Single Number III 单独的数字之三。那么思路是既然 0 到 n 之间少了一个数，我们将这个少了一个数的数组合 0 到 n 之间完整的数组异或一下，那么相同的数字都变为 0 了，剩下的就是少了的那个数字了

这道题还可以用二分查找法来做，我们首先要对数组排序，然后我们用二分查找法算出中间元素的下标，然后用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，此时将 right 赋为 mid，反之则将 left 赋为 mid+1。那么看到这里，作为读者的你可能会提出，排序的时间复杂度都不止 O(n)，何必要多此一举用二分查找，还不如用上面两种方法呢。对，你说的没错，但是在面试的时候，有可能人家给你的数组就是排好序的，那么此时用二分查找法肯定要优于上面两种方法，所以这种方法最好也要掌握以下~

## 278. first bad version

二分查找

## 279. perfect squares

动态规划。将原问题思考为最初始的简单问题的汇总，这里就是从 n=1 开始，逐渐增加 n,递推关系为 dp[i] = min(dp[i - j * j] + 1, dp[i]);也可以使用 BFS，思路就是假想有一个 graph，里面每个节点如果满足 i=j+squares 即代表二者相连（Node j is connected to node i via an edge if  
and only if either j = i + (a perfect square number) or i = j + (a perfect square number).）。使用广度优先便利即可以找到最短路径。

## 283. Move Zeroes

这道题目让我们将一个数组的所有 0 放在最后面，同时不改变其他数字的相对次序，同时不使用额外的空间。

这个可以使用双指针进行实现。

左边的指针从头开始遍历，右边的指针从第一个 0 数组开始遍历。

然后两个指针一起前进，如果左指针等于 0,右指针非 0,那么交换这两个数字。

如果左指针非 0，那么直接前进，如果右指针等于 0,那么直接前进，直到右指针到达末尾为之。

## 287. Find the Duplicate Number

思路：这道题要求我们查找的数是一个整数，并且给出了这个整数的范围（在 11 和 nn 之间，包括 1 和 n），并且给出了一些限制，于是可以使用二分查找法定位在一个区间里的整数。

这个问题应用二分法与绝大多数其它问题应用二分法的不同点是：正着思考是容易的，即思考哪边区间存在重复数是容易的，因为依然是有抽屉原理做保证。我们依然通过一个具体的例子来分析应该如何编写代码。

以 [1, 2, 2, 3, 4, 5, 6, 7] 为例，一共 8 个数，n + 1 = 8，n = 7，根据题目意思，每个数都在 1 和 7 之间。

例如：区间 [1, 7] 的中位数是 4，遍历整个数组，统计小于等于 4 的整数的个数，至多应该为 4 个。换句话说，整个数组里小于等于 4 的整数的个数如果严格大于 4 个，就说明重复的数存在于区间 [1, 4]，它的反面是：重复的数存在于区间 [5, 7]。

于是，二分法的思路是先猜一个数（有效范围 [left, right]里的中间数 mid），然后统计原始数组中小于等于这个中间数的元素的个数 cnt，如果 cnt 严格大于 mid，（注意我加了着重号的部分“小于等于”、“严格大于”）依然根据抽屉原理，重复元素就应该在区间 [left, mid] 里。

还有一种解法是类似于链表判断环：

【笔记】这道题（据说）花费了计算机科学界的传奇人物 Don Knuth 24 小时才解出来。并且我只见过一个人（注：Keith Amling）用更短时间解出此题。

快慢指针，一个时间复杂度为 O(N)的算法。

其一，对于链表问题，使用快慢指针可以判断是否有环。

其二，本题可以使用数组配合下标，抽象成链表问题。但是难点是要定位环的入口位置。

举个例子：nums = [2,5, 9 ,6,9,3,8, 9 ,7,1]，构造成链表就是：2->[9]->1->5->3->6->8->7->[9]，也就是在[9]处循环。

其三，快慢指针问题，会在环内的[9]->1->5->3->6->8->7->[9]任何一个节点追上，不一定是在[9]处相碰，事实上会在 7 处碰上。

其四，必须另起一个 for 循环定位环入口位置[9]。这里需要数学证明。

对“其四”简单说明一下，既然快慢指针在环内的某处已经相碰了。那么，第二个 for 循环遍历时，res 指针还是在不停的绕环走，但是必定和 i 指针在环入口处相碰。

这里说明一下，就是入口设置 index=0,是因为 index=0 一定在环的外面，不会在环的里面，因为数组里面所有的数组都是 1 ～ n 而不是 0 ～ n.

## 292. nim-游戏

有史以来最少代码量的解法，虽然解法很简单，但是题目还是蛮有意思的，题目说给我们一堆石子，每次可以拿一个两个或三个，两个人轮流拿，拿到最后一个石子的人获胜，现在给我们一堆石子的个数，问我们能不能赢。那么我们就从最开始分析，由于是我们先拿，那么 3 个以内(包括 3 个)的石子，我们直接赢，如果共 4 个，那么我们一定输，因为不管我们取几个，下一个人一次都能取完。如果共 5 个，我们赢，因为我们可以取一个，然后变成 4 个让别人取，根据上面的分析我们赢，所以我们列出 1 到 10 个的情况如下：

1 Win

2 Win

3 Win

4 Lost

5 Win

6 Win

7 Win

8 Lost

9 Win

10 Win

由此我们可以发现规律，只要是 4 的倍数个，我们一定会输，所以对 4 取余即可

讨论：我们来 generalize 一下这道题，当可以拿 1 ～ n 个石子时，那么个数为(n+1)的整数倍时一定会输，我们试着证明一下这个结论，若当前共有 m\*(n+1)个石子，那么：

当 m=1 时，即剩 n+1 个的时候，肯定会输，因为不管你取 1 ～ n 中的任何一个数字，另一个人都可以取完。
当 m>1 时，即有 m*(n+1)的时候，不管你先取 1 ～ n 中的任何一个数字 x，另外一个人一定会取 n+1-x 个，这样总数就变成了(m-1)*(n+1)，第二个人就一直按这个策略取，那么直到剩 n+1 个的时候，就便变成 m=1 的情况，一定会输

## 293. 翻转游戏

[链接](https://www.cnblogs.com/grandyang/p/5224896.html)

## 294. 翻转游戏之二

[链接](https://www.cnblogs.com/grandyang/p/5226206.html)

## 295. 找出数据流的中位数

这道题给我们一个数据流，让我们找出中位数，由于数据流中的数据并不是有序的，所以我们首先应该想个方法让其有序。如果我们用 vector 来保存数据流的话，每进来一个新数据都要给数组排序，很不高效。所以之后想到用 multiset 这个数据结构，是有序保存数据的，但是它不能用下标直接访问元素，找中位数也不高效。这里用到的解法十分巧妙，我们使用大小堆来解决问题，其中大堆保存右半段较大的数字，小堆保存左半段较小的数组。这样整个数组就被中间分为两段了，由于堆的保存方式是由大到小，我们希望大堆里面的数据是从小到大，这样取第一个来计算中位数方便。我们用到一个小技巧，就是存到大堆里的数先取反再存，这样由大到小存下来的顺序就是实际上我们想要的从小到大的顺序。当大堆和小堆中的数字一样多时，我们取出大堆小堆的首元素求平均值，当小堆元素多时，取小堆首元素为中位数

## 297. 二叉树的序列化与反序列化

这道题让我们对二叉树进行序列化和去序列化的操作。序列化就是将一个数据结构或物体转化为一个位序列，可以存进一个文件或者内存缓冲器中，然后通过网络连接在相同的或者另一个电脑环境中被还原，还原的过程叫做去序列化。现在让我们来序列化和去序列化一个二叉树，并给了我们例子。这题有两种解法，分别为先序遍历的递归解法和层序遍历的非递归解法。先来看先序遍历的递归解法，非常的简单易懂，我们需要接入输入和输出字符串流 istringstream 和 ostringstream，对于序列化，我们从根节点开始，如果节点存在，则将值存入输出字符串流，然后分别对其左右子节点递归调用序列化函数即可。对于去序列化，我们先读入第一个字符，以此生成一个根节点，然后再对根节点的左右子节点递归调用去序列化函数即可，

另一种方法是层序遍历的非递归解法，这种方法略微复杂一些，我们需要借助 queue 来做，本质是 BFS 算法，也不是很难理解，就是 BFS 算法的常规套路稍作修改即可

## 300. longest-increasing-subsquence

这道题目是求最长子序列。可以使用动态规划进行求解

设计一个数组 dp，dp[i]代表以 nums[i]结尾的最长子序列的长度，然后对于 nums[i],遍历前面的 nums[i](j < i), 如果 nums[i] > nums[j] ，就在 dp[j]上加 1, 说明 nums[j]可以添加到后面的序列中，统计最大值作为 dp[i],然后不断迭代更新。

## 303. range-sum-query-immutable

这道题目比较特殊，构造函数使用一次，子函数调用很多次，所以要求构造函数多做一些任务，子函数做的任务小一些。

这里题目的作用就是返回 i 到 j 之间的求和，那么在构造函数里面，就创建一个数组，数组 i 存储累计到 i 为止的所有元素的和。

子函数直接计算 j-i 就是 i 到 j 之间的和了。

## 309. Best Time to Buy and Sell Stock with Cooldown

这道题目计算股票的最大收益，但是添加了一个条件就是卖出后有一天的冷却期。

设计两个数组，分别是：

have[i],代表第 i 天手里持有股票时的最大收益。

nothave[i]，代表第 i 天手里没有股票是的最大收益。

递推关系式是：

```c++
have[i] = max(have[i-1], (i>=2 ? nothave[i-2] : 0) - prices[i]);
nothave[i] = max(nothave[i-1], have[i-1] + prices[i]);
```

第 i 天 have[i]说明手里有股票，如果没有操作，那么取决于 have[i-1],如果是当天买了，那么取决于 nothave[i-2] - prices[i]，因为有冷却期，取决于前天卖出的最大收益。

第 i 天 nothave[i]说明手里没有股票，如果没有操作，那么取决于 nothave[i-1]，如果当天是卖出，那么取决于 have[i-1]。

## 312. 戳气球

这道题提出了一种打气球的游戏，每个气球都对应着一个数字，每次打爆一个气球，得到的金币数是被打爆的气球的数字和其两边的气球上的数字相乘，如果旁边没有气球了，则按 1 算，以此类推，求能得到的最多金币数。参见题目中给的例子，题意并不难理解。那么大家拿到题后，总是会习惯的先去想一下暴力破解法吧，这道题的暴力搜索将相当的复杂，因为每打爆一个气球，断开的地方又重新挨上，所有剩下的气球又要重新遍历，这使得分治法不能 work，整个的时间复杂度会相当的高，不要指望可以通过 OJ。而对于像这种求极值问题，一般都要考虑用动态规划 Dynamic Programming 来做，维护一个二维动态数组 dp，其中 dp[i][j] 表示打爆区间 [i,j] 中的所有气球能得到的最多金币。题目中说明了边界情况，当气球周围没有气球的时候，旁边的数字按 1 算，这样可以在原数组两边各填充一个 1，方便于计算。这道题的最难点就是找状态转移方程，还是从定义式来看，假如区间只有一个数，比如 dp[i][i]，那么计算起来就很简单，直接乘以周围两个数字即可更新。如果区间里有两个数字，就要算两次了，先打破第一个再打破了第二个，或者先打破第二个再打破第一个，比较两种情况，其中较大值就是该区间的 dp 值。假如区间有三个数呢，比如 dp[1][3]，怎么更新呢？如果先打破第一个，剩下两个怎么办呢，难道还要分别再遍历算一下吗？这样跟暴力搜索的方法有啥区别呢，还要 dp 数组有啥意思。所谓的状态转移，就是假设已知了其他状态，来推导现在的状态，现在是想知道 dp[1][3] 的值，那么如果先打破了气球 1，剩下了气球 2 和 3，若之前已经计算了 dp[2][3] 的话，就可以使用其来更新 dp[1][3] 了，就是打破气球 1 的得分加上 dp[2][3]。那假如先打破气球 2 呢，只要之前计算了 dp[1][1] 和 dp[3][3]，那么三者加起来就可以更新 dp[1][3]。同理，先打破气球 3，就用其得分加上 dp[1][2] 来更新 dp[1][3]。说到这里，是不是感觉豁然开朗了 ^.^

那么对于有很多数的区间 [i, j]，如何来更新呢？现在是想知道 dp[i][j] 的值，这个区间可能比较大，但是如果知道了所有的小区间的 dp 值，然后聚沙成塔，逐步的就能推出大区间的 dp 值了。还是要遍历这个区间内的每个气球，就用 k 来遍历吧，k 在区间 [i, j] 中，假如第 k 个气球最后被打爆，那么此时区间 [i, j] 被分成了三部分，[i, k-1]，[k]，和 [k+1, j]，只要之前更新过了 [i, k-1] 和 [k+1, j] 这两个子区间的 dp 值，可以直接用 dp[i][k-1] 和 dp[k+1][j]，那么最后被打爆的第 k 个气球的得分该怎么算呢，你可能会下意识的说，就乘以周围两个气球被 nums[k-1] _ nums[k] _ nums[k+1]，但其实这样是错误的，为啥呢？dp[i][k-1] 的意义是什么呢，是打爆区间 [i, k-1] 内所有的气球后的最大得分，此时第 k-1 个气球已经不能用了，同理，第 k+1 个气球也不能用了，相当于区间 [i, j] 中除了第 k 个气球，其他的已经爆了，那么周围的气球只能是第 i-1 个，和第 j+1 个了，所以得分应为 nums[i-1] _ nums[k] _ nums[j+1]，分析到这里，状态转移方程应该已经跃然纸上了吧，如下所示：

dp[i][j] = max(dp[i][j], nums[i - 1] _ nums[k] _ nums[j + 1] + dp[i][k - 1] + dp[k + 1][j]) ( i ≤ k ≤ j )

## 318. Maximum Product of Word Lengths

题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。

本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数的各个位来表示字母的出现。

如果两个字符串没有相同的字符，那么两个数字进行位与操作一定是 0,这样判断起来就很快。

## 322. coin-change

这道题目是完全背包问题：想比于普通背包问题，也叫 01 背包问题（例如题目 416），二者区别在于：

> 1. 完全背包问题可以使用无限次物品
> 2. 01 背包问题只能使用一次物品

具体就是体现在循环队列是正序还是倒序列。

我知道，背包问题的递推公式如下：

```c
dp[i] = min(dp[i], dp[i-num]+1);
```

在进行循环遍历的样子如下：

完全背包：

```c
for(int num : coins){
    for(int i=num;i<=amount;i++){
        dp[i] = min(dp[i], dp[i-num]+1);
    }
}
```

01 背包：

```c
for(int num : coins){
    for(int i=amount;i>=num;i--){
        dp[i] = min(dp[i], dp[i-num]+1);
    }
}
```

为什么 01 背包要倒序呢，这是因为 01 背包必须物品只能使用一次，如果正序的话，比如 dp[3]更新了一次，说明使用了当前遍历的物品，那么后续遍历的时候，dp[8]可能用到了 dp[3],又更新一次，那么这个物品又被使用了一次，这是不符合 01 背包物品只能使用一次的规则的。因此倒序进行，先更新 dp[8],这时候使用的 dp[3]肯定是没有被更新过得，保证整个遍历的过程中，物品仅仅被使用一次。

那么对于完全背包问题，由于物品可以使用无限次，那么必须使用正序，倒序反而不合适。

## 326. Power of Three

这道题目是判断 n 是不是 3 的倍数。

一种巧妙的方法，利用对数的换底公式来做，高中学过的换底公式为 logab = logcb / logca，那么如果 n 是 3 的倍数，则 log3n 一定是整数，我们利用换底公式可以写为 log3n = log10n / log103，注意这里一定要用 10 为底数，不能用自然数或者 2 为底数，否则当 n=243 时会出错，原因请看这个帖子。现在问题就变成了判断 log10n / log103 是否为整数，在 c++中判断数字 a 是否为整数，我们可以用 a - int(a) == 0 来判断

## 328. odd even linked list

这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。我们可以使用两个指针来做，pre 指向奇节点，cur 指向偶节点，然后把偶节点 cur 后面的那个奇节点提前到 pre 的后面，然后 pre 和 cur 各自前进一步，此时 cur 又指向偶节点，pre 指向当前奇节点的末尾，以此类推直至把所有的偶节点都提前了即可

## 329. 矩阵中的最长递增路径

这道题给我们一个二维数组，让我们求矩阵中最长的递增路径，规定我们只能上下左右行走，不能走斜线或者是超过了边界。那么这道题的解法要用递归和 DP 来解，用 DP 的原因是为了提高效率，避免重复运算。我们需要维护一个二维动态数组 dp，其中 dp[i][j]表示数组中以(i,j)为起点的最长递增路径的长度，初始将 dp 数组都赋为 0，当我们用递归调用时，遇到某个位置(x, y), 如果 dp[x][y]不为 0 的话，我们直接返回 dp[x][y]即可，不需要重复计算。我们需要以数组中每个位置都为起点调用递归来做，比较找出最大值。在以一个位置为起点用 DFS 搜索时，对其四个相邻位置进行判断，如果相邻位置的值大于上一个位置，则对相邻位置继续调用递归，并更新一个最大值，搜素完成后返回即可

## 337. house-robber 3 到若干个完全

这道题是之前那两道 House Robber II 和 House Robber 的拓展，这个小偷又偷出新花样了，沿着二叉树开始偷，碉堡了，题目中给的例子看似好像是要每隔一个偷一次，但实际上不一定只隔一个，比如如下这个例子：

```
        4
       /
      1
     /
    2
   /
  3
```

如果隔一个偷，那么是 4+2=6，其实最优解应为 4+3=7，隔了两个，所以说纯粹是怎么多怎么来，那么这种问题是很典型的递归问题，可以利用回溯法来做，因为当前的计算需要依赖之前的结果，那么对于某一个节点，如果其左子节点存在，通过递归调用函数，算出不包含左子节点返回的值，同理，如果右子节点存在，算出不包含右子节点返回的值，那么此节点的最大值可能有两种情况，一种是该节点值加上不包含左子节点和右子节点的返回值之和，另一种是左右子节点返回值之和不包含当期节点值，取两者的较大值返回即可，但是这种方法无法通过 OJ，超时了，所以必须优化这种方法，这种方法重复计算了很多地方，比如要完成一个节点的计算，就得一直找左右子节点计算，可以把已经算过的节点用 HashMap 保存起来，以后递归调用的时候，现在 HashMap 里找，如果存在直接返回，如果不存在，等计算出来后，保存到 HashMap 中再返回，这样方便以后再调用，

## 338. Counting Bits

这道题给我们一个整数 n，然我们统计从 0 到 n 每个数的二进制写法的 1 的个数，存入一个一维数组中返回，题目中明确表示不希望我们一个数字一个数字，一位一位的傻算，而是希望我们找出规律，而且题目中也提示了我们注意 [2-3], [4-7], [8-15] 这些区间的规律，那么我们写出 0 到 15 的数的二进制和 1 的个数如下：

```
0    0000    0
-------------
1    0001    1
-------------
2    0010    1
3    0011    2
-------------
4    0100    1
5    0101    2
6    0110    2
7    0111    3
-------------
8    1000    1
9    1001    2
10   1010    2
11   1011    3
12   1100    2
13   1101    3
14   1110    3
15   1111    4
```

我最先看出的规律是这样的，除去前两个数字 0 个 1，从 2 开始，2 和 3，是 [2^1, 2^2) 区间的，值为 1 和 2。而 4 到 7 属于 [2^2, 2^3) 区间的，值为 1,2,2,3，前半部分 1 和 2 和上一区间相同，2 和 3 是上面的基础上每个数字加 1。再看 8 到 15，属于 [2^3, 2^4) 区间的，同样满足上述规律

## 342. Power of Four

这道题目让我们判断一个数字是不是 4 的倍数。

首先判断是不是小于等于 0,然后判断是不是 2 的倍数，然后进行位操作，逐渐移位统计 1 后面 0 的个数，如果统计 0 的个数是偶数个，那么就是 4 的倍数。

## 343. integer-break

这道题目是将一个整数进行拆分，以计算拆分后的各部分积求得最大值。

这道题目一个技巧就是，拆分越多的 3,最终的积的最大。所以拆分求得 3 越多越好，再把剩下的部分乘进去。如果剩下的是>=5,那么继续拆分，如果是 4,那么就乘进去。

还可以用动态规划进行求解，任意一个数字 n，设计一个动态规划数组 dp，代表可以求得的最大积，逐步计算到 dp[n]

对于一个数字 i,可以遍历他其中的一个和因子 j,那么他的另外一部分就是 i-j.

如果不对 i-j 进行拆分，那么求积就是 j\*(i-j), 如果对 i-j 进行拆分，那么求积就是 j\*(dp[i-j]), 二者取最大就是最大积。

## 345. reverse vowels of a string

可以使用 hash 表存储元音字母，然后使用双指针从两边遍历，如果是元音，则交换。另一种方法是 find_last_of 与 find_first_of 函数，不使用 hash 表

## 347. top k frequent elements

使用 hashmap 储存每个数据出现的次数，然后可以使用大顶堆来选出 top k,也可以使用桶排序来计算，桶排序就是将相同出现次数的数字放在一个桶中，然后全部放进去之后，从后向前遍历桶

## 354. 俄罗斯套娃信封问题

本质上就是一个最长递增子序列的问题。

## 367. Valid Perfect Square

遍历从 2 到 n/2 的范围，检测是否 i\*i==num，如果检测大于 num，那么直接 false，如果等于 num，那么直接 true。

## 371. Sum of Two Integers

这道题是 CareerCup 上的一道原题，可参加我之前的博客 18.1 Add Two Numbers。让我们实现两数相加，但是不能用加号或者其他什么数学运算符号，那么我们只能回归计算机运算的本质，位操作 Bit Manipulation，我们在做加法运算的时候，每位相加之后可能会有进位 Carry 产生，然后在下一位计算时需要加上进位一起运算，那么我们能不能将两部分拆开呢，我们来看一个例子 759+674

1. 如果我们不考虑进位，可以得到 323

2. 如果我们只考虑进位，可以得到 1110

3. 我们把上面两个数字假期 323+1110=1433 就是最终结果了

然后我们进一步分析，如果得到上面的第一第二种情况，我们在二进制下来看，不考虑进位的加，0+0=0，0+1=1, 1+0=1，1+1=0，这就是异或的运算规则，如果只考虑进位的加 0+0=0, 0+1=0, 1+0=0, 1+1=1，而这其实这就是'与'的运算，而第三步在将两者相加时，我们再递归调用这个算法，终止条件是当进位为 0 时，直接返回第一步的结果。一切都是如此的美好，突然有一天，博主的所有方法都无法通过 OJ 了，不知为何，原因不明。在热心网友 GGGGITFK 的提示下，终于知道了错误的原因：

runtime error: left shift of negative value -2147483648，对 INT_MIN 左移位。

就是 LeetCode 自己的编译器比较 strict，不能对负数进行左移，就是说最高位符号位必须要为 0，才能左移（此处应有尼克杨问号脸？！），好吧，你赢了。那么我们在 a 和 b 相'与'之后，再'与'上一个最高位为 0，其余位都为 1 的数 0x7fffffff，这样可以强制将最高位清零，然后再进行左移，终于，世界清静了

## 376. wiggle-subsequence

这道题目求最长摆动子序列。 动态规划方式进行解决，设计两个数组 up 和 down, 代表到 i 为止以上升沿和下降沿为止的摆动序列的最长长度。

如果 nums[i] > nums[i-1], 则上升沿数组更新（在 down[i-1]上加一），下降沿数组维持上一个不变。如果 nums[i] < nums[i-1], 则下降沿数组更新（在 up[i-1]上加一），上升沿数组维持上一个不变。

数组中的任何元素都对应下面三种可能状态中的一种：

上升的位置，意味着 nums[i] > nums[i - 1]nums[i]>nums[i−1]
下降的位置，意味着 nums[i] < nums[i - 1]nums[i]<nums[i−1]
相同的位置，意味着 nums[i] == nums[i - 1]nums[i]==nums[i−1]
更新的过程如下：

如果 nums[i] > nums[i-1]nums[i]>nums[i−1] ，意味着这里在摆动上升，前一个数字肯定处于下降的位置。所以 up[i] = down[i-1] + 1up[i]=down[i−1]+1 ， down[i]down[i] 与 down[i-1]down[i−1] 保持相同。

如果 nums[i] < nums[i-1]nums[i]<nums[i−1] ，意味着这里在摆动下降，前一个数字肯定处于下降的位置。所以 down[i] = up[i-1] + 1down[i]=up[i−1]+1 ， up[i]up[i] 与 up[i-1]up[i−1] 保持不变。

如果 nums[i] == nums[i-1]nums[i]==nums[i−1] ，意味着这个元素不会改变任何东西因为它没有摆动。所以 down[i]down[i] 与 up[i]up[i] 与 down[i-1]down[i−1] 和 up[i-1]up[i−1] 都分别保持不变。

最后，我们可以将 up[length-1]up[length−1] 和 down[length-1]down[length−1] 中的较大值作为问题的答案，其中 lengthlength 是给定数组中的元素数目。

最后还可以对空间进行优化，因为这个动态规划仅仅与前一个状态有关。

## 377. combination-sum-4

这是一道完全背包问题，里面的数字可以使用很多次，而且计算可以组成 target 的序列，顺序是有区别的，比如{1,2,1}和{1,1,2}是两个答案，这个可以使用动态规划来进行计算。

如果使用递归来进行计算会耗时很严重，因为它只需要计算个数，所以我们使用动态规划来解决。

经典的完全背包形式：

```c++
    dp[0] = 1;

    for(long i=1;i<=target;i++){
        for(long num : nums){
            if(i >= num){
                dp[i] += dp[i-num];
            }
        }
    }
```

## 378. Kth Smallest Element in a Sorted Matrix

这道题让我们求有序矩阵中第 K 小的元素，这道题的难点在于数组并不是蛇形有序的，意思是当前行的最后一个元素并不一定会小于下一行的首元素，所以我们并不能直接定位第 K 小的元素，所以只能另辟蹊径。先来看一种利用堆的方法，我们使用一个最大堆，然后遍历数组每一个元素，将其加入堆，根据最大堆的性质，大的元素会排到最前面，然后我们看当前堆中的元素个数是否大于 k，大于的话就将首元素去掉，循环结束后我们返回堆中的首元素即为所求。

这题我们也可以用二分查找法来做，我们由于是有序矩阵，那么左上角的数字一定是最小的，而右下角的数字一定是最大的，所以这个是我们搜索的范围，然后我们算出中间数字 mid，由于矩阵中不同行之间的元素并不是严格有序的，所以我们要在每一行都查找一下 mid，我们使用 upper_bound，这个函数是查找第一个大于目标数的元素，如果目标数在比该行的尾元素大，则 upper_bound 返回该行元素的个数，如果目标数比该行首元素小，则 upper_bound 返回 0, 我们遍历完所有的行可以找出中间数是第几小的数，然后 k 比较，进行二分查找，left 和 right 最终会相等，并且会变成数组中第 k 小的数字。举个例子来说吧，比如数组为:

[1 2
12 100]
k = 3

那么刚开始 left = 1, right = 100, mid = 50, 遍历完 cnt = 3，此时 right 更新为 50
此时 left = 1, right = 50, mid = 25, 遍历完之后 cnt = 3, 此时 right 更新为 25
此时 left = 1, right = 25, mid = 13, 遍历完之后 cnt = 3, 此时 right 更新为 13
此时 left = 1, right = 13, mid = 7, 遍历完之后 cnt = 2, 此时 left 更新为 8
此时 left = 8, right = 13, mid = 10, 遍历完之后 cnt = 2, 此时 left 更新为 11
此时 left = 11, right = 12, mid = 11, 遍历完之后 cnt = 2, 此时 left 更新为 12
循环结束，left 和 right 均为 12，任意返回一个即可。

## 392. is subsequence

遍历母数组，设置子数组遍历 index，如果可以匹配上，那么 index++，如果子数组可以遍历完全，那么代表是子串。

## 400. 第 n 个数字

这道题目也是找规律的题目。

那么我们首先来分析自然数序列和其位数的关系，前九个数都是 1 位的，然后 10 到 99 总共 90 个数字都是两位的，100 到 999 这 900 个数都是三位的，那么这就很有规律了

规律就是先找到所寻找的数字所在的区间，比如在 10 ～ 99 之间。

然后找到这个区间最开始的数字，比如 10, 然后这个区间的每个数字的长度是 2,那么就(n-start)/len 就是我们所寻找的数字距离 start 的距离。移动到这个数字，确定这个数字的大小。

然后(n-start)%len 就是所寻找的数字里面第几个字母。就是最后的答案。

## 404. Sum of Left Leaves

这道题目是计算所有左叶子节点的总和，可以使用递归实现。

## 405. Convert a Number to Hexadecimal

对正数进行 16 进制转换，对负数以补码的形式进行 16 进制转换。

```c++
for(int i=0;num && i<8;i++){
    int item = num & 0x0f;
    if(item>=10){
        ans = map[item-10] + ans;
    }else{
        ans = to_string(item) + ans;
    }
    num = num >> 4;

}
```

使用位操作可以对正负数进行相同的操作。

## 406. queue reconstruction height

首先要确定好如何进行排序，要先安排个子高的同学，然后再去插入个子低的同学。所以排序方式就是先按照个子排序，对于个子相同的，按照第二个数字小的放在前面

## 409. Longest Palindrome

这道题目是根据给定的字符串，判断可以组成的最长回文序列的长度。

注意这里可以使用 hashmap 进行统计每一个字符串的个数。对于偶数，肯定可以加入进去，但是对于奇数，其中的偶数部分也是可以加入进去的。然后如果存在奇数，那么最后还要加 1.

## 413 Arithmetic Slices

这道题目是求出数字序列可以拆分成为等差递增序列的个数。

设计一个 dp 数组，其含义是以 A[i]数字为结尾的等差序列的个数。其递推关系式是 dp[i] = dp[i-1] + 1

然后再遍历 dp 数组求和，就可以得到所有的个数了。

## 415. Add Strings

这道题目是字符串相加，和题目 67 很类似，套路是一样的。

## 416. Partition Equal Subset Sum

动态规划题目，题目要求是确定是否可以将一个序列划分为两个和相等的子序列。

本质上是求是否可以在一个序列中，寻求一个子集，使得和可以等于一个数字 target.

设计一个数组 dp, dp[i]代表是否可能组成 i. 当遍历到 nums[i]和目标 target = j 的时候，dp[j]是否是 true，取决于 dp[ j-nums[i] ]是否为 true, 同时，如果 dp[j] 已经等于 true，当然还要保持 true, 因此，递推关系式是： dp[j] = dp[j - nums[i] ] || dp[j]

这里需要特别注意的是，第二个 for 循环一定要从 target 遍历到 nums[i]，而不能反过来，想想为什么呢？因为如果从 nums[i] 遍历到 target 的话，假如 nums[i]=1 的话，那么 [1, target] 中所有的 dp 值都是 true，因为 dp[0] 是 true，dp[1] 会或上 dp[0]，为 true，dp[2] 会或上 dp[1]，为 true，依此类推，完全使的 dp 数组失效了。

## 417. pacific atlantic water flow

可以使用 BFS 或者 DFS 来进行遍历，遍历就是先从左上边缘进行，对于遍历到的点将 P 相应位置赋值为 TRUE，对于右下角的边缘进行遍历，遍历到的点 A 相应位置赋值为 TRUE，然后再从头遍历一变，如果 P 和 A 都是 true，那么就是均可以流入太平洋和大西洋的点。

## 429. N 叉树的层序遍历

典型的数的层次遍历。

## 435. non overlapping intervals

先对待排序的区间进行排序，然后比较两个区间的是否有重叠。根据每个区间的 start 来做升序排序，然后开始要查找重叠区间，判断方法是看如果前一个区间的 end 大于后一个区间的 start，那么一定是重复区间，此时结果 res 自增 1，我们需要删除一个，那么此时究竟该删哪一个呢，为了保证总体去掉的区间数最小，我们去掉那个 end 值较大的区间。具体并不是删掉，而是使用索引指针的形式。

## 437. path sum 3

这道题让我们求二叉树的路径的和等于一个给定值，说明了这条路径不必要从根节点开始，可以是中间的任意一段，而且二叉树的节点值也是有正有负。那么我们可以用递归来做，相当于先序遍历二叉树，对于每一个节点都有记录了一条从根节点到当前节点到路径，同时用一个变量 curSum 记录路径节点总和，然后我们看 curSum 和 sum 是否相等，相等的话结果 res 加 1，不等的话我们来继续查看子路径和有没有满足题意的，做法就是每次去掉一个节点，看路径和是否等于给定值，注意最后必须留一个节点，不能全去掉了，因为如果全去掉了，路径之和为 0，而如果给定值刚好为 0 的话就会有问题

## 445. Add Two Numbers II

这道题是之前那道 Add Two Numbers 的拓展，我们可以看到这道题的最高位在链表首位置，如果我们给链表翻转一下的话就跟之前的题目一样了，这里我们来看一些不修改链表顺序的方法。由于加法需要从最低位开始运算，而最低位在链表末尾，链表只能从前往后遍历，没法取到前面的元素，那怎么办呢？

我们可以利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字了，我们首先遍历两个链表，将所有数字分别压入两个栈 s1 和 s2 中。

然后遍历栈不为空，直到两个栈都为空，设计一个指针 pre，不断插入新的节点到 pre 指针后面。

## 451.sort character by frequency

hashmap 可以得到计数与元素的映射，然后可以使用桶排序或者堆排序来进行计算，看具体的题目要求来决定选择哪一种方法

## 452. minimum number of arrows to burst balloons

类似于计算重叠区间个数，注意在计算重叠区间的时候，要计算公共重叠区间来进行比较，这个区间是逐渐缩小的。

## 455. assign cookies

贪心算法，将两个数组首先进行排序，然后在逐个安排

## 461. Hamming Distanc

对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可

## 462. Minimum Moves to Equal Array Elements II

这道题是之前那道 Minimum Moves to Equal Array Elements 的拓展，现在我们可以每次对任意一个数字加 1 或者减 1，让我们用最少的次数让数组所有值相等。一般来说这种题目是不能用暴力方法算出所有情况，因为 OJ 一般是不会答应的。那么这道题是否像上面一道题一样，有巧妙的方法呢？答案是肯定的。下面这种解法实际上利用了之前一道题 Best Meeting Point 的思想，是不感觉很 amazing，看似完全不相干的两道题，居然有着某种内部联系。我们首先给数组排序，那么我们最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个数字；如果是偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数实际上就是两端数字的距离，讲到这里发现是不是就和这道题 Best Meeting Point 的思路是一样了。那么我们就两对两对的累加它们的差值就可以了

## 464. 我能赢吗

这道题给了我们一堆数字，然后两个人，每人每次选一个数字，看数字总数谁先到给定值，有点像之前那道 Nim Game，但是比那题难度大。我刚开始想肯定说用递归啊，结果写完发现 TLE 了，后来发现我们必须要优化效率，使用 HashMap 来记录已经计算过的结果。我们首先来看如果给定的数字范围大于等于目标值的话，直接返回 true。如果给定的数字总和小于目标值的话，说明谁也没法赢，返回 false。然后我们进入递归函数，首先我们查找当前情况是否在 HashMap 中存在，有的话直接返回即可。我们使用一个整型数按位来记录数组中的某个数字是否使用过，我们遍历所有数字，将该数字对应的 mask 算出来，如果其和 used 相与为 0 的话，说明该数字没有使用过，我们看如果此时的目标值小于等于当前数字，说明已经赢了，或者调用递归函数，如果返回 false，说明也是第一个人赢了。为啥呢，因为当前已经选过数字了，此时就该对第二个人调用递归函数，只有返回的结果是 false，我们才能赢，所以此时我们 true，并返回 true。如果遍历完所有数字，标记 false，并返回 false

## 474. ones-and-zeros

这道题是一道典型的应用 DP 来解的题，如果我们看到这种求总数，而不是列出所有情况的题，十有八九都是用 DP 来解，重中之重就是在于找出递推式。如果你第一反应没有想到用 DP 来做，想得是用贪心算法来做，比如先给字符串数组排个序，让长度小的字符串在前面，然后遍历每个字符串，遇到 0 或者 1 就将对应的 m 和 n 的值减小，这种方法在有的时候是不对的，比如对于{"11", "01", "10"}，m=2，n=2 这个例子，我们将遍历完“11”的时候，把 1 用完了，那么对于后面两个字符串就没法处理了，而其实正确的答案是应该组成后面两个字符串才对。所以我们需要建立一个二维的 DP 数组，其中 dp[i][j]表示有 i 个 0 和 j 个 1 时能组成的最多字符串的个数，而对于当前遍历到的字符串，我们统计出其中 0 和 1 的个数为 zeros 和 ones，然后 dp[i - zeros][j - ones]表示当前的 i 和 j 减去 zeros 和 ones 之前能拼成字符串的个数，那么加上当前的 zeros 和 ones 就是当前 dp[i][j]可以达到的个数，我们跟其原有数值对比取较大值即可，所以递推式如下：

dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);

有了递推式，我们就可以很容易的写出代码

## 476. Number Complement

计算一个数字的反码，但是是部分反，不是全部反。

位操作，统计输入数字有效位的个数，然后得到对应个数的 1,将数组与这个对应个数的 1 构成的数字异或。因为与 1 异或相当于取反。

## 480. 滑动窗口中位数

使用滑动窗口和大小堆实现。

大小堆使用 multiset 实现起来比较方便，因为相比于 priority_queue, multiset 实现的大小堆可以访问中间的数字，而且可以查找中间的数字，而且可以遍历数字，因为其中的数字顺序都是有序的，所以大堆和小堆都是一样的数据结构就可以，只需要看你取最前面的还是最後面的，还可以使用 next(),以及 prev()函数移动指针。

求中位值，可以直接考虑使用大小堆。

这道题目关键是处理好删除数据，更关键是添加新数据的时候，如果维护好两个堆的大小关键，调整数字，使得小堆的 size 总是等于或仅大 1 大堆的数字。

## 485. Max Consecutive Ones

这道题目要计算连续 1 的个数。很简单，遍历即可。

## 494. target-sum

可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：

```
sum(P) - sum(N) = target

sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)

2 \* sum(P) = target + sum(nums)
```

因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。

这道题目本质上还是求一个序列里面子集等于 target，不过这里不是求是否存在，而是求有几个，和题目 416 很像。

主要就是 dp[i] = dp[i] + dp[ i-nums[j] ], 解释就是 dp[i]代表 target = i 的有几种组合法。

当前 dp[i]的个数，依赖于历史可以组成 dp[i]的个数，以及 dp[i-nums[j]]个数之和。

然后注意第二层遍历要倒序遍历。

## 501. Find Mode in Binary Search Tree

这道题让我们求二分搜索树中的众数，这里定义的二分搜索树中左根右结点之间的关系是小于等于的，有些题目中是严格小于的，所以一定要看清题目要求。所谓的众数就是出现最多次的数字，可以有多个，那么这道题比较直接点思路就是利用一个哈希表来记录数字和其出现次数之前的映射，然后维护一个变量 mx 来记录当前最多的次数值，这样在遍历完树之后，根据这个 mx 值就能把对应的元素找出来。那么用这种方法的话就不需要用到二分搜索树的性质了，随意一种遍历方式都可以。

题目中的 follow up 说了让我们不用除了递归中的隐含栈之外的额外空间，那么我们就不能用哈希表了，不过这也不难，由于是二分搜索树，那么我们中序遍历出来的结果就是有序的，这样我们只要比较前后两个元素是否相等，就等统计出现某个元素出现的次数，因为相同的元素肯定是都在一起的。我们需要一个结点变量 pre 来记录上一个遍历到的结点，然后 mx 还是记录最大的次数，cnt 来计数当前元素出现的个数，我们在中序遍历的时候，如果 pre 不为空，说明当前不是第一个结点，我们和之前一个结点值比较，如果相等，cnt 自增 1，如果不等，cnt 重置 1。如果此时 cnt 大于了 mx，那么我们清空结果 res，并把当前结点值加入结果 res，如果 cnt 等于 mx，那我们直接将当前结点值加入结果 res，然后 mx 赋值为 cnt。最后我们要把 pre 更新为当前结点

## 503. Next Greater Element II

这道题目和题目 739 很像，但是由于这里的数组是循环的，所以在遍历的时候需要循环遍历两次数组。

## 504. base-7

这道题目是将一个数字转化为 7 进制。

核心的递推公式是：

```c++
    while (item) {
        ans = to_string(item % 7) + ans;
        item = item / 7;
    }
```

注意负数的处理和 0 的处理。

## 513. Find Bottom Left Tree Value

二叉树的层次遍历。

## 516. 最长回文子序列

动态规划，类似于最长回文子串的设计思路。

## 518. coin-change-2

这道题目是计算可以凑出目标钱数目的所有硬币组合，这是一个完全背包问题，本质和题目 322 是一样的。

就是递推公式不一样,该题目的递推公式为：

```
    dp[i] = dp[i] + dp[i - coin];

```

需要注意的是，这是完全背包，需要正序遍历。

同时 dp[0] = 1

## 524. Longest Word in Dictionary through Deleting

这个类似于比较一个字符串是不是另一个字符串的子字符串。遍历字典中的字符串，如果当前遍历的字符串是 s 的子字符串，那么就赋值给 ans，然后继续遍历，如果当前遍历的字符串大小小于 ans 或者等于 ans 大小，但是字典排序在 ans 后面，那么就跳过，继续便利。

## 530. Minimum Absolute Difference in BST

计算 BST 两个节点的最小的差值，可以使用中序遍历实现，计算相邻节点的最小差值。

## 538. Convert BST to Greater Tree

这道题目可以使用中序遍历来实现，但是是反过来的中序遍历，这样逐渐从大到小遍历，这样就可以将比 n 大的所有数字都加起来。

## 540. single element in a sorted array

属于能够找到准确值的二分查找

## 543. Diameter of Binary Tree

这道题让我们求二叉树的直径，并告诉了我们直径就是两点之间的最远距离，根据题目中的例子也不难理解题意。我们再来仔细观察例子中的那两个最长路径[4,2,1,3] 和 [5,2,1,3]，我们转换一种角度来看，是不是其实就是根结点 1 的左右两个子树的深度之和呢。那么我们只要对每一个结点求出其左右子树深度之和，这个值作为一个候选值，然后再对左右子结点分别调用求直径对递归函数，这三个值相互比较，取最大的值更新结果 res，因为直径不一定会经过根结点，所以才要对左右子结点再分别算一次。为了减少重复计算，我们用哈希表建立每个结点和其深度之间的映射，这样某个结点的深度之前计算过了，就不用再次计算了

## 547. friend Circles

这道题目是查找联通区域的个数，可以使用 BFS 或者 DFS 来进行遍历，然后统计联通区域的个数即可。这道题目还有一种解法比较巧妙，就是 union find. 核心思想是设置一个数组 root,root 里面存储的是索引链接关系，开始给每一个对象的 root 索引都是自己，各个对象都是独立的，然后如果判断一个对象和另一个对象属于同一类，就把后者的 root 索引链接到前者。这样二者就变为了同一类，最后在总的类别数目上减一。

## 565 Array Nesting

这道题目是让我们计算嵌套数组的最大长度。可以找到的规律就是，如果是嵌套数组，那么一定是循环的，即首位链接嵌套的，那么我们就可以对于访问过的数字进行标记，对于每一个没有被访问过的数字，循环深入潜逃下去，直到发现回到了起点为止，计算他的长度。

## 566. Reshape the Matrix

这道题目是让我实现矩阵的 reshap 函数。我们就按照行进行依次遍历填入数据即可。

## 572. subtree-of-another-tree

这道题让我们求一个数是否是另一个树的子树，从题目中的第二个例子中可以看出，子树必须是从叶结点开始的，中间某个部分的不能算是子树，那么我们转换一下思路，是不是从 s 的某个结点开始，跟 t 的所有结构都一样，那么问题就转换成了判断两棵树是否相同，也就是 Same Tree 的问题了，这点想通了其实代码就很好写了，用递归来写十分的简洁，我们先从 s 的根结点开始，跟 t 比较，如果两棵树完全相同，那么返回 true，否则就分别对 s 的左子结点和右子结点调用递归再次来判断是否相同，只要有一个返回 true 了，就表示可以找得到

## 576. 出界的路径数

使用记忆化递归实现可以，但是注意特殊点判断，否则这道题目递推可能超时,可以参考代码实现里面的注释。或者使用动态规划来进行。[链接](https://www.cnblogs.com/grandyang/p/6927921.html)

## 583. Delete Operation for Two Strings

这道题目是计算多少次删除，可以让两个字符串相等。

本质上这道题目是求最长公共子序列，和题目 1143 是一样的。

## 594. Longest Harmonious Subsequence

我们还可以用 HashMap 来做，先遍历一遍，建立每个数字跟其出现次数之间的映射，然后再遍历每个数字的时候，只需在 HashMap 中查找该数字加 1 是否存在，存在就更新结果 res，这样更简单一些

## 605. can place flowers

这里类似于确定连续 0 的个数 n，然后计算(n-1)/2 即为可以种花的个数，但是要注意，这个是假设两边均种花，如果是位于边界的花，需要单独进行处理。左边界的条件可以事先设置起始 count=1,右边界的话，因为最后遍历完成之后，如果右边界是连续的 0,那么右面连续的 0 还没有统计进去，再统计进去的可以使用 n/2

## 617. merge two binary Trees

这道题目是将两个树进行合并。可以使用递归的思路进行合并。

## 628. maximun-product-of-three-numbers

这道题博主刚开始看的时候，心想直接排序，然后最后三个数字相乘不就完了，心想不会这么 Easy 吧，果然被 OJ 无情打脸，没有考虑到负数和 0 的情况。这道题给了数组的范围，至少三个，那么如果是三个的话，就无所谓了，直接相乘返回即可，但是如果超过了 3 个，而且有负数存在的话，情况就可能不一样，我们来考虑几种情况，如果全是负数，三个负数相乘还是负数，为了让负数最大，那么其绝对值就该最小，而负数排序后绝对值小的都在末尾，所以是末尾三个数字相乘，这个跟全是正数的情况一样。那么重点在于前半段是负数，后半段是正数，那么最好的情况肯定是两个最小的负数相乘得到一个正数，然后跟一个最大的正数相乘，这样得到的肯定是最大的数，所以我们让前两个数相乘，再和数组的最后一个数字相乘，就可以得到这种情况下的最大的乘积。实际上我们并不用分情况讨论数组的正负，只要把这两种情况的乘积都算出来，比较二者取较大值，就能涵盖所有的情况，从而得到正确的结果，

## 633. sum of aqure numbers

这道题目和 two sum 2 很类似，都是在排序好的数组内寻找两个数字，只不过一个是和，一个是平方和，可以使用双指针来实现，但是要注意的是右指针的初始化可以直接初始化为 target 的根号值

## 637. Average of Levels in Binary Tree

二叉树的层次遍历。

## 645. Set Mismatch

这道题给了我们一个长度为 n 的数组，说里面的数字是从 1 到 n，但是有一个数字重复出现了一次，从而造成了另一个数字的缺失，让我们找出重复的数字和缺失的数字。那么最直接的一种解法就是统计每个数字出现的次数了，然后再遍历次数数组，如果某个数字出现了两次就是重复数，如果出现了 0 次，就是缺失数。

另外一种思想就是通过交换数组元素，使得数组上的元素在正确的位置上。然后再遍历一遍数组，如果某一个位置的数字不符合要求，就可以得到我们想要的答案。

## 646. 最长数对链

这道题给了我们一些链对，规定了如果后面链对的首元素大于前链对的末元素，那么这两个链对就可以链起来，问我们最大能链多少个。那么我们想，由于规定了链对的首元素一定小于尾元素，我们需要比较的是某个链表的首元素和另一个链表的尾元素之间的关系，如果整个链对数组是无序的，那么就很麻烦，所以我们需要做的是首先对链对数组进行排序，按链对的尾元素进行排序，小的放前面。这样我们就可以利用 Greedy 算法进行求解了。我们可以用一个栈，先将第一个链对压入栈，然后对于后面遍历到的每一个链对，我们看其首元素是否大于栈顶链对的尾元素，如果大于的话，就将当前链对压入栈，这样最后我们返回栈中元素的个数即可，

我们可以对上面解法的空间进行优化，并不需要用栈来记录最长链上的每一个链对。而是用一个变量 end 来记录当前比较到的尾元素的值，初始化为最小值，然后遍历的时候，如果当前链对的首元素大于 end，那么结果 res 自增 1，end 更新为当前链对的尾元素

这道题论坛上最火的解法是用 DP 来做的，但是博主认为 Greedy 能解的就没有必要利用到 DP，而且还不省空间，有点杀鸡用牛刀的感觉

## 647. Palindromic substrings

这道题目是计算一个字符串的所有可能的所有字串有多少回文字符串。

关键点就是我们要对于输入的字符串进行拆分，一个回文字符串是有中间线的，这个中间线在原字符串的位置就是 0, 0.5, 1, 1.5, ... 如果是偶数回文，那么中间线就是包含 0.5, 如果是奇数回文，那么中间线就是纯整数。我们遍历这些中间线，然后向两侧遍历，如果相等，ans 就加 1,如果不相等直接 break.

## 650. 2 Keys Keyboard

这道题目关键是找出规律，

递推公式是 dp[i] = min(dp[i], dp[j] + i / j)

其中 i 是准备求的目标数字，j 是 i 的所有可以整除的因子。

## 653. Two Sum IV - Input is a BST

这道题又是一道 2sum 的变种题，博主一直强调，平生不识 TwoSum，刷尽 LeetCode 也枉然！只要是两数之和的题，一定要记得先尝试用 HashSet 来做，这道题只不过是把数组变成了一棵二叉树而已，换汤不换药，我们遍历二叉树就行，然后用一个 HashSet，在递归函数函数中，如果 node 为空，返回 false。如果 k 减去当前结点值在 HashSet 中存在，直接返回 true；否则就将当前结点值加入 HashSet，然后对左右子结点分别调用递归函数并且或起来返回即可

## 664. 奇怪的打印机

这道题说有一种奇怪的打印机每次只能打印一排相同的字符，然后可以在任意起点和终点位置之间打印新的字符，用来覆盖原有的字符。现在给了我们一个新的字符串，问我们需要几次可以正确的打印出来。题目中给了两个非常简单的例子，主要是帮助我们理解的。博主最开始想的方法是一种类似贪婪算法，先是找出出现次数最多的字符，然后算需要多少次变换能将所有其他字符都变成那个出现最多次的字符，结果 fail 了。然后又试了一种类似剥洋葱的方法，从首尾都分别找连续相同的字符，如果首尾字符相同，则两部分一起移去，否则就移去连续相同个数多的子序列，这种基于贪婪算法的解法还是 fail 了，所以这道题是典型的只能动态规划 Dynamic Programming，而不能用贪婪算法 Greedy Algorithm 的题。这道题的解题思路跟之前那道 Remove Boxes 很相似，博主在那个帖子中做了详细的讲解，是根据 fun4leetcode 大神的帖子写的，大神的思路对解这道题也相当有帮助。其实这道题并没有之前那道 Remove Boxes 难，移除盒子的题有隐含的条件需要加到重现关系中，大大地增加了题目的难度，非常地难想出来，这道题没有隐含条件都是个 Hard 题，那道题妥妥应该是 Super Hard。

好，话不多说，来分析这道题吧。思考的线索和思路很重要，不理解核心精髓，当背题侠是没用的，稍微变个形式又不会了，博主就经常是这样的-.-!!!。既然说了要用 DP 来做，先整个二维 dp 数组呗，其中 dp[i][j]表示打印出字符串[i, j]范围内字符的最小步数，难点就是找递推公式啦。遇到乍看去没啥思路的题，博主一般会先从简单的例子开始，看能不能分析出规律，从而找到解题的线索。首先如果只有一个字符，比如字符串是"a"的话，那么直接一次打印出来就行了。如果字符串是"ab"的话，那么我们要么先打印出"aa"，再改成"ab"，或者先打印出"bb"，再改成"ab"。同理，如果字符串是"abc"的话，就需要三次打印。那么一个很明显的特征是，如果没有重复的字符，打印的次数就是字符的个数。燃鹅这题的难点就是要处理有相同字符的情况，比如字符串是"aba"的时候，我们先打"aaa"的话，两步就搞定了，如果先打"bbb"的话，就需要三步。我们再来看一个字符串"abcb"，我们知道需要需要三步，我们看如果把这个字符串分成两个部分"a"和"bcb"，它们分别的步数是 1 和 2，加起来的 3 是整个的步数。而对于字符串"abba"，如果分成"a"和"bba"，它们分别的步数也是 1 和 2，但是总步数却是 2。这是因为分出的"a"和"bba"中的最后一个字符相同。对于字符串"abbac"，因为位置 0 上的 a 和位置 3 上的 a 相同，那么整个字符串的步数相当于"bb"和"ac"的步数之和，为 3。那么分析到这，是不是有点眉目了？我们关心的是字符相等的地方，对于[i, j]范围的字符，我们从 i+1 位置上的字符开始遍历到 j，如果和 i 位置上的字符相等，我们就以此位置为界，将[i+1, j]范围内的字符拆为两个部分，将二者的 dp 值加起来，和原 dp 值相比，取较小的那个。所以我们的递推式如下:

dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k][j] (s[k] == s[i] and i + 1 <= k <= j)
要注意一些初始化的值，dp[i][i]是 1，因为一个字符嘛，打印 1 次，还是就是在遍历 k 之前，dp[i][j]初始化为 1 + dp[i + 1][j]，为啥呢，可以看成在[i + 1, j]的范围上多加了一个 s[i]字符，最坏的情况就是加上的是一个不曾出现过的字符，步数顶多加 1 步，注意我们的 i 是从后往前遍历的，当然你可以从前往后遍历，参数对应好就行了

## 665. non decreasing array

判断 i 是否小于 i-1，如果小于，那么就需要修改，但是具体要修改哪个呢，需要看情况而定，如果 i-2 不存在，那么直接修改 i-1,如果 i-2 小于 i，那么修改 i-1,如果 i-2 大于 i，那么修改 i

## 667. Beautiful Arrangement II

这道题目让我们输出一个数组，数组由 1 ～ n 组成，但是每个相邻数字的之间的绝对值要满足在 1 ～ k 之间。

这道题目我们可以寻找一个规律，就是对于 1 ～ 8 这个为例，那么假设 k=7，那么就可以这么找规律：

1 8 2 7 3 6 4 5

就是设计两个变量，left = 1 和 right = 1+k 他俩交替填入到数组里面去，然后直到 left 和 right 相遇，然后处理一个边界问题即可。

## 669. Trim a Binary Search Tree

这道题让我们修剪一棵二叉搜索树，给了个边界范围[L, R], 所有不在这个范围内的结点应该被移除掉，但是仍需要保留二叉搜索树的性质，即左<根<右，有时候是小于等于。博主最开始的想法是先遍历一遍二叉树，将在返回内的结点值都放到一个数组后，遍历结束后再根据数组重建一棵二叉搜索树。这种方法会在某些 test case 上 fail 掉，可能会改变原来的二叉搜索树的结构，所以我们只能换一种思路。正确方法其实应该是在遍历的过程中就修改二叉树，移除不合题意的结点。当然对于二叉树的题，十有八九都是要用递归来解的。首先判断如果 root 为空，那么直接返回空即可。然后就是要看根结点是否在范围内，如果根结点值小于 L，那么返回对其右子结点调用递归函数的值；如果根结点大于 R，那么返回对其左子结点调用递归函数的值。如果根结点在范围内，将其左子结点更新为对其左子结点调用递归函数的返回值，同样，将其右子结点更新为对其右子结点调用递归函数的返回值。最后返回 root 即可，

## 671. Second Minimum Node In a Binary Tree

这道题让我们找二叉树中的第二小的结点值，并且给该二叉树做了一些限制，比如对于任意一个结点，要么其没有子结点，要么就同时有两个子结点，而且父结点值是子结点值中较小的那个，当然两个子结点值可以相等。那么直接上暴力搜索呗，根据该树的附加条件可知，根结点一定是最小的结点值 first，那么我们只要找出第二小的值 second 即可，初始化为整型的最大值。然后对根结点调用递归函数，将 first 和 second 当作参数传进去即可。在递归函数中，如果当前结点为空，直接返回，若当前结点孩值不等于 first，说明其肯定比 first 要大，然后我们看其是否比 second 小，小的话就更新 second，然后对当前结点的左右子结点分别调用递归函数即可

## 677. Map Sum Pairs

这道题目和题目 208 很像，不同的地方在于，对于每一个节点，我们设置一个 sum 参数，一个 isWord 参数，新添加一个字符串的时候，经过的每一个节点的 sum 都增加 val 数值。

如果到达字符串末尾，如果 isword 大于 0,说明之前访问过，那么再次遍历一下，这次遍历的时候就每次减去 val，到达末尾的时候更新 val。

sum 方法的时候，直接进行遍历到末尾，然后直接返回最后一个节点的 sum.

## 680. validPalindrome 2

双指针，首先正常判断是不是回文字符串，在出现两个字符不一致的情况下，继续判断里面的字符串是不是会问字符串，注意有交叉两种情况

## 684. Redundant Connection

这道题给我们了一个无向图，让删掉组成环的最后一条边，其实这道题跟之前那道 Graph Valid Tree 基本没什么区别，三种解法都基本相同。博主觉得老题稍微变一下就是一道新题，而 onsite 遇到原题的概率很小，大多情况下都会稍稍变一下，所以举一反三的能力真的很重要，要完全吃透一道题也不太容易，需要多下功夫。首先来看递归的解法，这种解法的思路是，每加入一条边，就进行环检测，一旦发现了环，就返回当前边。对于无向图，还是用邻接表来保存，建立每个结点和其所有邻接点的映射，由于两个结点之间不算有环，所以要避免这种情况 1->{2}, 2->{1} 的死循环，用一个变量 pre 记录上一次递归的结点，比如上一次遍历的是结点 1，那么在遍历结点 2 的邻接表时，就不会再次进入结点 1 了，这样有效的避免了死循环，使其能返回正确的结果

这道题最好的解法使用 Union Find 来做，论坛上清一色的都是用这种解法来做的，像博主用 DFS 和 BFS 这么清新脱俗的方法还真不多:) 其实 Union Find 的核心思想并不是很难理解，首先建立一个长度为 (n+1) 的数组 root，由于这道题并没有明确的说明 n 是多少，只是说了输入的二位数组的长度不超过 1000，那么 n 绝对不会超过 2000，加 1 的原因是由于结点值是从 1 开始的，而数组是从 0 开始的，懒得转换了，就多加一位得了。将这个数组都初始化为 -1，有些人喜欢初始化为 i，都可以。开始表示每个结点都是一个单独的组，所谓的 Union Find 就是要让结点之间建立关联，比如若 root[1] = 2，就表示结点 1 和结点 2 是相连的，root[2] = 3 表示结点 2 和结点 3 是相连的，如果此时新加一条边 [1, 3] 的话，我们通过 root[1] 得到 2，再通过 root[2] 得到 3，说明结点 1 有另一条路径能到结点 3，这样就说明环是存在的；如果没有这条路径，那么要将结点 1 和结点 3 关联起来，让 root[1] = 3 即可，

## 687. Longest Univalue Path

这道题让我们求最长的相同值路径，跟之前那道 Count Univalue Subtrees 十分的类似，解法也很类似。对于这种树的路径问题，递归是不二之选。在递归函数中，我们首先对其左右子结点调用递归函数，得到其左右子树的最大相同值路径长度，下面就要来看当前结点和其左右子结点之间的关系了，如果其左子结点存在且和当前节点值相同，则 left 自增 1，否则 left 重置 0；同理，如果其右子结点存在且和当前节点值相同，则 right 自增 1，否则 right 重置 0。然后用 left+right 来更新结果 res。而调用当前节点值的函数只能返回 left 和 right 中的较大值，因为如果还要跟父节点组 path，就只能在左右子节点中选一条 path，当然选值大的那个了，什么意思呢，举个例子来说吧，比如下面的这棵二叉树：

```
      1
     / \
    4   5
   / \   \
  4   4   5
 /
4
```

若此时的 node 是只有两个结点的第二层的那个结点 4，那么分别对其左右子结点调用递归，会得到 left = 1, right = 0，因为此时要跟结点 4 组成 path，所以肯定挑左子结点（有两个 4 的那条边），那你会问为啥不能连上右子结点的那个 4，这整条长度为 3 的 path（left+right，此时的 left 和 right 已经分别自增 1 了，left=2，right=1）其实我们已经用来更新过结果 res 了。需要注意的是我们的递归函数 helper 返回值的意义，并不是经过某个结点的最长路径的长度，最长路径长度保存在了结果 res 中，不是返回值，返回的是以该结点为终点的最长路径长度，这样回溯的时候，我们还可以继续连上其父结点，比如若根结点也是 4 的话，那么回溯到根结点的时候，路径长度又可以增加了

## 692. 前 K 个高频单词

这道题让我们求前 K 个高频词，跟之前那道题 Top K Frequent Elements 极其类似，换了个数据类型就又是一道新题。唯一的不同就是之前那道题对于出现频率相同的数字，没有顺序要求。而这道题对于出现频率相同的单词，需要按照字母顺序来排。但是解法都一样，还是用最小堆和桶排序的方法。首先来看最小堆的方法，思路是先建立每个单词和其出现次数之间的映射，然后把单词和频率的 pair 放进最小堆，如果没有相同频率的单词排序要求，我们完全可以让频率当作 pair 的第一项，这样 priority_queue 默认是以 pair 的第一项为 key 进行从大到小的排序，而当第一项相等时，又会以第二项由大到小进行排序，这样第一项的排序方式就与题目要求的相同频率的单词要按字母顺序排列不相符，当然我们可以在存入结果 res 时对相同频率的词进行重新排序处理，也可以对 priority_queue 的排序机制进行自定义，这里我们采用第二种方法，我们自定义排序机制，我们让 a.second > b.second，让小频率的词在第一位，然后当 a.second == b.second 时，我们让 a.first < b.first，这是让字母顺序大的排在前面（这里博主需要强调一点的是，priority_queue 的排序机制的写法和 vector 的 sort 的排序机制的写法正好顺序相反，同样的写法，用在 sort 里面就是频率小的在前面，不信的话可以自己试一下）。定义好最小堆后，我们首先统计单词的出现频率，然后组成 pair 排序最小堆之中，我们只保存 k 个 pair，超过了就把队首的 pair 移除队列，最后我们把单词放入结果 res 中即可

下面这种解法还是一种堆排序的思路，这里我们用 map，来建立次数和出现该次数所有单词的集合 set 之间的映射，这里也利用了 set 能自动排序的特性，当然我们还是需要首先建立每个单词和其出现次数的映射，然后将其组成 pair 放入 map 种，map 是从小到大排序的，这样我们从最后面取 pair，就是次数最大的，每次取出一层中所有的单词，如果此时的 k 大于该层的单词个数，就将整层的单词加入结果 res 中，否则就取前 K 个就行了，取完要更更新 K 值，如果 K 小于等于 0 了，就 break 掉，返回结果 res 即可，

## 693. Binary Number with Alternating Bits

直接位操作就可以了

## 695. max-area-of-island

这道题目类似于 1091 这道题目，不同之处在于这道题目仅有四个方向可以拓展。至于每一个子区域遍历一遍，可以使用 BFS 也可以使用 DFS。BFS 可以求出最短路径，而 DFS 对于求出可达性会更快一些。

## 696. Count Binary Substrings

这道题目是让我们判断有多少个子字符串包含相同的‘0’和‘1’，且‘0’和‘1’都聚集在一起。

我们可以遍历整个数组，当遇到数字变化的时候，就是判断的时候，用一个数字 pre 代表上一堆相同的数字个数，用 cur_num 代表当前的数字个数。二者的较小值也就是公共部分，添加到最终结果里面。然后交替 pre=cur_sum，直到遍历到最后结束。注意开头的细节即可。

## 697. Degree of an Array

这道题给了我们一个数组，定义数组的度为某个或某些数字出现最多的次数，要我们找最短的子数组使其和原数组拥有相同的度。那么我们肯定需要统计每个数字出现的次数，就要用哈希表来建立每个数字和其出现次数之间的映射。由于我们要求包含原度的最小长度的子数组，那么最好的情况就是子数组的首位数字都是统计度的数字，即出现最多的数字。那么我们肯定要知道该数字的第一次出现的位置和最后一次出现的位置，由于我们开始不知道哪些数字会出现最多次，所以我们统计所有数字的首尾出现位置，那么我们再用一个哈希表，建立每个数字和其首尾出现的位置。我们用变量 degree 来表示数组的度。好，现在我们遍历原数组，累加当前数字出现的次数，当某个数字是第一次出现，那么我们用当前位置的来更新该数字出现的首尾位置，否则只更新尾位置。每遍历一个数，我们都更新一下 degree。当遍历完成后，我们已经有了数组的度，还有每个数字首尾出现的位置，下面就来找出现次数为 degree 的数组，然后计算其首尾位置差加 1 就是 candidate 数组的长度，由于出现次数为 degree 的数字不一定只有一个，我们遍历所有的，找出其中最小的即可

## 714. Best Time to Buy and Sell Stock with Transaction Fee

这道题目和 309 带冷却期的股票交易很像，只是没有冷却期了，添加了每次的手续费。

还是设计两个数组 have[i]与 nothave[i].代表第 i 天手里有或没有股票的最大收益。

递推公式就是在每次卖出的时候加上手续费就可以了

```c++
have[i] = max(have[i-1], nothave[i-1] - prices[i]);
nothave[i] = max(nothave[i-1], have[i-1] + prices[i] - fee);
```

## 725. Split Linked List in Parts

这道题给我们一个链表和一个正数 k，让我们分割链表成 k 部分，尽可能的平均分割，如果结点不够了，就用空结点，比如例子 1 中的。如果无法平均分，那么多余的结点就按顺序放在子链表中，如例子 2 中所示。我们要知道每个部分结点的个数，才能将整个链表断开成子链表，所以我们首先要统计链表中结点的总个数，然后除以 k，得到的商 avg 就是能分成的部分个数，余数 ext 就是包含有多余的结点的子链表的个数。我们开始 for 循环，循环的结束条件是 i 小于 k 且 root 存在，要生成 k 个子链表，在循环中，先把头结点加入结果 res 中对应的位置，然后就要遍历该子链表的结点个数了，首先每个子链表都一定包含有 avg 个结点，这是之前除法得到的商，然后还要有没有多余结点，如果 i 小于 ext，就说明当前子链表还得有一个多余结点，然后我们将指针向后移动一个，

## 730. 统计不同回文子序列的个数

使用一个二维的 dp 数组，其中 dp[i][j] 表示子字符串 [i, j] 中的不同回文子序列的个数，初始化 dp[i][i] 为 1，因为任意一个单个字符就是一个回文子序列，其余均为 0。这里的更新顺序不是正向，也不是逆向，而是斜着更新，对于 "bccb" 的例子，其最终 dp 数组如下，可以看到其更新顺序分别是红-绿-蓝-橙。

b c c b
b 1 2 3 6
c 0 1 2 3
c 0 0 1 2
b 0 0 0 1

这样更新的好处是，更新当前位置时，其左，下，和左下位置的 dp 值均已存在，而当前位置的 dp 值需要用到这三个位置的 dp 值。观察上面的 dp 数组，可以发现当 S[i] 不等于 S[j] 的时候，dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]，即当前的 dp 值等于左边值加下边值减去左下值，因为算左边值的时候包括了左下的所有情况，而算下边值的时候也包括了左下值的所有情况，那么左下值就多算了一遍，所以要减去。而当 S[i] 等于 S[j] 的时候，情况就比较复杂了，需要分情况讨论，因为不知道中间还有几个和 S[i] 相等的值。举个简单的例子，比如 "aba" 和 "aaa"，当 i = 0, j = 2 的时候，两个字符串均有 S[i] == S[j]，此时二者都新增两个子序列 "a" 和 "aa"，但是 "aba" 中间的 "b" 就可以加到结果 res 中，而 "aaa" 中的 "a" 就不能加了，因为和外层的单独 "a" 重复了。我们的目标就要找到中间重复的 "a"。所以让 left = i + 1, right = j - 1，然后对 left 进行 while 循环，如果 left <= right, 且 S[left] != S[i] 的时候，left 向右移动一个；同理，对 right 进行 while 循环，如果 left <= right, 且 S[right] != S[i] 的时候，left 向左移动一个。这样最终 left 和 right 值就有三种情况：

1. 当 left > righ 时，说明中间没有和 S[i] 相同的字母了，就是 "aba" 这种情况，那么就有 dp[i][j] = dp[i + 1][j - 1] \* 2 + 2，其中 dp[i + 1][j - 1] 是中间部分的回文子序列个数，为啥要乘 2 呢，因为中间的所有子序列可以单独存在，也可以再外面包裹上字母 a，所以是成对出现的，要乘 2。加 2 的原因是外层的 "a" 和 "aa" 也要统计上。

2. 当 left = right 时，说明中间只有一个和 S[i] 相同的字母，就是 "aaa" 这种情况，那么有 dp[i][j] = dp[i + 1][j - 1] \* 2 + 1，其中乘 2 的部分跟上面的原因相同，加 1 的原因是单个字母 "a" 的情况已经在中间部分算过了，外层就只能再加上个 "aa" 了。

3. 当 left < right 时，说明中间至少有两个和 S[i] 相同的字母，就是 "aabaa" 这种情况，那么有 dp[i][j] = dp[i + 1][j - 1] \* 2 - dp[left + 1][right - 1]，其中乘 2 的部分跟上面的原因相同，要减去 left 和 right 中间部分的子序列个数的原因是其被计算了两遍，要将多余的减掉。比如说对于 "aabaa"，当检测到 S[0] == S[4] 时，是要根据中间的 "aba" 的回文序列个数来计算，共有四种，分别是 "a", "b", "aa", "aba"，将其分别在左右两边加上 a 的话，可以得到 "aaa", "aba", "aaaa", "aabaa"，我们发现 "aba" 出现了两次了，这就是要将 dp[2][2] (left = 1, right = 3) 减去的原因。

## 739. Daily Temperatures

这道题给了我们一个数组，让我们找下一个比当前数字大的数字的距离，我们研究一下题目中给的例子，发现数组是无序的，所以没法用二分法快速定位下一个大的数字，那么最先考虑的方法就是暴力搜索了，写起来没有什么难度，但是 OJ 并不答应。实际上这道题应该使用递增栈来做，栈如果输出的话，是逐步递增的，思路是这样的，我们遍历数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是递减栈了，所以我们取出栈顶元素，那么由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，那么我们直接求出下标差就是二者的距离了，然后继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来了。

## 744. find smallest letter greater than target

二分查找法

## 763. partition label

构建一个 hash 表，记录每一个字母最后出现的位置，然后再遍历一边字符串，定义一个变量表示当前出现的字符的最右边的边界，如果当前索引等于当前出现字符的最右边边界，那么就认为可以切割了

## 766. Toeplitz Matrix

这道题目是要进行矩阵的 index 的特殊遍历，关键是找到 index 的变化转折位置，处理好边界条件。

## 769. Max Chunks To Make Sorted

这道题目是让我们计算可以将一个数组分成几个部分，使得对每部分排序后数组就为有序。

找到规律就是遍历数组，寻找当前的最大值，如果当前已经遍历的数组最大值刚好等于他在排序后应该在的位置（也就是当前最大值等于下标 index）,那么就说明前面这部分的数组是可以单独独立出来进行排序的，以此类推即可。

## 784. 字母大小写全排列

使用类似于题目 78 里面 subset 的方法，可以很方便的实现。

处理一组给定元素的排列和组合。 Subsets 模式描述了一种有效的广度优先搜索（BFS）方法来处理所有这些问题。
例如给定一个数组 `[1, 5, 3]`

另外一种方法:
首先初始化一个空数组： [[ ]]
将第一个数字(1)添加到所有现有子集，以创建新的子集: `[[], [1]]`
继续添加`[[], [1], [5], [1, 5]] [[], [1], [5], [1, 5], [3], [1, 3], [5, 3], [1, 5, 3]]`

## 785. Is Graph Bipartite?

这道题目让我们判断一个图是不是二分图。二分图就是整个图的节点可以分为两组，同组的节点不相互连接，也就是一条边的两个节点不能时同一种节点。

我们可以涂色法，遍历整个图的节点，可以使用 BFS，也可以使用递归方法。

如果这个节点被访问过了，那么判断这个节点的颜色即将被涂上的颜色是不是相等，如果相等，那么对了，如果和即将被涂上的颜色不相等，那么就不是二分图。

如果这个节点没有被访问过，那么就直接涂色。

---

这道题博主在最开始做的时候，看了半天，愣是没弄懂输出数据的意思，博主开始以为给的是边，后来发现跟图对应不上，就懵逼了，后来是通过研究论坛上大神们的解法，才总算搞懂了题目的意思，原来输入数组中的 graph[i]，表示顶点 i 所有相邻的顶点，比如对于例子 1 来说，顶点 0 和顶点 1，3 相连，顶点 1 和顶点 0，2 相连，顶点 2 和结点 1，3 相连，顶点 3 和顶点 0，2 相连。这道题让我们验证给定的图是否是二分图，所谓二分图，就是可以将图中的所有顶点分成两个不相交的集合，使得同一个集合的顶点不相连。为了验证是否有这样的两个不相交的集合存在，我们采用一种很机智的染色法，大体上的思路是要将相连的两个顶点染成不同的颜色，一旦在染的过程中发现有两连的两个顶点已经被染成相同的颜色，说明不是二分图。这里我们使用两种颜色，分别用 1 和 -1 来表示，初始时每个顶点用 0 表示未染色，然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数，如果返回 false，那么说明不是二分图，则直接返回 false。如果循环退出后没有返回 false，则返回 true。在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回 true，否则返回 false。如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点，调用递归函数，如果返回 false 了，则当前递归函数的返回 false，循环结束返回 true

我们再来看一种迭代的解法，整体思路还是一样的，还是遍历整个顶点，如果未被染色，则先染色为 1，然后使用 BFS 进行遍历，将当前顶点放入队列 queue 中，然后 while 循环 queue 不为空，取出队首元素，遍历其所有相邻的顶点，如果相邻顶点未被染色，则染成和当前顶点相反的颜色，然后把相邻顶点加入 queue 中，否则如果当前顶点和相邻顶点颜色相同，直接返回 false，循环退出后返回 true，

## 877. 石子游戏。

这道题说是有偶数堆的石子，每堆的石子个数可能不同，但石子总数是奇数个。现在 Alex 和 Lee （不应该是 Alice 和 Bob 么？？）两个人轮流选石子堆，规则是每次只能选开头和末尾中的一堆，最终获得石子总数多的人获胜。若 Alex 先选，两个人都会一直做最优选择，问我们最终 Alex 是否能获胜。博主最先想到的方法是像 [Predict the Winner](http://www.cnblogs.com/grandyang/p/6369688.html) 中的那样，用个 player 变量来记录当前是哪个玩家在操作，若为 0，表示 Alex 在选，那么他只有两种选择，要么拿首堆，要么拿尾堆，两种情况分别调用递归，两个递归函数只要有一个能返回 true，则表示 Alex 可以获胜，还需要用个变量 cur0 来记录当前 Alex 的石子总数。同理，若 Lee 在选，即 player 为 1 的时候，也是只有两种选择，分别调用递归，两个递归函数只要有一个能返回 true，则表示 Lee 可以获胜，用 cur1 来记录当前 Lee 的石子总数。需要注意的是，当首堆或尾堆被选走了后，我们需要标记，这里就有两种方法，一种是从原 piles 中删除选走的堆（或者是新建一个不包含选走堆的数组），但是这种方法会包括大量的拷贝运算，无法通过 OJ。另一种方法是用两个指针 left 和 right，分别指向首尾的位置。当选取了首堆时，则 left 自增 1，若选了尾堆时，则 right 自减 1。这样就不用执行删除操作，或是拷贝数组了，大大的提高了运行效率

这道题也可以使用动态规划 Dynamic Programming 来做，由于玩家获胜的规则是拿到的石子数多，那么多的石子数就可以量化为 dp 值。所以我们用一个二维数组，其中 dp[i][j] 表示在区间 [i, j] 内 Alex 比 Lee 多拿的石子数，若为正数，说明 Alex 拿得多，若为负数，则表示 Lee 拿得多。则最终只要看 dp[0][n-1] 的值，若为正数，则 Alex 能获胜。现在就要找状态转移方程了，我们想，在区间 [i, j] 内要计算 Alex 比 Lee 多拿的石子数，在这个区间内，Alex 只能拿 i 或者 j 位置上的石子，那么当 Alex 拿了 piles[i] 的话，等于 Alex 多了 piles[i] 个石子，此时区间缩小成了 [i+1, j]，此时应该 Lee 拿了，此时根据我们以往的 DP 经验，应该调用子区间的 dp 值，没错，但这里 dp[i+1][j] 表示是在区间 [i+1, j] 内 Alex 多拿的石子数，但是若区间 [i+1, j] 内 Lee 先拿的话，其多拿的石子数也应该是 dp[i+1][j]，因为两个人都要最优化拿，那么 dp[i][j] 的值其实可以被 piles[i] - dp[i+1][j] 更新，因为 Alex 拿了 piles[i]，减去 Lee 多出的 dp[i+1][j]，就是区间 [i, j] 中 Alex 多拿的石子数。同理，假如 Alex 先拿 piles[j]，那么就用 piles[j] - dp[i][j-1] 来更新 dp[i][j]，则我们用二者的较大值来更新即可。注意开始的时候要把 dp[i][i] 都初始化为 piles[i]，还需要注意的是，这里的更新顺序很重要，是从小区间开始更新，在之前那道 [Burst Balloons](http://www.cnblogs.com/grandyang/p/5006441.html)，博主详细的讲了这种 dp 的更新顺序，可以去看看，

## 887. 鸡蛋掉落

使用二维数组，分别表示当前鸡蛋个数和楼层大小，然后分情况讨论。类似于斐波那契亚系列变种（无限情况），对于某次鸡蛋个数 i 和楼层大小 j，要遍历之前所有的楼层位置，找到释放鸡蛋的楼层位置，但是这样做属于三次循环，时间复杂度太高。观察发现，待比较的两个数字具有一个不断增大，一个不断减小的特点，所以最合适的点就是二者相等的时候，或者二者不会相等，互相错过的场景（在其附近），由于具有单调变化的特点，因此可以使用二分查找。

[链接](https://www.cnblogs.com/grandyang/p/11048142.html)

## 916. 单词子集

这道题定义了两个单词之间的一种子集合关系，就是说假如单词 b 中的每个字母都在单词 a 中出现了（包括重复字母），就说单词 b 是单词 a 的子集合。现在给了两个单词集合 A 和 B，让找出集合 A 中的所有满足要求的单词，使得集合 B 中的所有单词都是其子集合。配合上题目中给的一堆例子，意思并不难理解，根据子集合的定义关系，其实就是说若单词 a 中的每个字母的出现次数都大于等于单词 b 中每个字母的出现次数，单词 b 就一定是 a 的子集合。现在由于集合 B 中的所有单词都必须是 A 中某个单词的子集合，那么其实只要对于每个字母，都统计出集合 B 中某个单词中出现的最大次数，比如对于这个例子，B=["eo","oo"]，其中 e 最多出现 1 次，而 o 最多出现 2 次，那么只要集合 A 中有单词的 e 出现不少 1 次，o 出现不少于 2 次，则集合 B 中的所有单词一定都是其子集合。这就是本题的解题思路，这里使用一个大小为 26 的一维数组 charCnt 来统计集合 B 中每个字母的最大出现次数，而将统计每个单词的字母次数的操作放到一个子函数 helper 中，当 charCnt 数组更新完毕后，下面就开始检验集合 A 中的所有单词了。对于每个遍历到的单词，还是要先统计其每个字母的出现次数，然后跟 charCnt 中每个位置上的数字比较，只要均大于等于 charCnt 中的数字，就可以加入到结果 res 中了.

## 946. 验证栈序列

使用一个栈，和双指针。

如果压入队列等于弹出队列，那么直接 i++,j++;

如果压入队列和弹出队列不相等，那么分两种情况：

如果栈 s 不为空且头顶数字等于弹出队列，那么栈 s 弹出，且弹出队列加 1.
如果栈顶数字与弹出队列不相等，那么就栈 s 加入这个数字，且弹出队列加 1.

当遍历压入队列遍历完毕之后，如果栈 s 还有数字，那么就看看栈里面的数字和剩下的弹出队列是不是一样的。

## 986. 区间列表的交集

寻找区间的交集，可以设置两个指针，分别遍历两个数组，然后设定判断条件来是指针递增。

## 992. K 个不同整数的子数组

滑动窗口。

这道题目也是使用滑动窗口可以进行解决。

核心思想就是窗口右边界开拓，遇到限制条件了之后，那么开始收缩左边界。

使用两个关键变量：ans 最后的计数个数，cnt 滑动窗口里面不同数字的个数。

而且使用一个 hashmap 或者固定数组来计数，确定好计数条件来表示什么时候是新数字，什么时候不是新数字，以此区分来影响对 cnt 的效果。

这道题目和题目 76 很像。

## 1039. 多边形三角剖分的最低得分。

典型的区间 dp，关键还是找到大区间和子区间的递推关系，这道题目的递推关系是用两边的端点作为三角形底边，然后遍历区间纯内部的点作为三角形的顶点，将原来的大区间分为一个中间的三角形和两边的两个子区间情况。还要注意是一个环，需要使用取余%N 还处理环。

## 1091. shortest path in binary matrix

BFS。注意要对八个可能方向都要添加进队列，可能会访问回以前遍历过的地方，那么就如果是更短的路径，就要更新，如果不是更短的路径，就不要更新。

## 1143. longest-common-subsequence

对于两个子序列 S1 和 S2，找出它们最长的公共子序列。

定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：

当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。
当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。
