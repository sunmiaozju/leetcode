# leetcode

---

## 5. Longest Palindromic Substring

正常方法要区分奇偶串，但是也可以首先便遍历中间重复的字符，将奇数偶数串统一处理

或者使用动态规划的方法，dp[i][j]表示这个 ij 区间内的是回文字符串，那么有递推公式：

```c++
dp[i][j] = true
{
if i==j
if j-1<2 && s[i]==s[j]
if dp[i+1][j-1]==true && s[i]==s[j]
}
```

## 14. Longest Common Prefix

先排序，排好序找到最短的字符串的长度，然后遍历最短字符串长度，逐个比较排序后的第一个字符串和最后一个字符串

## 84. Maximal Rectangle

使用类似于 84 的解法，将原来的矩阵从上到下，具有连续 1 的累加起来，不连续的变为 0，这样没一个新产生的行使用 84 的解法计算，找到最大值。

## 91. Decode Ways

动态规划解法，使用一个数组 dp 表示记录的数据，列写出动态规划的递推方程，dp[i]=dp[i-1]+dp[i-2],不过这里的递推公式因为边界条件不一样而有所不同。

## 121. Best Time to Buy and Sell Stock

设置两个变量一个是最大利润，一个是到当前之间为止，前面的最小买入价格，然后遍历，再每次遍历的时候，计算当前卖出价格和前面最小买入价格的差价

## 125. Valid Palindrome

双指针，两边开始便利，但是要注意边界条件：如果一个字母也没有

## 136. single number

使用异或进行处理，异或满足交换率和结合率，可以将两个相同大小的数字消掉。

## 137. single number 2

使用标记的 ones twos 变量进行每一个位的 1 的个数的记录，也可以推广到其他的问题， 比如三个四个重复的数字

## 190. reverse bits

可以按照单独一个位一个位进行处理，也可以按照四个位或更多的位一起进行处理，但是要提前计算好对应的映射表

## 191. numbers of 1 bits

可以使用 n&(n-1)， 它的作用是可以把 n 的二进制表示中的最低位为 1 的改为 0，每更改一次计数器+1，直到 n=0 停止

## 198. house-robber

动态规划经典题目，递推公式是 dp[i] = max(dp[i-1], dp[i-2]+ nums[i]) 也可以修改为长量的额外空间算法，使用 pre 和 pre_pre 两个变量代表 dp[i-1]和 dp[i-2],并不断更新这两个变量
