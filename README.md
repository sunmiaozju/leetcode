# leetcode

---

## 5. Longest Palindromic Substring

正常方法要区分奇偶串，但是也可以首先便遍历中间重复的字符，将奇数偶数串统一处理

或者使用动态规划的方法，dp[i][j]表示这个 ij 区间内的是回文字符串，那么有递推公式：

```c++
dp[i][j] = true
{
if i==j
if j-1<2 && s[i]==s[j]
if dp[i+1][j-1]==true && s[i]==s[j]
}
```

## 6. zig-zag Conversion

o(n)time o(1)space 的算法是找到每一排循环的规律，是按照一定的周期循环的，或者可以使用 o(n)space ,不断的调整填充辅助数组的方向进行填充

## 7. reverse integer

这里要求时说如果 int 反转之后超如了有符号位 32 位大小的限制范围，那么就要返回 0，可以将结果先用 long 保存，然后在计算，并比较最后的结果是否超出了范围，并返回比较后的结果

## 9. Palindrome Number

这里如果是负数一定不是 Palindrome Number， 然后可以转化为字符串用双指针来做，也可以将数字进行反转，然后比较二者是否相等，或者可以比较一半，这种方法最快，就是将原本剩下砍掉的数字和新累乘的数字进行比较，知道新的数字大于剩下砍掉的数字，但是要注意边界条件，数字可以被 10 整除的是非常特殊的。

## 14. Longest Common Prefix

先排序，排好序找到最短的字符串的长度，然后遍历最短字符串长度，逐个比较排序后的第一个字符串和最后一个字符串

## 15. three-num

类似于 two num 题目的解法，但是不同的是要固定一个数字，然后找到另外两个数字，同时需要注意不要有重复的组合出现，解决方法是对于相同的数字，我们就将 index 跳过。

## 17. letter combination of a phone number

递归解法，类似于回溯的层级递归解法，整体的结构就是一个树形网络，在数行网络的最低端返回结果

## 78. subsets

递归，回溯法。要设置的变量 paths , path， index, nums(输入变量)

## 84. Maximal Rectangle

使用类似于 84 的解法，将原来的矩阵从上到下，具有连续 1 的累加起来，不连续的变为 0，这样没一个新产生的行使用 84 的解法计算，找到最大值。

## 87. scramble-string

可以使用递归或者动态规划的解法。（1）递归解法就是遍历不同的切割方法，但是每种情况不仅要左右对称比较，还要左右交叉比较。需要注意的是，要预先比较两个字符串字符是不是字母都一样，如果不一样肯定返回 false，这样可以加快速度，否则递归会超时。（2）DP 解法是设计三维的 dp 矩阵，三个维度分别是左串起始，右串起始，长度。递推方案是先解决所有长度为 1 的情况，遍历即可。然后对于长度高一层级的情况，都有低一层级的所有子情况推出来，具体递推公式就是左右对称比较和交叉比较，然后逐渐升高长度大小，最终得到最终结果。

动态规划的过程可以看作就是递归的逆过程，递推是从最高维度向下分解，但是分解的子情况可能有很多是重复的，这时候会增加计算量，动态规划就是找到里面的构建规律，然后逐渐推倒到我们想要的结果，是从最简单情况到复杂情况的过程，而递推是复杂情况逐渐分解到最简单情况的过程。

## 90. subsets 2

和 78 类似，修改的地方在于如果 nums 当前变量和前一个变量相等，则 paths 不添加这个 path

## 91. Decode Ways

动态规划解法，使用一个数组 dp 表示记录的数据，列写出动态规划的递推方程，dp[i]=dp[i-1]+dp[i-2],不过这里的递推公式因为边界条件不一样而有所不同。

## 121. Best Time to Buy and Sell Stock

设置两个变量一个是最大利润，一个是到当前之间为止，前面的最小买入价格，然后遍历，再每次遍历的时候，计算当前卖出价格和前面最小买入价格的差价

## 122. Best Time to Buy and Sell Stock 2

使用贪心的思想，只要后一天比前一天价格高，就会有利润，因此可以计算后一天比前一天收益大于 0 并累积

## 125. Valid Palindrome

双指针，两边开始便利，但是要注意边界条件：如果一个字母也没有

## 136. single number

使用异或进行处理，异或满足交换率和结合率，可以将两个相同大小的数字消掉。

## 137. single number 2

使用标记的 ones twos 变量进行每一个位的 1 的个数的记录，也可以推广到其他的问题， 比如三个四个重复的数字

## 167. two sum 2

这里是用双指针，不断判断当前两个数字的和与 target 的大小，然后移动相应的指针，指导两个指针相遇或者找到了两个匹配的数字

## 168. excel-sheet-column-title

这里就是注意将输入的数字减一进行处理，可以用递归也可以不用递归

## 169. majority-element

寻找数组中最大 majority，即数目超过 n/2 的个数的数字，这里可以使用很多种方法：（1）排序，返回中间值。（2）摩尔计数。即确定一个摩尔基数器，开始赋值为 0,当预选数字和当前遍历的数字相等的时候，计数器加一，当不相等的时候，计数器减一。如果计数器等于 0 了，那么赋值当前预选数字为当前遍历的数字。所有数字全部遍历完成后，预选数字即为 majority。（3）位操作。如果一个数字是 majority，那么每一个位上面的最大个数的位（0 或 1），组成的二进制数字就是 majority，可以遍历每一个位来寻找。（4）递归+分而治之。可以分左右两个子数组进行递归，返回的左右结果如果相同，那么就是 majority，如果不同，需要比较两个数字的个数谁大。（5）hash 表。可以按顺序遍历，存放到 hash 表中，如果相同就加一，直到个数超过 n/2 就返回。

## 171. excel-sheet-column-number

和 168 本质是一样的，就是注意字母的对应关系是：数字减一与相应字母对应

## 190. reverse bits

可以按照单独一个位一个位进行处理，也可以按照四个位或更多的位一起进行处理，但是要提前计算好对应的映射表

## 191. numbers of 1 bits

可以使用 n&(n-1)， 它的作用是可以把 n 的二进制表示中的最低位为 1 的改为 0，每更改一次计数器+1，直到 n=0 停止

## 198. house-robber

动态规划经典题目，递推公式是 dp[i] = max(dp[i-1], dp[i-2]+ nums[i]) 也可以修改为长量的额外空间算法，使用 pre 和 pre_pre 两个变量代表 dp[i-1]和 dp[i-2],并不断更新这两个变量
