# JZ-offer

[TOC]

---

## 面试题 03. 数组中重复的数字

这道题目是寻找数组里面重复的数字，使用 hashset 可以很简单的实现。

## 面试题 04. 二维数组中的查找

这道题目是对一个矩阵，该矩阵的行的数字逐渐增大，列的数字逐渐增大。

可以从矩阵左下角开始遍历，小的话往上走，大的话往右走。

## 面试题 05. 替换空格

直接遍历，然后在尾部追加对应的字符串即可。

## 面试题 06. 从尾到头打印链表

这道题目是让我们将链表的数组反着保存在数组里面，可以先按正序存储在数组里面，然后再翻转数组。本质可以看做翻转一个数组

## 面试题 07. 重建二叉树

这道题要求用先序和中序遍历来建立二叉树，跟之前那道 Construct Binary Tree from Inorder and Postorder Traversal 原理基本相同，针对这道题，由于先序的顺序的第一个肯定是根，所以原二叉树的根节点可以知道，题目中给了一个很关键的条件就是树中没有相同元素，有了这个条件就可以在中序遍历中也定位出根节点的位置，并以根节点的位置将中序遍历拆分为左右两个部分，分别对其递归调用原函数。

## 面试题 09. 用两个栈实现队列

使用两个栈实现队列，一个用于输入，一个用于输出。

## 面试题 10- I. 斐波那契数列

使用动态规划解决。

## 面试题 10- II. 青蛙跳台阶问题

使用动态规划解决。

## 面试题 11. 旋转数组的最小数字

遍历，找到最小值即可。

## 面试题 12. 矩阵中的路径

回溯法，递归遍历

## 面试题 13. 机器人的运动范围

BFS。 一个关键点是对已经访问的位置进行标记，但是注意要在刚开始加入到队列的时候就标记，不要在弹出的时候才标记。

## 面试题 15. 二进制中 1 的个数

位操作。但是注意 leetcode 的编译器如果初始位为 1,不允许左移。会报这个错误

"Line 11: Char 29: runtime error: left shift of negative value -2147483648"

## 面试题 16. 数值的整数次方

可以使用递归求解。一个数字的 n 次方，等于其 n/2 × n/2 × n%2。

## 面试题 17. 打印从 1 到最大的 n 位数

简单遍历即可。

## 面试题 18. 删除链表的节点

链表操作，注意设计一个头节点 pre 即可。

## 面试题 19. 正则表达式匹配

这道求正则表达式匹配的题和那道 Wildcard Matching 的题很类似，不同点在于\*的意义不同，在之前那道题中，\*表示可以代替任意个数的字符，而这道题中的\*表示之前那个字符可以有 0 个，1 个或是多个，就是说，字符串 a\*b，可以表示 b 或是 aaab，即 a 的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归 Recursion 来解，大概思路如下：

- 若 p 为空，若 s 也为空，返回 true，反之返回 false。

- 若 p 的长度为 1，若 s 长度也为 1，且相同或是 p 为 '.' 则返回 true，反之返回 false。

- 若 p 的第二个字符不为\*，若此时 s 为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。

- 若 p 的第二个字符为\\\*，进行下列循环，条件是若 s 不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配 s 和去掉前两个字符的 p（这样做的原因是假设此时的星号的作用是让前面的字符出现 0 次，验证是否匹配），若匹配返回 true，否则 s 去掉首字母（因为此时首字母匹配了，我们可以去掉 s 的首字母，而 p 由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。

- 返回调用递归函数匹配 s 和去掉前两个字符的 p 的结果（这么做的原因是处理星号无法匹配的内容，比如 s="ab", p="a\*b"，直接进入 while 循环后，我们发现 "ab" 和 "b" 不匹配，所以 s 变成 "b"，那么此时跳出循环后，就到最后的 return 来比较 "b" 和 "b" 了，返回 true。再举个例子，比如 s="", p="a\*"，由于 s 为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）。

## 面试题 20. 表示数值的字符串

这道题目很繁琐，要根据特殊情况一个一个补充。

关键：

1. 开始去除左右两侧的空格。
2. 设置几个标志位：数字，符号，自然底数，小数点，数字是否在自然底数后面，然后分门别类按照各自的类型处理
3. 对于第一个字符单独处理
4. 对于没有数字的字符串肯定不是，这个要单独判断一下

## 面试题 21. 调整数组顺序使奇数位于偶数前面

双指针

## 面试题 21. 调整数组顺序使奇数位于偶数前面

快慢指针

## 面试题 24. 反转链表

反转链表，设置一个头节点，然后逐个插入。

## 面试题 25. 合并两个排序的链表

设置头指针。

## 面试题 26. 树的子结构

要查找树 A 是否存在和树 B 结构一样的子树，我们可以分成两步：第一步在树 A 中找到和树 B 的根节点的值一样的节点 R,第二步再判断树 A 中以 R 为根节点的子树是不是包含和树 B 一样的结构

第一步在树 A 中查找与根节点一样的节点，实际上就是树的遍历，可以采用递归的方式，
第二步是判断树 A 中以 R 为根节点的子树是不是和树 B 具有相同的结构。同样，我们也可以用递归的思路来考虑：如果节点 R 的值和树 B 的根节点不相同，则以 R 为根节点的子树和树 B 肯定不具有相同的结点；如果它们的值相同，则递归地判断它们各自的左右节点的值是不是相同。递归的终止条件是我们到达了树Ａ或者树 B 的叶节点

## 面试题 27. 二叉树的镜像

递归。

## 面试题 28. 对称的二叉树

使用递归的思想可以判断，判断右子树的左子树是不是相等，判断左子树的右子树是不是相等。

## 面试题 29. 顺时针打印矩阵

以框的形式进行遍历。

## 面试题 30. 包含 min 函数的栈

使用两个栈

## 面试题 31. 栈的压入、弹出序列

使用一个栈，和双指针。

如果压入队列等于弹出队列，那么直接 i++,j++;

如果压入队列和弹出队列不相等，那么分两种情况：

如果栈 s 不为空且头顶数字等于弹出队列，那么栈 s 弹出，且弹出队列加 1.
如果栈顶数字与弹出队列不相等，那么就栈 s 加入这个数字，且弹出队列加 1.

当遍历压入队列遍历完毕之后，如果栈 s 还有数字，那么就看看栈里面的数字和剩下的弹出队列是不是一样的。

## 面试题 32 - I. 从上到下打印二叉树

二叉树层次遍历

## 面试题 32 - II. 从上到下打印二叉树 II

二叉树层次遍历

## 面试题 32 - III. 从上到下打印二叉树 III

二叉树层次遍历 + 反转数组

## 面试题 33. 二叉搜索树的后序遍历序列

递归处理。

## 面试题 34. 二叉树中和为某一值的路径

回溯法

## 面试题 35. 复杂链表的复制

思路 用一个哈希表表示映射关系：键是原节点，值是复制的节点。

整体算法流程是：

第一次遍历，复制每个节点和 next 指针，并且保存“原节点-复制节点”的映射关系
第二次遍历，通过哈希表获得节点对应的复制节点，更新 random 指针

我们也 1 可以使用递归的解法，写起来相当的简洁，还是需要一个 HashMap 来建立原链表结点和拷贝链表结点之间的映射。在递归函数中，首先判空，若为空，则返回空指针。然后就是去 HashMap 中查找是否已经在拷贝链表中存在了该结点，是的话直接返回。否则新建一个拷贝结点 res，然后建立原结点和该拷贝结点之间的映射，然后就是要给拷贝结点的 next 和 random 指针赋值了，直接分别调用递归函数即可

## 面试题 36. 二叉搜索树与双向链表

这道题给了一个二叉搜索树，让我们将其转化为双向链表。并且题目中给了一个带图的例子，帮助理解。题目本身并不难理解，仔细观察下给的示例图。首先，转化成双向链表的每个结点都有 left 和 right 指针指向左右两个结点，不管其原来是否是叶结点还是根结点，转换后统统没有区别。其次，这是个循环双向链表，即首尾结点是相连的，原先的二叉搜索树中的最左结点和最右结点，现在也互相连接起来了。最后，返回的结点不再是原二叉搜索树的根结点 root 了，而是最左结点，即最小值结点。

好，发现了上述规律后，来考虑如何破题。根据博主多年经验，跟二叉搜索树有关的题，肯定要利用其性质，即左<根<右，即左子结点值小于根结点值小于右子结点值。而且十有八九都得用中序遍历来解，因为中序遍历的顺序就是左根右啊，跟性质吻合。观察到原二叉搜索树中结点 4 连接着结点 2 和结点 5，而在双向链表中，连接的是结点 3 和结点 5，这就是为啥要用中序遍历了，因为只有中序遍历，结点 3 之后才会遍历到结点 4，这时候可以将结点 3 和结点 4 串起来。决定了用中序遍历之后，就要考虑是迭代还是递归的写法，博主建议写递归的，一般写起来都比较简洁，而且递归是解树类问题的神器啊，十有八九都是用递归，一定要熟练掌握。再写中序遍历之前，其实还有难点，因为需要把相邻的结点连接起来，所以需要知道上一个遍历到的结点是什么，所以用一个变量 pre，来记录上一个遍历到的结点。还需要一个变量 head，来记录最左结点，这样的话，在递归函数中，先判空，之后对左子结点调用递归，这样会先一直递归到最左结点，此时如果 head 为空的话，说明当前就是最左结点，赋值给 head 和 pre，对于之后的遍历到的结点，那么可以和 pre 相互连接上，然后 pre 赋值为当前结点 node，再对右子结点调用递归即可

虽然说树类问题首推递归解法，但是中序遍历是可以用迭代来写的，可以参见博主之前的博客 Binary Tree Inorder Traversal。迭代写法借用了栈，其实整体思路和递归解法没有太大的区别，递归的本质也是将断点存入栈中，以便之后可以返回，这里就不多讲解.

## 面试题 37. 序列化二叉树

这道题让我们对二叉树进行序列化和去序列化的操作。序列化就是将一个数据结构或物体转化为一个位序列，可以存进一个文件或者内存缓冲器中，然后通过网络连接在相同的或者另一个电脑环境中被还原，还原的过程叫做去序列化。现在让我们来序列化和去序列化一个二叉树，并给了我们例子。这题有两种解法，分别为先序遍历的递归解法和层序遍历的非递归解法。先来看先序遍历的递归解法，非常的简单易懂，我们需要接入输入和输出字符串流 istringstream 和 ostringstream，对于序列化，我们从根节点开始，如果节点存在，则将值存入输出字符串流，然后分别对其左右子节点递归调用序列化函数即可。对于去序列化，我们先读入第一个字符，以此生成一个根节点，然后再对根节点的左右子节点递归调用去序列化函数即可，

另一种方法是层序遍历的非递归解法，这种方法略微复杂一些，我们需要借助 queue 来做，本质是 BFS 算法，也不是很难理解，就是 BFS 算法的常规套路稍作修改即可

## 面试题 38. 字符串的排列

回溯法，这道题目还涉及了重复被选元素的情况，以及每个备选元素只能使用一次的情况。

可以参考回溯法总结的第一条：

回溯法主要用于解决组合问题，要求一般是最后的组合不能有重复。

设置的 help 函数主要参数包括 paths, path, 其他。

需要注意的事项主要有两点：

> 1. 如何添加新的元素到 path，这里面涉及到给定的备选参数是否是重复的，如果备选参数是重复的，那么，注意每次添加新的数字的时候，前一个数字如果没有访问标记（visit）,并且当前数字等于前一个数字，说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此直接跳过。同时，如果当前数字已经被标记（visit）,那么不重复访问，也直接跳过。

> 2. 要求一般是组合不能有重复，对于组合来说，2,2,3 和 2,3,2 是同一种组合。一般做法就是先对备选参数进行排序，然后，添加新的元素到 path 的时候，新添加的数字要大于 path 的末尾数字。

> 3. 最后就是要确定 path 可以添加到 paths 的条件。

## 面试题 39. 数组中出现次数超过一半的数字

可以先排序返回中间值，也可以使用 hash 表

## 面试题 40. 最小的 k 个数

使用大顶對实现

## 面试题 41. 数据流中的中位数

这道题给我们一个数据流，让我们找出中位数，由于数据流中的数据并不是有序的，所以我们首先应该想个方法让其有序。如果我们用 vector 来保存数据流的话，每进来一个新数据都要给数组排序，很不高效。所以之后想到用 multiset 这个数据结构，是有序保存数据的，但是它不能用下标直接访问元素，找中位数也不高效。这里用到的解法十分巧妙，我们使用大小堆来解决问题，其中大堆保存右半段较大的数字，小堆保存左半段较小的数组。这样整个数组就被中间分为两段了，由于堆的保存方式是由大到小，我们希望大堆里面的数据是从小到大，这样取第一个来计算中位数方便。我们用到一个小技巧，就是存到大堆里的数先取反再存，这样由大到小存下来的顺序就是实际上我们想要的从小到大的顺序。当大堆和小堆中的数字一样多时，我们取出大堆小堆的首元素求平均值，当小堆元素多时，取小堆首元素为中位数

## 面试题 42. 连续子数组的最大和

动态规划。dp[i]表示以 nums[i]为结尾的子数组的最大值。

## 面试题 43. 1 ～ n 整数中 1 出现的次数

可以找到规律如下所示：
找到两个关键数字：
a : 0 1 20 300 4000
b : 1 10 100 1000 10000

举例来说：413

其中 b 是如果当前数字最高位等于 1, 那么当前数字的最高位贡献 1 的个数,比如 100 ～ 199 里面一共 100 个 1, 10 ～ 19 里面 10 个 1，1 自己是一个 1。

a 是当前数组排除最高位贡献的 1 的个数，比如 0 ～ 999 里面 300 个 1，0 ～ 99 里面 20 个 1, 0 ～ 9 里面 1 个 1

他们的递推关系就是：
a = a \* 10 + b;
b = b \* 10;

那么拿 413 为例， 首先判断 3,大于 1,那么说明跨过了 1 的门槛，1 对应的区域全部满贯，而 1 没有更小的数字跟在后面了，那么直接就是 1 + 0;

然后判断 1,这个就是 10 位数了，这个数字等于 1,那么就说明 1 对应的区域没有满贯，这里就是他后面的数组加 1 个，也就是 3+1=4 个，然后在计算最高位贡献的 1,也就是 1\*1

然后判断 4, 这个就是百位数了，这个数字大于 1,说明 1 对应的区域已经满贯，也就是 100, 这个代表最高位等于 1 的个数，（100 ～ 199），然后计算尾部数字的 1 的个数，4 \* 20

所有加起来就是结果。

```c
class Solution {
public:
    int countDigitOne(int n) {
        int origin = n;
        int ans = 0;
        long a = 0, b = 1;
        while(n){
            int item = n % 10;
            if(item>1){
                ans += item * a + b;
            }else if(item==1) {
                ans += item * a + origin%b + 1;
            }

            a = a * 10 + b;
            b = b * 10;

            n = n / 10;
        }
        return ans;
    }
};
```

具体思想可以参考下面的文字：

---

问题转化：求最高位对 1 的贡献

例如输入 193，我们先求 1 作为最高位百位对 1 的贡献，假设结果为 c1；然后我们将最高位 1 去掉，就剩下 93，我们求得 9 作为最高位十位对 1 的贡献为 c2；同样我们去掉 9，剩下 3，我们求得 3 作为最高位个位对 1 的贡献是 c3。

答案 = c1+c2+c3。

那么，求最高位对 1 的贡献怎么求？按照以下规则：

如果 n 是一位数，最高位就是个位，由于没有比它更小的位数了，因此对 1 的贡献只有它本身（个位），如果各位数字大于等于 1，贡献是 1，否则贡献是 0。

如果 n 是两位数，最高位就是十位，因此对 1 的贡献分为 0-9 部分和十位本身。0-9：贡献能力是 1，再乘以十位数字就是贡献 1 的个数；十位：贡献大小取决于十位数字，如果十位数字大于 1，则贡献是 10；如果十位数字等于 1，则贡献是去掉十位剩下的数+1。

如果 n 是三位数，最高位就是百位，因此对 1 的贡献分为 0-99 部分和它本身（百位）。0-99：贡献能力是 20，百位：贡献大小取决于百位数字，如果百位数字大于 1，则贡献是 100；如果十位数字等于 1，则贡献是去掉百位剩下的数+1。

如果 n 是四位数，最高位就是千位，因此对 1 的贡献分为 0-999 部分和它本身（千位）。0-999：贡献能力是 300，千位：贡献大小取决于千位数字，如果千位数字大于 1，则贡献是 1000；如果千位数字等于 1，则贡献是去掉千位剩下的数+1。

以此类推。。。。。。

举例说明：

413 是个三位数，我们这里先考虑最高位 4 对 1 的贡献，根据上面的规则，贡献分为 0-99 部分和百位部分。首先说 0-99 贡献：0-99 共有 20 个 1，因此贡献能力是 20，一共有四次（0-99、100-199、200-299、300-399），因此共贡献了 4\*20 = 80 个 1；再说百位的贡献：因为百位数字是 4，大于 1，因此百位的贡献就是 100（100、101、...、199 一共 100 个 1）。因此，413 最高位 4 对 1 的贡献 = 4\*20+100 = 180。

你可能会问，这里只考虑最高位 4 对 1 的贡献，后面的 13 也贡献了 6 个 1。没错，因此我们考虑完 4 对 1 的贡献后，就要将 4 剔除，剩下 13，我们还是套用此规则。

13 是个两位数，我们这里只找最高位 1 对 1 的贡献，根据上面的规则，贡献分为 0-9 部分和十位部分。首先说 0-9 贡献：0-9 共有 1 个 1，因此贡献能力是 1，一共有 1 次（0-9），因此共贡献了 1\*1 = 1 个 1；再说十位的贡献：因为十位数字等于 1，因此十位的贡献就是 4（去掉十位后的数+1，即 3+1，因为 10、11、12、13）。因此，13 最高位十位 1 对 1 的贡献 = 1\*1+4 = 5。

然后剔除十位 1，只剩下 3 了，3 大于等于 1，所以贡献是 1。

因此结果 = 4\*20+100 + 1\*1+4 + 1 = 186。

0-9 贡献能力是 1，0-99 贡献能力是 20，0-999 贡献能力是 300，0-9999 贡献能力是 4000，这是怎么来的？

1\*10+10 = 20；20\*10+10^2=300；300\*10+10^3=400。就是这个规律。

## 面试题 44. 数字序列中某一位的数字

这道题目也是找规律的题目。

那么我们首先来分析自然数序列和其位数的关系，前九个数都是 1 位的，然后 10 到 99 总共 90 个数字都是两位的，100 到 999 这 900 个数都是三位的，那么这就很有规律了

规律就是先找到所寻找的数字所在的区间，比如在 10 ～ 99 之间。

然后找到这个区间最开始的数字，比如 10, 然后这个区间的每个数字的长度是 2,那么就(n-start)/len 就是我们所寻找的数字距离 start 的距离。移动到这个数字，确定这个数字的大小。

然后(n-start)%len 就是所寻找的数字里面第几个字母。就是最后的答案。

## 面试题 45. 把数组排成最小的数

这道题目可以自定义排序规则来进行计算。

注意自定义的排序规则函数要是静态函数。

对于自定义的排序规则可以这么理解：

> sort 函数默认是递增序列排序的，也就是说 compare 这个自定义排序规则的函数，如果返回 true,说明不改变原来的规则，也就是和默认一样，compare 的第一个参数是小于第二个参数的。

> 如果返回 false, 那么说明改变原来的规则，原来的规则是 a 是小于 b 的，那么现在就是 a 是大于 b 的。

## 面试题 46. 把数字翻译成字符串

动态规划。

## 面试题 47. 礼物的最大价值

动态规划。

## 面试题 48. 最长不含重复字符的子字符串

这道题目可以使用 128 位的数组来表示所有字符。开始每个字符都初始化为-1

然后这道题目其实是维护一个滑动窗口。滑动窗口左边界是 left，右边界是当前访问的数组下标。

left 的更新策略是：

left = max(left, dp[s[i]]);

也就是如果一直没有被访问过重复字符，那么 left 一直维持在-1;窗口的长度就是当前下标减去 left.

然后如果出现了重复字符，那么 left 就立刻更新到之前出现的位置。

注意 dp[]数组也在不断更新，保存的是上一次出现的位置，用于如果出现了重复，可以把滑动窗口左边界拉过来。

## 面试题 49. 丑数

这道题是之前那道 Ugly Number 的拓展，这里让找到第 n 个丑陋数，还好题目中给了很多提示，基本上相当于告诉我们解法了，根据提示中的信息，丑陋数序列可以拆分为下面 3 个子列表：

(1) 1x2, 2x2, 2x2, 3x2, 3x2, 4x2, 5x2...
(2) 1x3, 1x3, 2x3, 2x3, 2x3, 3x3, 3x3...
(3) 1x5, 1x5, 1x5, 1x5, 2x5, 2x5, 2x5...
仔细观察上述三个列表，可以发现每个子列表都是一个丑陋数分别乘以 2，3，5，而要求的丑陋数就是从已经生成的序列中取出来的，每次都从三个列表中取出当前最小的那个加入序列

## 面试题 50. 第一个只出现一次的字符

hash_map 统计数字，然后再回来重头遍历一遍字符串，找到计数为 1 的那个即可

## 面试题 51. 数组中的逆序对

对于这道题，要求找出一个数组中的所有逆序对的个数。

这里借用评论区的解答：

所谓逆序对，就是指在数组给定的顺序中，如果排在前面的数字的值比排在它后面的数字的值大，那么这两个数字就构成一个逆序对。

我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿 ta 和后面的每一个数字作比较，否则时间复杂度就是 O(n^2)，因此我们可以考虑先比较两个相邻的数字。

(a) 把长度为 4 的数组分解成两个长度为 2 的子数组；
(b) 把长度为 2 的数组分解成两个成都为 1 的子数组；
(c) 把长度为 1 的子数组 合并、排序并统计逆序对 ；
(d) 把长度为 2 的子数组合并、排序，并统计逆序对；

在上图（a）和（b）中，我们先把数组分解成两个长度为 2 的子数组，再把这两个子数组分别拆成两个长度为 1 的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为 1 的子数组{7}、{5}中 7 大于 5，因此（7,5）组成一个逆序对。同样在第二对长度为 1 的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。

接下来我们统计两个长度为 2 的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。

我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图 b 所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为 copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。

## 面试题 52. 两个链表的第一个公共节点

双指针，遍历两次。

## 面试题 53 - I. 在排序数组中查找数字 I

二分查找。

类型是查找第一个大于等于 target 的数值的位置。

## 面试题 53 - II. 0 ～ n-1 中缺失的数字

二分查找

类型是特殊条件的二分查找，查找的规律和查找第一个大于等于 target 的数值的位置一样。

## 面试题 54. 二叉搜索树的第 k 大节点

中序遍历思想，但是是反过来的中序遍历。
