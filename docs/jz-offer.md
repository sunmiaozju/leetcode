# JZ-offer

[TOC]

---

## 面试题 03. 数组中重复的数字

这道题目是寻找数组里面重复的数字，使用 hashset 可以很简单的实现。

## 面试题 04. 二维数组中的查找

这道题目是对一个矩阵，该矩阵的行的数字逐渐增大，列的数字逐渐增大。

可以从矩阵左下角开始遍历，小的话往上走，大的话往右走。

## 面试题 05. 替换空格

直接遍历，然后在尾部追加对应的字符串即可。

## 面试题 06. 从尾到头打印链表

这道题目是让我们将链表的数组反着保存在数组里面，可以先按正序存储在数组里面，然后再翻转数组。本质可以看做翻转一个数组

## 面试题 07. 重建二叉树

这道题要求用先序和中序遍历来建立二叉树，跟之前那道 Construct Binary Tree from Inorder and Postorder Traversal 原理基本相同，针对这道题，由于先序的顺序的第一个肯定是根，所以原二叉树的根节点可以知道，题目中给了一个很关键的条件就是树中没有相同元素，有了这个条件就可以在中序遍历中也定位出根节点的位置，并以根节点的位置将中序遍历拆分为左右两个部分，分别对其递归调用原函数。

## 面试题 09. 用两个栈实现队列

使用两个栈实现队列，一个用于输入，一个用于输出。

## 面试题 10- I. 斐波那契数列

使用动态规划解决。

## 面试题 10- II. 青蛙跳台阶问题

使用动态规划解决。

## 面试题 11. 旋转数组的最小数字

遍历，找到最小值即可。

## 面试题 12. 矩阵中的路径

回溯法，递归遍历

## 面试题 13. 机器人的运动范围

BFS。 一个关键点是对已经访问的位置进行标记，但是注意要在刚开始加入到队列的时候就标记，不要在弹出的时候才标记。

## 面试题 15. 二进制中 1 的个数

位操作。但是注意 leetcode 的编译器如果初始位为 1,不允许左移。会报这个错误

"Line 11: Char 29: runtime error: left shift of negative value -2147483648"

## 面试题 16. 数值的整数次方

可以使用递归求解。一个数字的 n 次方，等于其 n/2 × n/2 × n%2。

## 面试题 17. 打印从 1 到最大的 n 位数

简单遍历即可。

## 面试题 18. 删除链表的节点

链表操作，注意设计一个头节点 pre 即可。

## 面试题 19. 正则表达式匹配

这道求正则表达式匹配的题和那道 Wildcard Matching 的题很类似，不同点在于\*的意义不同，在之前那道题中，\*表示可以代替任意个数的字符，而这道题中的\*表示之前那个字符可以有 0 个，1 个或是多个，就是说，字符串 a\*b，可以表示 b 或是 aaab，即 a 的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归 Recursion 来解，大概思路如下：

- 若 p 为空，若 s 也为空，返回 true，反之返回 false。

- 若 p 的长度为 1，若 s 长度也为 1，且相同或是 p 为 '.' 则返回 true，反之返回 false。

- 若 p 的第二个字符不为\*，若此时 s 为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。

- 若 p 的第二个字符为\\\*，进行下列循环，条件是若 s 不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配 s 和去掉前两个字符的 p（这样做的原因是假设此时的星号的作用是让前面的字符出现 0 次，验证是否匹配），若匹配返回 true，否则 s 去掉首字母（因为此时首字母匹配了，我们可以去掉 s 的首字母，而 p 由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。

- 返回调用递归函数匹配 s 和去掉前两个字符的 p 的结果（这么做的原因是处理星号无法匹配的内容，比如 s="ab", p="a\*b"，直接进入 while 循环后，我们发现 "ab" 和 "b" 不匹配，所以 s 变成 "b"，那么此时跳出循环后，就到最后的 return 来比较 "b" 和 "b" 了，返回 true。再举个例子，比如 s="", p="a\*"，由于 s 为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）。

## 面试题 20. 表示数值的字符串

这道题目很繁琐，要根据特殊情况一个一个补充。

关键：

1. 开始去除左右两侧的空格。
2. 设置几个标志位：数字，符号，自然底数，小数点，数字是否在自然底数后面，然后分门别类按照各自的类型处理
3. 对于第一个字符单独处理
4. 对于没有数字的字符串肯定不是，这个要单独判断一下

## 面试题 21. 调整数组顺序使奇数位于偶数前面

双指针

## 面试题 21. 调整数组顺序使奇数位于偶数前面

快慢指针

## 面试题 24. 反转链表

反转链表，设置一个头节点，然后逐个插入。

## 面试题 25. 合并两个排序的链表

设置头指针。

## 面试题 26. 树的子结构

要查找树 A 是否存在和树 B 结构一样的子树，我们可以分成两步：第一步在树 A 中找到和树 B 的根节点的值一样的节点 R,第二步再判断树 A 中以 R 为根节点的子树是不是包含和树 B 一样的结构

第一步在树 A 中查找与根节点一样的节点，实际上就是树的遍历，可以采用递归的方式，
第二步是判断树 A 中以 R 为根节点的子树是不是和树 B 具有相同的结构。同样，我们也可以用递归的思路来考虑：如果节点 R 的值和树 B 的根节点不相同，则以 R 为根节点的子树和树 B 肯定不具有相同的结点；如果它们的值相同，则递归地判断它们各自的左右节点的值是不是相同。递归的终止条件是我们到达了树Ａ或者树 B 的叶节点

## 面试题 27. 二叉树的镜像

递归。

## 面试题 28. 对称的二叉树

使用递归的思想可以判断，判断右子树的左子树是不是相等，判断左子树的右子树是不是相等。

## 面试题 29. 顺时针打印矩阵

以框的形式进行遍历。

## 面试题 30. 包含 min 函数的栈

使用两个栈

## 面试题 31. 栈的压入、弹出序列

使用一个栈，和双指针。

如果压入队列等于弹出队列，那么直接 i++,j++;

如果压入队列和弹出队列不相等，那么分两种情况：

如果栈 s 不为空且头顶数字等于弹出队列，那么栈 s 弹出，且弹出队列加 1.
如果栈顶数字与弹出队列不相等，那么就栈 s 加入这个数字，且弹出队列加 1.

当遍历压入队列遍历完毕之后，如果栈 s 还有数字，那么就看看栈里面的数字和剩下的弹出队列是不是一样的。

## 面试题 32 - I. 从上到下打印二叉树

二叉树层次遍历

## 面试题 32 - II. 从上到下打印二叉树 II

二叉树层次遍历

## 面试题 32 - III. 从上到下打印二叉树 III

二叉树层次遍历 + 反转数组

## 面试题 33. 二叉搜索树的后序遍历序列

递归处理。

## 面试题 34. 二叉树中和为某一值的路径

回溯法

## 面试题 35. 复杂链表的复制

思路 用一个哈希表表示映射关系：键是原节点，值是复制的节点。

整体算法流程是：

第一次遍历，复制每个节点和 next 指针，并且保存“原节点-复制节点”的映射关系
第二次遍历，通过哈希表获得节点对应的复制节点，更新 random 指针

我们也 1 可以使用递归的解法，写起来相当的简洁，还是需要一个 HashMap 来建立原链表结点和拷贝链表结点之间的映射。在递归函数中，首先判空，若为空，则返回空指针。然后就是去 HashMap 中查找是否已经在拷贝链表中存在了该结点，是的话直接返回。否则新建一个拷贝结点 res，然后建立原结点和该拷贝结点之间的映射，然后就是要给拷贝结点的 next 和 random 指针赋值了，直接分别调用递归函数即可

## 面试题 36. 二叉搜索树与双向链表

这道题给了一个二叉搜索树，让我们将其转化为双向链表。并且题目中给了一个带图的例子，帮助理解。题目本身并不难理解，仔细观察下给的示例图。首先，转化成双向链表的每个结点都有 left 和 right 指针指向左右两个结点，不管其原来是否是叶结点还是根结点，转换后统统没有区别。其次，这是个循环双向链表，即首尾结点是相连的，原先的二叉搜索树中的最左结点和最右结点，现在也互相连接起来了。最后，返回的结点不再是原二叉搜索树的根结点 root 了，而是最左结点，即最小值结点。

好，发现了上述规律后，来考虑如何破题。根据博主多年经验，跟二叉搜索树有关的题，肯定要利用其性质，即左<根<右，即左子结点值小于根结点值小于右子结点值。而且十有八九都得用中序遍历来解，因为中序遍历的顺序就是左根右啊，跟性质吻合。观察到原二叉搜索树中结点 4 连接着结点 2 和结点 5，而在双向链表中，连接的是结点 3 和结点 5，这就是为啥要用中序遍历了，因为只有中序遍历，结点 3 之后才会遍历到结点 4，这时候可以将结点 3 和结点 4 串起来。决定了用中序遍历之后，就要考虑是迭代还是递归的写法，博主建议写递归的，一般写起来都比较简洁，而且递归是解树类问题的神器啊，十有八九都是用递归，一定要熟练掌握。再写中序遍历之前，其实还有难点，因为需要把相邻的结点连接起来，所以需要知道上一个遍历到的结点是什么，所以用一个变量 pre，来记录上一个遍历到的结点。还需要一个变量 head，来记录最左结点，这样的话，在递归函数中，先判空，之后对左子结点调用递归，这样会先一直递归到最左结点，此时如果 head 为空的话，说明当前就是最左结点，赋值给 head 和 pre，对于之后的遍历到的结点，那么可以和 pre 相互连接上，然后 pre 赋值为当前结点 node，再对右子结点调用递归即可

虽然说树类问题首推递归解法，但是中序遍历是可以用迭代来写的，可以参见博主之前的博客 Binary Tree Inorder Traversal。迭代写法借用了栈，其实整体思路和递归解法没有太大的区别，递归的本质也是将断点存入栈中，以便之后可以返回，这里就不多讲解.

## 面试题 37. 序列化二叉树

这道题让我们对二叉树进行序列化和去序列化的操作。序列化就是将一个数据结构或物体转化为一个位序列，可以存进一个文件或者内存缓冲器中，然后通过网络连接在相同的或者另一个电脑环境中被还原，还原的过程叫做去序列化。现在让我们来序列化和去序列化一个二叉树，并给了我们例子。这题有两种解法，分别为先序遍历的递归解法和层序遍历的非递归解法。先来看先序遍历的递归解法，非常的简单易懂，我们需要接入输入和输出字符串流 istringstream 和 ostringstream，对于序列化，我们从根节点开始，如果节点存在，则将值存入输出字符串流，然后分别对其左右子节点递归调用序列化函数即可。对于去序列化，我们先读入第一个字符，以此生成一个根节点，然后再对根节点的左右子节点递归调用去序列化函数即可，

另一种方法是层序遍历的非递归解法，这种方法略微复杂一些，我们需要借助 queue 来做，本质是 BFS 算法，也不是很难理解，就是 BFS 算法的常规套路稍作修改即可

## 面试题 38. 字符串的排列

回溯法，这道题目还涉及了重复被选元素的情况，以及每个备选元素只能使用一次的情况。

可以参考回溯法总结的第一条：

回溯法主要用于解决组合问题，要求一般是最后的组合不能有重复。

设置的 help 函数主要参数包括 paths, path, 其他。

需要注意的事项主要有两点：

> 1. 如何添加新的元素到 path，这里面涉及到给定的备选参数是否是重复的，如果备选参数是重复的，那么，注意每次添加新的数字的时候，前一个数字如果没有访问标记（visit）,并且当前数字等于前一个数字，说明这两个数字是位于同一个地位的相同数字，不能使用两次，因此直接跳过。同时，如果当前数字已经被标记（visit）,那么不重复访问，也直接跳过。

> 2. 要求一般是组合不能有重复，对于组合来说，2,2,3 和 2,3,2 是同一种组合。一般做法就是先对备选参数进行排序，然后，添加新的元素到 path 的时候，新添加的数字要大于 path 的末尾数字。

> 3. 最后就是要确定 path 可以添加到 paths 的条件。

## 面试题 39. 数组中出现次数超过一半的数字

可以先排序返回中间值，也可以使用 hash 表

## 面试题 40. 最小的 k 个数

使用大顶對实现

## 面试题 41. 数据流中的中位数

这道题给我们一个数据流，让我们找出中位数，由于数据流中的数据并不是有序的，所以我们首先应该想个方法让其有序。如果我们用 vector 来保存数据流的话，每进来一个新数据都要给数组排序，很不高效。所以之后想到用 multiset 这个数据结构，是有序保存数据的，但是它不能用下标直接访问元素，找中位数也不高效。这里用到的解法十分巧妙，我们使用大小堆来解决问题，其中大堆保存右半段较大的数字，小堆保存左半段较小的数组。这样整个数组就被中间分为两段了，由于堆的保存方式是由大到小，我们希望大堆里面的数据是从小到大，这样取第一个来计算中位数方便。我们用到一个小技巧，就是存到大堆里的数先取反再存，这样由大到小存下来的顺序就是实际上我们想要的从小到大的顺序。当大堆和小堆中的数字一样多时，我们取出大堆小堆的首元素求平均值，当小堆元素多时，取小堆首元素为中位数

## 面试题 42. 连续子数组的最大和

动态规划。dp[i]表示以 nums[i]为结尾的子数组的最大值。

## 面试题 43. 1 ～ n 整数中 1 出现的次数

可以找到规律如下所示：
找到两个关键数字：
a : 0 1 20 300 4000
b : 1 10 100 1000 10000

举例来说：413

其中 b 是如果当前数字最高位等于 1, 那么当前数字的最高位贡献 1 的个数,比如 100 ～ 199 里面一共 100 个 1, 10 ～ 19 里面 10 个 1，1 自己是一个 1。

a 是当前数组排除最高位贡献的 1 的个数，比如 0 ～ 999 里面 300 个 1，0 ～ 99 里面 20 个 1, 0 ～ 9 里面 1 个 1

他们的递推关系就是：
a = a \* 10 + b;
b = b \* 10;

那么拿 413 为例， 首先判断 3,大于 1,那么说明跨过了 1 的门槛，1 对应的区域全部满贯，而 1 没有更小的数字跟在后面了，那么直接就是 1 + 0;

然后判断 1,这个就是 10 位数了，这个数字等于 1,那么就说明 1 对应的区域没有满贯，这里就是他后面的数组加 1 个，也就是 3+1=4 个，然后在计算最高位贡献的 1,也就是 1\*1

然后判断 4, 这个就是百位数了，这个数字大于 1,说明 1 对应的区域已经满贯，也就是 100, 这个代表最高位等于 1 的个数，（100 ～ 199），然后计算尾部数字的 1 的个数，4 \* 20

所有加起来就是结果。

```c
class Solution {
public:
    int countDigitOne(int n) {
        int origin = n;
        int ans = 0;
        long a = 0, b = 1;
        while(n){
            int item = n % 10;
            if(item>1){
                ans += item * a + b;
            }else if(item==1) {
                ans += item * a + origin%b + 1;
            }

            a = a * 10 + b;
            b = b * 10;

            n = n / 10;
        }
        return ans;
    }
};
```

具体思想可以参考下面的文字：

---

问题转化：求最高位对 1 的贡献

例如输入 193，我们先求 1 作为最高位百位对 1 的贡献，假设结果为 c1；然后我们将最高位 1 去掉，就剩下 93，我们求得 9 作为最高位十位对 1 的贡献为 c2；同样我们去掉 9，剩下 3，我们求得 3 作为最高位个位对 1 的贡献是 c3。

答案 = c1+c2+c3。

那么，求最高位对 1 的贡献怎么求？按照以下规则：

如果 n 是一位数，最高位就是个位，由于没有比它更小的位数了，因此对 1 的贡献只有它本身（个位），如果各位数字大于等于 1，贡献是 1，否则贡献是 0。

如果 n 是两位数，最高位就是十位，因此对 1 的贡献分为 0-9 部分和十位本身。0-9：贡献能力是 1，再乘以十位数字就是贡献 1 的个数；十位：贡献大小取决于十位数字，如果十位数字大于 1，则贡献是 10；如果十位数字等于 1，则贡献是去掉十位剩下的数+1。

如果 n 是三位数，最高位就是百位，因此对 1 的贡献分为 0-99 部分和它本身（百位）。0-99：贡献能力是 20，百位：贡献大小取决于百位数字，如果百位数字大于 1，则贡献是 100；如果十位数字等于 1，则贡献是去掉百位剩下的数+1。

如果 n 是四位数，最高位就是千位，因此对 1 的贡献分为 0-999 部分和它本身（千位）。0-999：贡献能力是 300，千位：贡献大小取决于千位数字，如果千位数字大于 1，则贡献是 1000；如果千位数字等于 1，则贡献是去掉千位剩下的数+1。

以此类推。。。。。。

举例说明：

413 是个三位数，我们这里先考虑最高位 4 对 1 的贡献，根据上面的规则，贡献分为 0-99 部分和百位部分。首先说 0-99 贡献：0-99 共有 20 个 1，因此贡献能力是 20，一共有四次（0-99、100-199、200-299、300-399），因此共贡献了 4\*20 = 80 个 1；再说百位的贡献：因为百位数字是 4，大于 1，因此百位的贡献就是 100（100、101、...、199 一共 100 个 1）。因此，413 最高位 4 对 1 的贡献 = 4\*20+100 = 180。

你可能会问，这里只考虑最高位 4 对 1 的贡献，后面的 13 也贡献了 6 个 1。没错，因此我们考虑完 4 对 1 的贡献后，就要将 4 剔除，剩下 13，我们还是套用此规则。

13 是个两位数，我们这里只找最高位 1 对 1 的贡献，根据上面的规则，贡献分为 0-9 部分和十位部分。首先说 0-9 贡献：0-9 共有 1 个 1，因此贡献能力是 1，一共有 1 次（0-9），因此共贡献了 1\*1 = 1 个 1；再说十位的贡献：因为十位数字等于 1，因此十位的贡献就是 4（去掉十位后的数+1，即 3+1，因为 10、11、12、13）。因此，13 最高位十位 1 对 1 的贡献 = 1\*1+4 = 5。

然后剔除十位 1，只剩下 3 了，3 大于等于 1，所以贡献是 1。

因此结果 = 4\*20+100 + 1\*1+4 + 1 = 186。

0-9 贡献能力是 1，0-99 贡献能力是 20，0-999 贡献能力是 300，0-9999 贡献能力是 4000，这是怎么来的？

1\*10+10 = 20；20\*10+10^2=300；300\*10+10^3=400。就是这个规律。

## 面试题 44. 数字序列中某一位的数字

这道题目也是找规律的题目。

那么我们首先来分析自然数序列和其位数的关系，前九个数都是 1 位的，然后 10 到 99 总共 90 个数字都是两位的，100 到 999 这 900 个数都是三位的，那么这就很有规律了

规律就是先找到所寻找的数字所在的区间，比如在 10 ～ 99 之间。

然后找到这个区间最开始的数字，比如 10, 然后这个区间的每个数字的长度是 2,那么就(n-start)/len 就是我们所寻找的数字距离 start 的距离。移动到这个数字，确定这个数字的大小。

然后(n-start)%len 就是所寻找的数字里面第几个字母。就是最后的答案。

## 面试题 45. 把数组排成最小的数

这道题目可以自定义排序规则来进行计算。

注意自定义的排序规则函数要是静态函数。

对于自定义的排序规则可以这么理解：

> sort 函数默认是递增序列排序的，也就是说 compare 这个自定义排序规则的函数，如果返回 true,说明不改变原来的规则，也就是和默认一样，compare 的第一个参数是小于第二个参数的。

> 如果返回 false, 那么说明改变原来的规则，原来的规则是 a 是小于 b 的，那么现在就是 a 是大于 b 的。

## 面试题 46. 把数字翻译成字符串

动态规划。

## 面试题 47. 礼物的最大价值

动态规划。

## 面试题 48. 最长不含重复字符的子字符串

这道题目可以使用 128 位的数组来表示所有字符。开始每个字符都初始化为-1

然后这道题目其实是维护一个滑动窗口。滑动窗口左边界是 left，右边界是当前访问的数组下标。

left 的更新策略是：

left = max(left, dp[s[i]]);

也就是如果一直没有被访问过重复字符，那么 left 一直维持在-1;窗口的长度就是当前下标减去 left.

然后如果出现了重复字符，那么 left 就立刻更新到之前出现的位置。

注意 dp[]数组也在不断更新，保存的是上一次出现的位置，用于如果出现了重复，可以把滑动窗口左边界拉过来。

## 面试题 49. 丑数

这道题是之前那道 Ugly Number 的拓展，这里让找到第 n 个丑陋数，还好题目中给了很多提示，基本上相当于告诉我们解法了，根据提示中的信息，丑陋数序列可以拆分为下面 3 个子列表：

(1) 1x2, 2x2, 2x2, 3x2, 3x2, 4x2, 5x2...
(2) 1x3, 1x3, 2x3, 2x3, 2x3, 3x3, 3x3...
(3) 1x5, 1x5, 1x5, 1x5, 2x5, 2x5, 2x5...
仔细观察上述三个列表，可以发现每个子列表都是一个丑陋数分别乘以 2，3，5，而要求的丑陋数就是从已经生成的序列中取出来的，每次都从三个列表中取出当前最小的那个加入序列

## 面试题 50. 第一个只出现一次的字符

hash_map 统计数字，然后再回来重头遍历一遍字符串，找到计数为 1 的那个即可

## 面试题 51. 数组中的逆序对

对于这道题，要求找出一个数组中的所有逆序对的个数。

这里借用评论区的解答：

所谓逆序对，就是指在数组给定的顺序中，如果排在前面的数字的值比排在它后面的数字的值大，那么这两个数字就构成一个逆序对。

我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿 ta 和后面的每一个数字作比较，否则时间复杂度就是 O(n^2)，因此我们可以考虑先比较两个相邻的数字。

(a) 把长度为 4 的数组分解成两个长度为 2 的子数组；
(b) 把长度为 2 的数组分解成两个成都为 1 的子数组；
(c) 把长度为 1 的子数组 合并、排序并统计逆序对 ；
(d) 把长度为 2 的子数组合并、排序，并统计逆序对；

在上图（a）和（b）中，我们先把数组分解成两个长度为 2 的子数组，再把这两个子数组分别拆成两个长度为 1 的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为 1 的子数组{7}、{5}中 7 大于 5，因此（7,5）组成一个逆序对。同样在第二对长度为 1 的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。

接下来我们统计两个长度为 2 的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。

我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图 b 所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为 copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。

## 面试题 52. 两个链表的第一个公共节点

双指针，遍历两次。

## 面试题 53 - I. 在排序数组中查找数字 I

二分查找。

类型是查找第一个大于等于 target 的数值的位置。

## 面试题 53 - II. 0 ～ n-1 中缺失的数字

二分查找

类型是特殊条件的二分查找，查找的规律和查找第一个大于等于 target 的数值的位置一样。

## 面试题 54. 二叉搜索树的第 k 大节点

中序遍历思想，但是是反过来的中序遍历。

## 面试题 55 - I. 二叉树的深度

递归

## 面试题 55 - II. 平衡二叉树

递归

## 面试题 56 - I. 数组中数字出现的次数

将原来的数组分为两组，使用两个数字分别进行异或。

## 面试题 56 - II. 数组中数字出现的次数 II

位操作，设计一个 32 长度的数组，代表位元素，统计每个位上面 1 的数字，如果等于 3，就清零，最后剩下的就是所求数字的位形式。

注意就是 & 操作的时候要家括号 比如 (a & b) != 0

## 面试题 57. 和为 s 的两个数字

双指针。

## 面试题 57 - II. 和为 s 的连续正数序列

双指针。

双指针技术，就是相当于有一个窗口，窗口的左右两边就是两个指针，根据窗口内值之和来确定窗口的位置和宽度。

两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小

由于是连续的，差为 1 的一个序列，那么求和公式是(a0+an)\*n/2

相等，那么就将窗口范围的所有数添加进结果集

如果当前窗口内的值之和小于 sum，那么右边窗口右移一下

如果当前窗口内的值之和大于 sum，那么左边窗口右移一下

## 面试题 58 - I. 翻转单词顺序

方法一：先全部反转，然后对每个单词进行反转。

方法二：使用 istringstream 可以很方便的对带空格的字符进行分割。

## 面试题 58 - II. 左旋转字符串

两次翻转。

## 面试题 59 - I. 滑动窗口的最大值

这道题给定了一个数组，还给了一个窗口大小 k，让我们每次向右滑动一个数字，每次返回窗口内的数字的最大值。难点就在于如何找出滑动窗口内的最大值（这不废话么，求得不就是这个），那么最狂野粗暴的方法就是每次遍历窗口，找最大值呗，OJ 说呵呵哒，no way！我们希望窗口内的数字是有序的，但是每次给新窗口排序又太费时了，所以最好能有一种类似二叉搜索树的结构，可以在 lgn 的时间复杂度内完成插入和删除操作，那么使用 STL 自带的 multiset 就能满足我们的需求，这是一种基于红黑树的数据结构，可以自动对元素进行排序，又允许有重复值，完美契合。所以我们的思路就是，遍历每个数字，即窗口右移，若超过了 k，则需要把左边界值删除，这里不能直接删除 nums[i-k]，因为集合中可能有重复数字，我们只想删除一个，而 erase 默认是将所有和目标值相同的元素都删掉，所以我们只能提供一个 iterator，代表一个确定的删除位置，先通过 find() 函数找到左边界 nums[i-k] 在集合中的位置，再删除即可。然后将当前数字插入到集合中，此时看若 i >= k-1，说明窗口大小正好是 k，就需要将最大值加入结果 res 中，而由于 multiset 是按升序排列的，最大值在最后一个元素，我们可以通过 rbegin() 来取出。

我们也可以使用优先队列来做，即最大堆，不过此时我们里面放一个 pair 对儿，由数字和其所在位置组成的，这样我们就可以知道每个数字的位置了，而不用再进行搜索了。在遍历每个数字时，进行 while 循环，假如优先队列中最大的数字此时不在窗口中了，就要移除，判断方法就是将队首元素的 pair 对儿中的 second（位置坐标）跟 i-k 对比，小于等于就移除。然后将当前数字和其位置组成 pair 对儿加入优先队列中。此时看若 i >= k-1，说明窗口大小正好是 k，就将最大值加入结果 res 中即可

## 面试题 59 - II. 队列的最大值

使用最大堆实现。

关键是在最大堆里面存储的是进队列的编号以及数值，在弹出队列的统计次数。

这样在得到最大值的时候，如果判断当前大顶堆的头数字已经被原来的队列弹出了，那么直接弹出大顶堆头顶的数字，循环如此，知道判断大顶堆的头部数字仍然在队列之中，才返回该值作为最大值。

## 面试题 60. n 个骰子的点数

一.题目描述

把 n 个骰子仍在地上，所有的骰子朝上的一面的点数之和为 s，输入 n，打印出 s 所有可能的值出现的概率。

二.题解

《剑指 offer》上给出的两种方法，尤其是代码，晦涩难懂且没有注释。而 n 个骰子的问题实质就是一个动态规划问题，所以文本主要从动态规划的角度来求解这个问题。首先该问题具备 DP 的两个特征：最优子结构性质和子问题的重叠性。具体的表现在：(1)n 个骰子的点数依赖于 n-1 个骰子的点数，相当于在 n-1 个骰子点数的基础上再进行投掷。(2)求父问题的同时，需要多次利用子问题。由此定义状态转移方程为 𝑓(𝑛,𝑘)表示 𝑛 个骰子点数和为 𝑘 时出现的次数，于是可得:

𝑓(𝑛,𝑘)=𝑓(𝑛−1,𝑘−1)+𝑓(𝑛−1,𝑘−2)+𝑓(𝑛−1,𝑘−3)+𝑓(𝑛−1,𝑘−4)+𝑓(𝑛−1,𝑘−5)+𝑓(𝑛−1,𝑘−6)

其中 𝑛>0 且 𝑘<=6𝑛。其中 𝑓(𝑛−1,𝑘−𝑖)表示的是第 n 次掷骰子时，骰子的点数为 𝑖 对应的情况，所以从 𝑘−1 到 𝑘−6 分别对应第 n 次掷骰子时骰子正面为 1 到 6 的情况。而初始状态可以定义为：

𝑓(1,1)=𝑓(1,2)=𝑓(1,3)=𝑓(1,4)=𝑓(1,5)=𝑓(1,6)=1

## 面试题 61. 扑克牌中的顺子

思路 1：

排序以后检查相邻元素差值，为 0 说明重复，为 1 说明连续，大于 1 的话需要用大小王补

对于大于 1 的差值检查看一下 0 的数量够不够补，不够补直接返回 false

思路 2：

先排序，把零剔除掉，之后看有没有重复，最大最小值的差有没有超过四（超过 4 用零补不齐）

## 面试题 62. 圆圈中最后剩下的数字

f(n,m):表示 每次在 n 个数字 0，1,...,n-1 中删除第 m 个数字最后剩下的数字（也就是要求的结果）。（注意，要求数字标号需要是连续的，所以后面删除一个元素后标号不连续了，需要重新标号）。

在这 n 个数字中，第一个被删除的数字是 (m-1)%n (取余的原因是 m 可能比 n 大)，记作 k，则 k=(m-1)%n。删除后的序列为 0,1,...,k-1,k+1,...,n-1。由于下一次删除是从 k+1 开始计数的，所以相当于从标号为 k+1,k+2,...,n-1,0,1,2,...,k-1 的序列中继续删除第 m 个数字，最终剩下的数字就是结果。

剩下的 n-1 个数字如果重新按顺序标号得到序列 0,1,...,n-2，则每次删除第 m 个数，最后剩下的数字就是 f(n-1,m)。由于重新标号了，所以并不是 f(n,m)=f(n-1,m)! 那么 f(n-1,m)对应的数字在修改标号之前是什么数呢？

事实上，原先的不连续的序列 A(k+1,k+2,...,n-1,0,1,2,...,k-1)变成了序列 B(0,1,...,n-2)，而我们主要是想知道如何从序列 B 中的某个数找到序列 A 中对应的关系，先建立个映射表格：

| B 序列   | 序列 A           |
| -------- | ---------------- |
| 0        | k+1              |
| 1        | k+2              |
| n-k-2    | n-1              |
| n-k-1    | 0                |
| n-k      | 1                |
| n-2      | k-1              |
| f(n-1,m) | (f(n-1,m)+k+1)%n |

根据表格，可以很直观的看出，在 B 序列中数字 x，对应于 A 序列中的(x+k+1)%n（注意：必须取余数，因为 B 序列中为 n-k,而 n-k+k+1 为 n+1,必须取余数才能得到 1）。所以在 B 序列中标号为 f(n-1,m)，对于在 A 序列中就为(f(n-1,m)+k+1)%n。

还记得 k 吗，k 就是在第一次删除的时候删掉的数(与 n 有关的变量)，k=(m-1)%n。

将其带入上面的式子，就得到:

(f(n-1,m)+k+1)%n = (f(n-1,m)+(m-1)+1)%n = (f(n-1,m)+m)%n

因此，我们就得到了这个递归公式，而当 n=1 的时候，也就是序列中只有标号为 0 的数字，显然最后剩下的数字就是 0，所以整个公式就是：

```
f(n, m) = 0           if n == 1
        = f(n-1, m)%n if n > 1
```

根据这个公式，写代码就很简单了。

这种算法的时间复杂度是 O(n)，空间复杂度是 O(1)，远远优于第一种算法，但是推导复杂，数学渣渣表示如果没见过这个题，绝对推导不出来。。。

## 面试题 63. 股票的最大利润

寻找前面的最小值，与当前值相减，统计出现的最大值。

## 面试题 64. 求 1+2+…+n

利用与&& 左侧为 false，不进行后续的判断，即可以中断递归调用。

这个特性实际叫做“骤死性评估”,是一种语言特性，即左侧的表达式为假时整个表达式后续将不再进行评估。

这也就是为什么不要重载&&,||,和逗号操作符的原因，因为重载之后变为函数语义，编译器将不再保证骤死性评估。

## 面试题 65. 不用加减乘除做加法

无计算符来计算两个数的和

位操作。 两个数异或是无进位加法，两个数与是进位的加法。

## 面试题 66. 构建乘积数组

用两个数组，分别记录左边数字所有的积和右边数字所有的积。

然后两个数组对应数字乘起来就是最终结果。

## 面试题 67. 把字符串转换成整数

1. 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回 0.

2. 若第一个非空格字符是符号 +/-，则标记 sign 的真假，这道题还有个局限性，那就是在 c++ 里面，+-1 和-+1 都是认可的，都是 -1，而在此题里，则会返回 0.

3. 若下一个字符不是数字，则返回 0，完全不考虑小数点和自然数的情况，不过这样也好，起码省事了不少。

4. 如果下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。

5. 还需要考虑边界问题，如果超过了整型数的范围，则用边界值替代当前值。

判断是否超出了整数范围，可以这么判断：

```c
if(ans > INT_MAX / 10 || (ans == INT_MAX / 10 && str[right] > '7'))
```

## 面试题 68 - I. 二叉搜索树的最近公共祖先

递归。

## 面试题 68 - II. 二叉树的最近公共祖先

这道求二叉树的最小共同父节点的题是之前那道 Lowest Common Ancestor of a Binary Search Tree 的 Follow Up。跟之前那题不同的地方是，这道题是普通是二叉树，不是二叉搜索树，所以就不能利用其特有的性质，我们只能在二叉树中来搜索 p 和 q，然后从路径中找到最后一个相同的节点即为父节点，可以用递归来实现，在递归函数中，首先看当前结点是否为空，若为空则直接返回空，若为 p 或 q 中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了 p 和 q 一定都在二叉树中存在，那么如果当前结点不等于 p 或 q，p 和 q 要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论：

- 若 p 和 q 分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回 p 和 q 结点的位置，而当前结点正好就是 p 和 q 的最小共同父结点，直接返回当前结点即可，这就是题目中的例子 1 的情况。

- 若 p 和 q 同时位于左子树，这里有两种情况，一种情况是 left 会返回 p 和 q 中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子 2 的情况。还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的左子树中的某个结点才是 p 和 q 的最小父结点，会被返回。

- 若 p 和 q 同时位于右子树，同样这里有两种情况，一种情况是 right 会返回 p 和 q 中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回 p 和 q 的最小父结点，就是说当前结点的右子树中的某个结点才是 p 和 q 的最小父结点，会被返回，写法很简洁
