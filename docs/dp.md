[TOC]

## 二维矩阵路径相关

- 62. 不同路径。这种是二维数组里面寻找路径相关的动态规划，本质上还是依赖于前面已经解决过的，类似于斐波那契亚数列，仅仅依靠前面有限的情况，例如这里仅仅依赖前面相邻的两个格子。

- 63. 不同路径 2. 还是一道二维数据寻找路径个数的问题，不同之处在于存在障碍物，那么根据实际问题实际分析，有障碍物的地方那么路径肯定是 0,同时处理好上边界和左边界情况即可。

- 64. 最小路径和。这道题目和 62 很像，不同之处在于计算路径个数，变成了计算路径的最小权重。本质上一个思路，其次对于这种二维路径的问题，因为要依赖前面相邻的格子，所以最好前单独把上边界和左边界计算出来。

- 221. 最大正方形。 这道题目也是二维矩阵的题目，但是是计算最大的正方形面积，仔细分析规律可以发现，如果当前数字是 0 的话，那么肯定不会产生正方形，如果当前数字是 1,那么当前情况就需要取决于左边的格子，右边的格子和左上角的格子，然后取他们的最小值。关键还是要处理好左边界和上边界的情况。

## 三角形矩阵路径相关

- 120. 三角形最小路径和。三角形路径，这道题目是不能从上到下使用贪心算法，要从下到上使用动态规划。同时，节省空间考虑，仅仅使用一个一维数组 dp，每次更新这个数组，同时缩短数组的有效长度，不断向上更新。

## 表达式匹配

- 10. 正则表达式匹配。模拟法，实际问题实际分析。

- 44. 通配符匹配. 本质上是根据不同的情况（即对应的字符是否相等），来具体选择不同的递推公式，依赖于前面有限的情况。

## 斐波那契亚系列普通变种（有限情况）

大部分动态规划都属于这种，需要实际问题实际分析，找到当前情况是如何依赖前面的情况的，也就是实际情况实际分析，找到递推规律。

- 91. 解码方法。实际问题实际分析。也是依赖前面有限的情况推导现在的情况，属于斐波那契亚系列的普通变种（有限情况）。

- 198. 打家劫舍。 这道题目也是依赖于前面的有限情况，对于这种问题，关键是根据实际问题实际分析，找到当前是如果依赖于前面的情况的。

- 213. 打家劫舍 2。这道题目类似于打家劫舍 1, 本质上将这个问题分解为两个打家劫舍 1 问题，同时处理好特殊情况，特殊情况就是数组大小比较小的时候，一些黑启动的情况，这部分要好好分析，不能依赖错误案例解决，要能够提前想到。

- 32. 最长有效括号：这道题目也是使用动态规划，类似于最长子串的思想，也使用的模拟法，结合具体的题目要求，找到子问题的依赖条件，也就是根据实际情况，推到公式。这道题目特点在于，判断的条件复杂一些，需要结合 stack 来完成，进而满足条件，才能加上之前发生过的情况。

- 746. 使用最小有效花费爬楼梯。斐波那契亚系列普通变种，不过添加了权重，本质上还是当前情况依赖于前面有限的情况。

- 139. 单词拆分。斐波那契亚系列普通变种，根据词典里面不同的单词长度的大小，确定和哪些之前的变量有关，同时，由于是对比很多个之前情况（但也是有限个），可能存在覆盖的现象，要考虑这种问题的解决，就是覆盖现象的解决，一般是使用 max，min 函数用于记录最大最小值，如果是 bool 类型，要用或来进行统计有没有一个是真。

- 303. 区域和检索 - 数组不可变。 这种需要频繁调用的说明，就是我们要考虑使用一些空间，来记录下来，方便多次调用的时候节约时间，空间换时间。

- 44. 通配符匹配。 根据不同的情况来，这个就要具体问题具体分析。这道题目递推公式就是根据不同的情况（有无“\*”），涉及到的之前的情况是有限的，属于斐波那契亚系列普通变种（有限情况）

- 72. 编辑距离。 根据当前 index 的字符是不是相等，当前的情况依赖与前面的有限情况。

## 斐波那契亚系列变种（无限情况）

无限情况在于当前情况的结果，取决于前面 O（n）个情况的综合考虑，一般表现为需要两层遍历。

- 300. 最长递增子序列, 类似于斐波那契亚，要考虑前面的情况，不过这里是遍历前面所有 index，而斐波那契亚是仅仅考虑前面有限的情况，属于斐波那契亚系列变种（依赖前面全部情况）。

- 354. 俄罗斯套娃信封问题。本质上就是一个最长递增子序列的问题。

- 279. 完全平方数字。 属于斐波那契亚系列的变种（依赖前面无限情况）

- 96. 不同的二叉搜索树。属于无限情况的变种。当前情况取决于多个前面的情况，

- 95. 不同的二叉搜索树 2。 属于递归形式的解法，结合记忆数组，也可以看作是动态规划的效果。

- 338. 比特位计数。类似于动态规划的方法，但是需要自己寻找出规律。

- 343. 整数拆分。dp 数组是一维的，但是每种情况需要遍历前面的所有情况，需要双层遍历，因此属于斐波那契亚系列变种（无限情况）。

- 1025. 除数博弈。

## 双 dp 数组问题

适合于对于不同情况，使用不同的 dp 数组的问题，一般问题都是根据不同情况，需要使用不同含义的 dp 数组。

- 152. 乘积最大子数组。这道题目因为有负数的存在，会不时的调换最大值最小值，因此需要使用两个 dp 数组，来记录分别的最大值和最小值。

- 123. 买卖股票的最佳时机 3。 这道题目比较巧妙，超过我的理解能力了，比较难以想到。需要设置一个局部最优数组和全局最优数组。

- 376. 摆动序列. 这道题目也是典型的需要设置两个数组的题目，由于在每个当前情况下，属于两种状态，不同状态要使用不同的 dp 数据，交替前进。

- 309. 最佳买卖股票时机含冷冻期. 这里需要使用双数组的原因是，由于冷却期的存在，使得卖出和买入情况的递推公式不一样，而且交替依赖，因此需要两个数组分别表示持有股票和不持有股票的两种情况。

- 714. 买卖股票的最佳时机含手续费。 这道题目和 309 带冷却期的股票交易很像，只是没有冷却期了，添加了每次的手续费。还是设计两个数组 have[i]与 nothave[i].代表第 i 天手里有或没有股票的最大收益。

## 01 背包（有限情况）

可以使用二维数组空间来进行实现，比较好理解----要么不要，要么要。
优化空间：可以使用两行一维空间来实现，即利用 i%2
优化空间：也可以使用一维数组空间来实现，节省空间，但是要注意第二层便利要反向遍历，避免覆盖了的内容。

- 416. 分割等和子集。将原来的问题转化为是否可以有部分元素组成某一个数字，组成数字的目标和 target 是代价。这里面没有价值的定义，因为是判断 true 或 false.

- 0. 分割相差最小的两个子集。 转化为有限 01 背包问题，背包的大小就是数组和的一半，然后在这个容量之下，找到最大的价值。[链接](https://blog.csdn.net/qq_26222859/article/details/69335310)

- 494. 目标和。本质上是寻找数组的子数组能不能组成和为 target, 并统计子数组的个数。

- 474. 一和零。 本质上是有限背包，但是限制条件变成了两个限制条件，无非就是在 dp 数组上面添加一个维度表示新的限制，递推公式对应的修改为与 dp[i][j][k] 和 dp[i - 1][j - zeros][k - ones]有关;

## 01 背包（无限情况）

- 322. 零钱兑换。 统计组成目标价格的最小硬币数，硬币可以重复使用

- 518. 零钱兑换 II。 统计组成目标价格的所有组成方案，硬币可以重复使用。

## 回文子串子序列问题

对于回文子串：

其实这个问题，可以被归类为斐波那契亚系列变种（无限情况），但是回文子串特点很明显，就将这一类问题提了出来。

也还是符合斐波那契亚系列变种（无限情况）的特点，就是当前情况取决于前面的所有情况都要遍历一下。

这里递推公式，代码实现里面可以简明看出来，基本就是三步：

```c++
dp[i][j] = true
{
if i==j
if j == i+1 && s[i]==s[j]
if dp[i+1][j-1]==true && s[i]==s[j]
}
```

- 5. 最长回文子串问题。 保留遍历过程中的最长值

- 647. 回文子串。统计便利过程中的所有数目。

- 516. 最长回文子序列。类似于最长回文子串的设计思路。

- 730. 统计不同回文子序列个数。这道题目情况比较多，还是附上[链接](https://www.cnblogs.com/grandyang/p/7942040.html)

## 公共子序列问题

本类问题很像斐波那契亚系列普通变种（有限情况），但是公共子序列特征比较明显，也就提炼出来了。

- 1143. 最长公共子序列。 当前的情况，根据是否字符相等，分为两种递推公式，但是每一种递推公式都仅仅与前面的有限情况有关。

## 区间 dp

区间 dp 的特点：子情况是子区间，递推是从一个个小区间（或者说是处理过的小区间），逐步汇总成为大区间。

区间 dp 的遍历有一定的特点，一般区间 dp 是一个字符串，使用二维数组 dp[i][j]表示区间 ij(包含 ij)内的结果。遍历的过程，要保证小区间子情况都要被遍历过。一般采用下三角遍历。

// " b c c b
// b 1 5 6 7
// c 0 1 3 4
// c 0 0 1 2
// b 0 0 0 1

比如这样的矩阵，我们以计算回文子序列为例子，遍历的过程从下三角开始，按照序号开始逐个遍历，因为区间遍历使用的子情况一般是左边，下边和左下边。即 dp[i][j]取决于 dp[i+1][j-1]，dp[i+1][j]，dp[i][j-1]

模板：先更新对角线的情况，这个对于区间 dp 来说很简单，就是一个元素。然后按照下三角的顺序进行遍历。

除此之外，遍历也可以使用 len+起始坐标遍历。如下所示：

```c++
vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));
// 遍历子区间的长度
for (int len = 1; len <= n; ++len) {
    // 遍历子区间的起始坐标，注意右边边界
    for (int i = 1; i <= n - len + 1; ++i) {
        // 计算子区间的结束坐标。
        int j = i + len - 1;
    }
}
```

- 5. 回文子串子序列一系列问题。 题目 5, 516, 647, 730

- 312. 戳气球. 这道题目对于大区间和小区间的关系还可以，但是一个关键点就是戳破气球的分割位置是最后戳破的，这样方便使用戳破气球像中间的积聚的条件。参考[链接](https://www.cnblogs.com/grandyang/p/5006441.html);

- 664. 奇怪的打印机. 这道题目大区间和小区间的递推关系比较难以想到，参考[链接](https://www.cnblogs.com/grandyang/p/8319913.html);

- 1039. 多边形三角剖分的最低得分。 典型的区间 dp，关键还是找到大区间和子区间的递推关系，这道题目的递推关系是用两边的端点作为三角形底边，然后遍历区间纯内部的点作为三角形的顶点，将原来的大区间分为一个中间的三角形和两边的两个子区间情况。还要注意是一个环，需要使用取余%N 还处理环。

- 877. 石子游戏。 这道题目可以使用递归来进行解决，也可以使用动态规划来进行解决，动态规划是类似于区间 dp 的方式。[链接](https://www.cnblogs.com/grandyang/p/10828725.html)

## 树形 dp

树形 dp 本质上看成带记忆的递归好些。

- 337. 打家劫舍 III。

- 124. 二叉树中的最大路径和。

- 543. 二叉树的直径

## 其他（不好分类的）

- 887. 鸡蛋掉落。 使用二维数组，分别表示当前鸡蛋个数和楼层大小，然后分情况讨论。类似于斐波那契亚系列变种（无限情况），对于某次鸡蛋个数 i 和楼层大小 j，要遍历之前所有的楼层位置，找到释放鸡蛋的楼层位置，但是这样做属于三次循环，时间复杂度太高。观察发现，待比较的两个数字具有一个不断增大，一个不断减小的特点，所以最合适的点就是二者相等的时候，或者二者不会相等，互相错过的场景（在其附近），由于具有单调变化的特点，因此可以使用二分查找。

- 最长子串：0 和 1 的个数相同。[链接](https://blog.csdn.net/chdhust/article/details/11831349)

## 游戏对弈

游戏对弈一般可以考虑使用递归的方法来进行解决。

- 292. Nim 游戏

- 293. 翻转游戏。[链接](https://www.cnblogs.com/grandyang/p/5224896.html)

- 294. 翻转游戏之二。[链接](https://www.cnblogs.com/grandyang/p/5226206.html)

- 877. 石子游戏。 这道题目可以使用递归来进行解决，也可以使用动态规划来进行解决，动态规划是类似于区间 dp 的方式。[链接](https://www.cnblogs.com/grandyang/p/10828725.html)

## 记忆化递归

- 329. 矩阵中的最长递增路径。

- 576. 出界的路径数。 使用记忆化递归实现可以，但是注意特殊点判断，否则这道题目递推可能超时,可以参考代码实现里面的注释。或者使用动态规划来进行。[链接](https://www.cnblogs.com/grandyang/p/6927921.html)

- 526. 优美的排列. 这道题目不使用记忆化也可以通过，单纯的递归。

## 状态压缩 dp

状态压缩 dp 就是利用计算机二进制的性质来描述状态的 dp，因为在某些情况下，表示一个动态规划问题的状态需要的维度太多了，使用多维数组来保存太浪费空间，而且编写代码也不简洁。如果表示一个动态规划状态的维度比较高，同时每一个维度就两种状态，那么就可以使用二进制来存储不同的状态，使用 hashmap 来做记忆化存储，hashmap 存储的键就是一个整数，该整数的不同位记录了不同的状态。

- 464. 我能赢吗。 这道题目使用递归可以实现，但是超时，需要记忆化递归处理。但是需要记忆化的维度又太大，所以考虑使用状态压缩可以实现。
