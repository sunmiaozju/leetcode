- 对于计算一个数组是不是可以分成两个相等的部分，其实就可以转化为一个数组是不是可以找到一个子数组等于原数组的和的一半。
- 背包问题可以简化为使用一维度 dp 数组，但是注意遍历的时候要从大到小来进行遍历，避免 dp[n]c-cap[i]]里面的 c-cap[i]被覆盖，因为他需要的是左边的数字。
- 一般来讲，如果递归函数仅仅和 i-1 的状态有关，那么就其实不必维护二维递归数组，而维护一维度递归数组即可。因为维护二维递归数组前面都用不到，仅仅用到 i-1
- 深度优先搜索要注意及时清除标记
- 对于位操作，当作 mask 的变量，使用 unsigned int 比使用 int 要好，因为对于有符号数的左移（尤其是负数），会很麻烦。若是负数右移，左侧空缺是补 1 的，符号位为 1 不变。正数右移，左侧空缺补 0. 负数左移，会不断修改符号位，最终会变成 0.
- 回溯法注意不要提前返回，因为后面还有清理标志的工作没有做。有的时候判断达到了最终标准，然后直接返回，这是不对的，一定要确保函数最后离开了的时候清理的标志。
- 这种方法可以修改优先队列的比较方式

```c++
auto cmp = [](ListNode*& a, ListNode*& b) {
    return a->val > b->val;
};
priority_queue<ListNode*, vector<ListNode*>, decltype(cmp) > q(cmp);
```
